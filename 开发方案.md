这是一个非常出色且专业的项目！你的顶层设计文档（V4.0）非常清晰、结构合理，前端Figma设计也高度专业。你对AI照片分析的流程理解深刻，特别是“两阶段分析”和“结构化输出”的思路，这是成功的关键。

我将为你提供一套详尽的开发方案，严格遵循你的设计文档，并整合你提出的新需求（如Gemini Flash生成仿色示意图），解决你担心的核心问题（特别是Gemini的“随机性”）。

-----

## 🎯 核心评估与战略建议

在开始详细计划之前，我们先解决你提出的几个关键问题：

1.  **【核心问题】如何处理Gemini的“随机性”？**

      * **问题：** 你担心Gemini返回的JSON不规范，导致后端解析和前端展现失败。
      * **解决方案：【后端验证与规范化层】**。这是整个项目中最关键的非功能性模块。我们不能100%相信Gemini的Prompt。
      * **执行：** 后端在`analysisFormatter`服务中，必须使用一个强大的Schema验证库（例如 **Zod** 或 **Joi**）。
          * 为Part1和Part2的JSON输出**分别定义严格的Zod Schema**。
          * 当Gemini返回JSON后，**立即**用Schema进行解析（`schema.parse(geminiJson)`）。
          * **如果验证通过**：直接使用。
          * **如果验证失败（或字段缺失）**：
              * **启用“兜底（Fallback）”逻辑**：`analysisFormatter`不仅是映射，更是“修复”层。例如，如果`lightroom.exposure`缺失，它应自动插入默认值`"+0"`，而不是让程序崩溃。
              * **记录日志**：必须（如你文档所说）记录`warn`日志，指出哪些字段缺失或格式错误，以便你迭代Prompt。
              * **前端提示**：在`meta.notes`中（如你文档所说）登记问题，前端可以显示一个“部分参数AI未提供，已使用默认值”的提示。
      * **结论：** **我们不靠祈祷Prompt完美，而是靠后端的“验证器+修复器”来保证100%的数据结构稳定。**

2.  **【新需求】Gemini Flash生成仿色示意图**

      * **评估：** 这是一个关键的、提升用户体验的功能，但你的V4.0文档中没有。它改变了Part2的流程。
      * **执行：** 我会将其整合为“**分析阶段三（Part 3）**”，它紧跟在Part2之后，在同一个后端任务流中执行。
      * **流程：** 用户点击触发Part2 -\> 后端**异步**执行Part2（获取LR/PS参数）-\> **然后**立即执行Part3（使用刚拿到的参数和用户图去调用Gemini Flash Image）-\> 所有数据（JSON+示意图URL）全部准备好后，才更新数据库状态，前端通过轮询获取最终结果。

3.  **【Prompt问题】是否需要输出直方图？**

      * **回答：** **绝对不要让AI输出直方图数据**。
      * **原因：**
        1.  AI（Gemini）是一个语言和视觉模型，它不擅长（也不能）执行像素级的数学计算。
        2.  直方图是一个需要遍历图片所有像素来生成的**精确数学**图表。
      * **正确方案：【前端计算】**
          * Figma中的三个直方图（参考图、用户图、仿色后）必须**全部在前端（浏览器）生成**。
          * **技术选型：** 使用`Canvas` API。
          * **流程：**
            1.  前端加载“参考图”（`Image`对象）。
            2.  将其绘制到内存中的`Canvas`上。
            3.  使用`canvas.getContext('2d').getImageData()`获取像素数据。
            4.  前端JS遍历此数据，计算R, G, B的直方图。
            5.  使用图表库（如`Chart.js`或`D3.js`）绘制直方图。
          * “仿色后”的直方图，则在Part3（Gemini Flash）返回示意图后，对该示意图执行上述1-5步。

4.  **【架构冲突】你的Prompt vs 你的设计文档**

      * 你的V4.0文档定义了**清晰的“两阶段分析”**（Part1基础洞察 / Part2详细参数），这是**非常正确**的架构，可以快速响应Part1，避免用户等待。
      * 你提供的**Prompt模版**是一个\*\*“单体Prompt”**（Step 1-6一次性完成），这与你的两阶段架构相**冲突\*\*。
      * **解决方案：** 我们必须**拆分你的Prompt模版**。
          * **Part 1 Prompt**：将使用你的模版中的Step 1（专业评价）、Step 2（影像分析）、Step 4（可行性评估）以及V4.0文档中的“工作流草案”。
          * **Part 2 Prompt**：将使用你的模版中的Step 3（光影参数）、Step 5（复刻逻辑）、Step 6（结构化JSON）以及V4.0文档中的“工作流执行总结”。

-----

## ⚙️ 详细开发方案：从0到1（精细化任务）

我将把整个项目分为4个核心里程碑，包含主站、管理后台和帐权体系，任务已细化到“Cursor可执行”级别。

### Milestone 0: 地基与核心验证器（1-2天）

**目标：** 搭建所有服务，实现登录注册，并构建“Gemini随机性”的防火墙（Validator）。

| 模块 | 任务详情（可直接复制为TODO） |
| :--- | :--- |
| **通用** | 1. 初始化项目：`pnpm workspace`（推荐），包含`apps/frontend`、`apps/backend`、`apps/admin`。 |
| **后端** | 1. 搭建Node.js + Express + TS环境。 |
| | 2. 数据库：使用`mysql2`连接。按V4.0文档，创建`analysis_tasks`、`uploads`、`users`表。 |
| | 3. **【帐权】** 搭建Auth：`POST /api/auth/register`, `POST /api/auth/login`。使用`bcrypt`加密，`JWT`生成Token。 |
| | 4. **【帐权】** 编写`authMiddleware.js`：验证JWT `Authorization` 头，并将`req.user`注入请求。 |
| | 5. **【核心】** 安装`zod`。创建`src/validators/geminiSchemas.js`。 |
| | 6. **【核心】** 在`geminiSchemas.js`中，严格按照你Prompt的Step 6，定义`Part1ResponseSchema`和`Part2ResponseSchema`。 |
| | 7. **【核心】** `Part2ResponseSchema`示例：`lightroom: z.object({ exposure: z.string().default("+0"), ... })`。（**注意**：使用`.default("+0")`来自动修复缺失字段）。 |
| **前端** | 1. 搭建React + Vite + TS环境。 |
| | 2. **【帐权】** 创建`AuthContext.js`（React Context），用于全局存储Token和用户信息。 |
| | 3. **【帐权】** 创建`/login`和`/register`页面（简单表单即可）。 |
| | 4. **【帐权】** 创建`axios`实例（`src/services/api.ts`），配置拦截器，自动附带Auth Token。 |
| **管理后台** | 1. 搭建*另一个*React + Vite项目（`/admin`）。 |
| | 2. 使用`Ant Design`或`MUI`快速搭建布局。 |
| | 3. 创建Admin的登录页，调用`POST /api/auth/login`（可与主站共用，但Token管理分开）。 |

-----

### Milestone 1: 主站核心流程 - Part 1（2-3天）

**目标：** 实现用户上传、触发Part 1分析、前端展示Part 1卡片（点评、构图）。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[上传]** 实现`PhotoUploadZone.tsx`：支持拖拽和点击。 |
| | 2. **[上传]** 图片预览使用`URL.createObjectURL`（比Base64高效）。 |
| | 3. **[上传]** 上传时，*并行*调用`POST /api/photos/upload`（如V4.0文档）。 |
| | 4. **[分析]** 点击“开始AI分析”：<br>      a. 显示全屏Loading（如V4.0文档）。<br>      b. 调用`POST /api/analyze/part1`，传入`uploadId`。 |
| | 5. **[结果]** `AdjustmentResults.tsx`：接收API返回的`structuredAnalysis`。 |
| | 6. **[结果]** `CompositionSection.tsx`：根据Figma设计，渲染`composition.advanced_sections`的七个板块。 |
| | 7. **[结果]** `ProfessionalReview.tsx`：渲染`professional_evaluation`的自然语言。 |
| | 8. **[直方图]** 创建`Histogram.tsx`组件（使用`Canvas`或`Chart.js`）。<br>      a. 接收`imageSrc` (URL)。<br>      b. 在`useEffect`中加载图片，计算并绘制直方图。 |
| | 9. **[直方图]** 在Figma页面中（“专业摄影点评”下方）显示“参考图”和“用户图”的`Histogram`组件。 |
| **后端** | 1. **[Prompt]** 创建`src/services/promptTemplate.js`。 |
| | 2. **[Prompt]** 创建`getPart1Prompt(image1, image2)`函数，内容为你Prompt的Step 1, 2, 4 + V4.0的“工作流草案”要求。 |
| | 3. **[路由]** 实现`POST /api/photos/upload`（V4.0）。 |
| | 4. **[路由]** 实现`POST /api/analyze/part1`（V4.0）。（注意：此路由受`authMiddleware`保护）。 |
| | 5. **[服务]** `analyzeService.js`：<br>      a. 从`uploads`表获取图片数据。<br>      b. 调用`geminiService.js`（传入Part 1 Prompt）。<br>      c. **[核心]** 获取Gemini的JSON字符串。 |
| | 6. **[服务]** `analysisFormatter.js`：<br>      a. `formatPart1(geminiJson)`：<br>      b. `const validatedData = Part1ResponseSchema.parse(geminiJson)`。（**Zod验证在此！**）<br>      c. 记录验证中产生的任何`warn`或`error`。<br>      d. 返回`validatedData`（即`structured_result`）。 |
| | 7. **[服务]** `taskService.js`：将`validatedData`、`taskId`、`part1_summary`、`workflow_draft`等存入`analysis_tasks`表。 |
| | 8. **[响应]** `part1`接口返回`{ taskId, structuredAnalysis }`。 |

-----

### Milestone 2: 主站核心流程 - Part 2 & 3（3-4天）

**目标：** 实现点击LR/PS卡片，触发Part2（参数）和Part3（示意图）的生成，并使用**轮询**机制在前端展示最终结果。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[状态]** `AdjustmentResults.tsx`维护一个状态，如`isPart2Loading`。 |
| | 2. **[触发]** 当用户点击“Lightroom”、“Photoshop”或“色彩方案”卡片时，检查`part2_completed`状态。 |
| | 3. **[触发]** 如果未完成，调用`triggerPart2Analysis(taskId)`。 |
| | 4. **[异步]** `triggerPart2Analysis`函数：<br>      a. `POST /api/analyze/part2`（传入`taskId`）。此接口应**立即**返回`{ status: 'processing' }`。<br>      b. `isPart2Loading = true`。<br>      c. **[轮询]** 启动一个`setInterval`，每3秒调用一次`GET /api/analyze/:taskId`。 |
| | 5. **[轮询]** `GET /api/analyze/:taskId`的处理器：<br>      a. 检查返回数据中的`status`字段。<br>      b. 如果`status === 'completed'`，则：<br>          i. 清除`setInterval`。<br>          ii. `isPart2Loading = false`。<br>          iii. 将返回的完整`structuredAnalysis`（含LR/PS/Color/PreviewImage）存入状态。 |
| | 6. **[渲染]** LR/PS/色彩卡片根据`structuredAnalysis`中的数据自动渲染。 |
| | 7. **[渲染]** 在Figma的“仿色示意图”位置，渲染`structuredAnalysis.preview_image_url`。 |
| | 8. **[渲染]** “仿色后”的`Histogram`组件，传入`structuredAnalysis.preview_image_url`。 |
| **后端** | 1. **[Prompt]** `promptTemplate.js`：创建`getPart2Prompt(part1Context, ...)`函数，内容为你Prompt的Step 3, 5, 6 + V4.0的“工作流执行总结”。 |
| | 2. **[Prompt]** `promptTemplate.js`：创建`getPart3FlashPrompt(userImage, styleParams)`函数。<br>      *Prompt示例：“你是一个修图师。将这张[用户图]按照以下[LR/PS参数或风格描述]进行处理，生成一张仿色后的示意图。”* |
| | 3. **[路由]** `POST /api/analyze/part2`：<br>      a. （受Auth保护）获取`taskId`。<br>      b. **[异步]** **不使用`await`**，调用一个`async`函数 `runPart2And3Job(taskId)`。<br>      c. **立即返回**`{ status: 'processing' }`。 |
| | 4. **[路由]** `GET /api/analyze/:taskId`：<br>      a. （受Auth保护）查询`analysis_tasks`表。<br>      b. 返回`{ status, structured_result, natural_language_part1, ... }`。 |
| | 5. **[核心Job]** `runPart2And3Job(taskId)`：<br>      a. **Part 2**: 调用`geminiService.js` (Part 2 Prompt)，获取LR/PS JSON。<br>      b. **验证**: `const validatedP2 = Part2ResponseSchema.parse(geminiJson)`（**Zod在此！**）<br>      c. **Part 3**: 调用`geminiService.js` (Gemini Flash，使用Part 3 Prompt)，获取示意图URL/Base64。<br>      d. **[存储]** 将`validatedP2`（LR/PS参数）和`preview_image_url`（示意图）**合并**到`structured_result`中。<br>      e. **[更新]** `UPDATE analysis_tasks SET structured_result = ?, status = 'completed', part2_completed = 1 WHERE id = ?`。 |
| | 6. **[存储]** （可选但推荐）如果示意图是Base64，应先上传到对象存储（如S3/OSS），只在数据库存URL。 |

-----

### Milestone 3: 导出与报告（1-2天）

**目标：** 实现Figma上的“导出XMP”、“导出JSX”和“下载报告”功能。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. 在`AdjustmentResults.tsx`中添加3个下载按钮。 |
| | 2. 按钮点击事件（示例）：`window.open('/api/export/xmp?taskId=TASK_ID&token=JWT_TOKEN')`。（注意：GET请求下载文件时，Auth Token需要作为Query参数传递）。 |
| **后端** | 1. **[Auth]** 编写一个`authMiddlewareForQuery`，用于从URL查询参数中获取Token并验证（专用于文件下载）。 |
| | 2. **[路由]** `GET /api/export/xmp` (V4.0) (使用`authMiddlewareForQuery`）。 |
| | 3. **[服务]** `exportService.js`：<br>      a. `generateXMP(taskId)`：<br>      b. 从`analysis_tasks`获取`structured_result`。<br>      c. 使用`fs.readFileSync`读取一个**XMP模板文件**。<br>      d. 使用`structured_result.lightroom`中的参数（如`exposure`）替换模板中的占位符。<br>      e. `res.setHeader('Content-Type', 'application/xml')`。 `res.send(finalXmlString)`。 |
| | 4. **[路由]** `GET /api/export/jsx` (V4.0) (同上，但使用JSX模板)。 |
| | 5. **[路由]** `GET /api/report/pdf`（**新**）：<br>      a. 使用`puppeteer`或`pdfkit`。<br>      b. （推荐`puppeteer`）创建一个HTML模板（`report.html`），使用`EJS`或`Handlebars`作为模板引擎。<br>      c. 加载`structured_result`，渲染HTML。<br>      d. `puppeteer.launch()...page.setContent()...page.pdf()`。<br>      e. `res.setHeader('Content-Type', 'application/pdf')`。`res.send(pdfBuffer)`。 |

-----

### Milestone 4: 管理后台与历史记录（2-3天）

**目标：** 实现V4.0规划中的“历史任务列表”和“管理后台”。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[历史]** `GET /api/analyze/history`（V4.0）。（注意：分页，`?limit=20&page=1`）。 |
| | 2. 在主站添加“我的历史”页面，列表展示历史任务，点击可跳转到`AdjustmentResults`（即`GET /api/analyze/:taskId`）。 |
| **后端** | 1. **[路由]** `GET /api/analyze/history` (V4.0)：<br>    ˆ `SELECT id, status, created_at, source_image_thumbnail FROM analysis_tasks WHERE userId = ? ORDER BY created_at DESC LIMIT ? OFFSET ?`。（需要为`uploads`表生成缩略图）。 |
| **管理后台** | 1. **[路由]** `GET /api/admin/tasks` (分页, 可搜索`userId`或`taskId`)。 |
| | 2. **[路由]** `GET /api/admin/tasks/:taskId` (返回**原始**`gemini_result`和**已验证**的`structured_result`，用于调试Prompt)。 |
| | 3. **[路由]** `GET /api/admin/users` (用户列表)。 |
| | 4. **[前端]** `Admin/Tasks.tsx`：使用`Ant Design`的`Table`组件，展示`GET /api/admin/tasks`的数据。 |
| | 5. **[前端]** `Admin/TaskDetail.tsx`：<br>    ˆ 左侧显示`gemini_result`（原始JSON）。<br>    ˆ 右侧显示`structured_result`（Zod修复后的JSON）。<br>    ˆ **(这是调试Prompt最关键的页面)**。 |
| | 6. **[前端]** `Admin/Users.tsx`：展示用户列表。 |

-----

## 📑 附录：已优化的Prompt策略（按两阶段拆分）

你不再使用那个单体Prompt，而是使用这两个：

### 1\. Part 1 Prompt (用于 `POST /api/analyze/part1`)

> (角色定义：资深摄影师...)
>
> 【输入】
>
>   * `reference_image`: ...
>   * `user_image`: ...
>
> 【任务】
> 你将执行第一阶段的基础洞察。输出必须包含**自然语言报告**和**JSON**两部分。
>
> 1.  **自然语言报告 (Part 1)**：
>       * 执行你原Prompt的**Step 1（专业摄影师视角评价）**。
>       * *（请注意：如果提供了user\_image，对比分析表必须在此处输出）。*
> 2.  **JSON (Part 1)**：
>       * `professional_evaluation`: (你原Prompt Step 1的结构化版本)。
>       * `analysis_meta`: (你原Prompt Step 2, 4的结合，包含`composition`、`resolution`、`conversion_feasibility`等)。
>       * `workflow_draft`: (V4.0文档要求) 包含对后续Part2的初步工作流草案。

### 2\. Part 2 Prompt (用于 `POST /api/analyze/part2`)

> (角色定义：影像后期专家...)
>
> 【输入】
>
>   * `reference_image`: ...
>   * `user_image`: ...
>   * `part1_context`: (一个JSON对象，包含Part 1的`professional_evaluation`摘要和`workflow_draft`)
>
> 【任务】
> 你将执行第二阶段的详细参数执行。根据`part1_context`中的草案，为`user_image`生成复刻`reference_image`的详细参数。
>
> 1.  **自然语言报告 (Part 2)**：
>       * 工作流执行总结：说明你如何（沿用/调整/新增）`part1_context.workflow_draft`中的步骤。
>       * LR/PS调色思路的自然语言描述。
> 2.  **JSON (Part 2)**：
>       * 严格执行你原Prompt的**Step 3, 5, 6**。
>       * `lightroom`: (包含所有基础滑块, tone\_curve, rgb\_curves, HSL, color\_grading...)
>       * `lightroom_panels`: (详细面板)
>       * `lightroom_local_adjustments`: (局部调整)
>       * `photoshop`: (所有步骤)
>       * `color_mapping`: (V4.0要求)
>       * `workflow_alignment_notes`: (V4.t要求，说明与草案的差异)

-----

### 3\. Part 3 Prompt (用于Gemini Flash Image)

> (这是一个全新的、简单的Prompt)
>
> 【输入】
>
>   * `user_image`: ... (用户图)
>   * `style_summary`: (一个简短的JSON或文本，包含Part 2生成的关键参数，例如: `{ "exposure": "+0.5", "contrast": "+15", "highlights": "-30", "temperature": "+120", "tint": "+8", "shadow_hue": 230, "highlight_hue": 35 }`)
>
> 【任务】
> 你是一个AI照片编辑器。请**严格**按照`style_summary`中的参数调整`user_image`。不要发挥创意，只需应用这些调整，生成一张“仿色后”的示意图。

## 开发方案

### 0. 本轮迭代统一约定与范围边界

#### 0.0 服务启动检查清单（强制要求）

**问题背景**：在开发过程中曾出现路由404问题，根本原因是应用无法正常启动，导致路由未注册。为避免类似问题，特制定此检查清单。

**启动前必须检查**：

1. **依赖安装检查**：
   - 确保所有 `requirements.txt` 中的依赖已安装：`pip install -r requirements.txt`
   - 关键依赖包括：
     - `python-jose[cryptography]`（JWT认证）
     - `email-validator`（邮箱验证）
     - `pydantic-settings`（配置管理）
     - `reportlab`（PDF生成，可选）
   - 如果使用代理，可能需要 `--trusted-host` 参数：
     ```bash
     pip install --trusted-host pypi.org --trusted-host pypi.python.org --trusted-host files.pythonhosted.org -r requirements.txt
     ```

2. **环境变量配置检查**：
   - 检查 `.env` 文件是否存在，且包含必需配置：
     - `GEMINI_API_KEY`（必需）
     - `GEMINI_MODEL`（可选，默认 `gemini-2.5-pro`）
     - `GEMINI_TIMEOUT_MS`（可选，默认 `120000`）
     - `SECRET_KEY`（必需，生产环境必须修改）
     - `DATABASE_URL`（可选，默认 SQLite）
   - 确保 `Settings` 类中定义了所有环境变量字段（见第 0.2 节）

3. **Pydantic 配置检查**：
   - `Settings` 类的 `Config` 中必须设置 `extra = "ignore"`，允许环境变量中有额外字段但不报错
   - 所有环境变量字段必须在 `Settings` 类中定义，或使用 `extra = "ignore"` 忽略未定义字段

4. **SQLAlchemy 模型检查**：
   - **禁止使用保留字段名**：`metadata`、`query`、`registry` 等是 SQLAlchemy 的保留字
   - 如果必须存储元数据，使用 `extra_data` 或 `meta_data` 等替代名称
   - 检查所有模型类，确保无保留字段冲突

5. **路由注册验证**：
   - 启动服务后，访问 `http://localhost:8081/openapi.json` 检查所有路由是否注册
   - 使用以下命令验证：
     ```bash
     curl -s http://localhost:8081/openapi.json | python3 -c "import json, sys; data = json.load(sys.stdin); paths = list(data.get('paths', {}).keys()); print('Total routes:', len(paths)); [print(p) for p in sorted(paths) if '/api/' in p]"
     ```
   - 预期应看到所有路由：`/api/auth/*`、`/api/photos/*`、`/api/user/*`、`/api/analyze/*`、`/api/export/*`、`/api/simulate/*`、`/api/admin/*`

6. **CORS 配置检查**：
   - 开发环境：`allow_origins` 必须明确指定 `["http://localhost:3001", "http://127.0.0.1:3001"]`
   - **禁止**使用 `allow_origins=["*"]`，因为当 `allow_credentials=True` 时，浏览器会拒绝此配置
   - 生产环境：通过 `FRONTEND_ORIGINS` 环境变量配置允许的前端域名

7. **端口配置检查**：
   - 前端：`vite.config.ts` 中 `server.port` 必须为 `3001`
   - 后端：`server_py/run.py` 中 `port` 必须为 `8081`
   - 确保端口未被占用

**常见错误与解决方案**：

| 错误信息 | 原因 | 解决方案 |
|---------|------|---------|
| `ModuleNotFoundError: No module named 'jose'` | `python-jose` 未安装 | `pip install python-jose[cryptography]` |
| `ImportError: email-validator is not installed` | `email-validator` 未安装 | `pip install email-validator` |
| `pydantic_core.ValidationError: Extra inputs are not permitted` | 环境变量中有未定义字段 | 在 `Settings` 类中添加该字段，或设置 `extra = "ignore"` |
| `sqlalchemy.exc.InvalidRequestError: Attribute name 'metadata' is reserved` | 使用了 SQLAlchemy 保留字段名 | 重命名为 `extra_data` 或其他非保留名称 |
| 路由返回 404 | 应用启动失败，路由未注册 | 检查上述所有项，查看启动日志 |

**验证命令**：
```bash
# 1. 检查依赖
python3 -c "from jose import jwt; from email_validator import validate_email; print('✅ 依赖检查通过')"

# 2. 检查配置加载
python3 -c "import sys; sys.path.insert(0, 'server_py'); from app.config import get_settings; s = get_settings(); print('✅ 配置加载成功')"

# 3. 检查应用启动
python3 -c "import sys; sys.path.insert(0, 'server_py'); from app.main import create_app; app = create_app(); print('✅ 应用启动成功，路由数:', len([r for r in app.routes if hasattr(r, 'path')]))"
```

#### 0.1 前端变量命名规范（防止重复声明问题）

**问题背景**：在 `ThemeCardsGrid.tsx` 中曾出现 `taskId` 重复声明错误（props 与 state 同名），导致语法错误。

**规范定义**：
- **禁止**：组件内部声明与 props 同名的 state 或变量
- **要求**：如果 props 需要转换为内部状态，应使用计算值或重命名
- **命名规范**：
  - **Props 参数**：使用原始名称（如 `taskId`、`userId`、`imageUrl`）
  - **内部计算值**：使用 `currentXxx` 或 `internalXxx`（如 `currentTaskId`、`internalUserId`）
  - **内部 state**：使用 `xxxState` 或 `xxxData`（如 `taskIdState`、`userData`）
  - **函数参数**：如果函数参数与 props 同名，使用 `propXxx` 或 `paramXxx`（如 `propTaskId`、`paramUserId`）

**示例**：
```typescript
// ✅ 正确：使用 propTaskId 避免与内部变量冲突
interface ThemeCardsGridProps {
  taskId?: string;
}
export function ThemeCardsGrid({ taskId: propTaskId }: ThemeCardsGridProps) {
  // 计算值：从 propTaskId 或 results 中获取
  const currentTaskId = propTaskId || results?.meta?.taskId;
  
  // 内部 state：使用不同的名称
  const [taskIdState, setTaskIdState] = useState<string | null>(null);
}

// ❌ 错误：props 与 state 同名
export function BadComponent({ taskId }: { taskId: string }) {
  const [taskId, setTaskId] = useState<string>(''); // 语法错误！
}
```

**检查清单**：
- 所有组件在实现前，检查 props 名称是否与内部 state/变量冲突
- 如果存在冲突，优先重命名 props 参数（使用解构重命名）
- 代码审查时，使用 ESLint 规则检查重复声明

### 0. 本轮迭代统一约定与范围边界（原内容）

- **运行环境与端口配置（强制要求）**
  - **前端**：Vite 开发服务器，**必须**运行在 `http://localhost:3001`
    - 配置文件：`vite.config.ts` 中 `server.port` 必须设置为 `3001`
    - 不允许使用其他端口（如 3000），避免与开发方案不一致
  - **后端**：FastAPI 应用，**必须**运行在 `http://localhost:8081`
    - 启动文件：`server_py/run.py` 中 `port=8081`
  - **数据库**：开发环境使用 SQLite（`./photostyle.db`），生产环境使用 MySQL
  - **代理**：ClashX 代理地址 `http://127.0.0.1:7890`（用于访问 Gemini API）
  
- **CORS 跨域配置（强制要求）**
  - **开发环境**：
    - 后端 CORS 中间件必须明确指定允许的源：`["http://localhost:3001", "http://127.0.0.1:3001"]`
    - **禁止**使用 `allow_origins=["*"]`，因为当 `allow_credentials=True` 时，浏览器会拒绝 `["*"]` 配置
    - 这是浏览器的安全策略，无法绕过
  - **生产环境**：
    - 通过环境变量 `FRONTEND_ORIGINS` 配置允许的前端域名（多个用逗号分隔）
    - 例如：`FRONTEND_ORIGINS="https://example.com,https://www.example.com"`
    - 如果未配置，默认不允许任何跨域请求（安全）
  - **配置位置**：
    - 后端：`server_py/app/main.py` 中的 `CORSMiddleware` 配置
    - 前端：`src/lib/api.ts` 中的 `API_BASE_URL`（默认 `http://localhost:8081`）
  - **验证方法**：
    - 启动前后端后，在浏览器控制台检查是否有 CORS 错误
    - 如果出现 "No 'Access-Control-Allow-Origin' header" 错误，检查后端 CORS 配置

- **后端技术栈与代码目录**
  - 本轮迭代后端统一采用 **Python（FastAPI/Flask）+ `server_py/app/**` 这套实现**；
  - 任何 `server/src/**`、Node.js + Express 相关代码与示例仅作为"历史/废弃参考"，**不再扩展**；
  - 未来如需 Node 版本，将单独开新迭代与文档，本方案默认所有新接口与服务均落在 `server_py/app` 下。

- **Admin 模拟数据与调试开关**
  - 现有 Admin 前端中使用 LocalStorage 的 store（`subscriptionStore`、`subscriptionUsersStore`、`paymentStore` 等）仅作为 Figma 还原与开发期模拟；
  - **生产环境要求**：
    - 不再展示“恢复默认模拟数据 / 清空数据 / 显示调试 JSON”等按钮（方案 3：删除，仅保留真实数据视图）；
    - 如需调试工具，统一以受限的 Admin 接口实现（例如 `/api/admin/plans/reset-defaults`），并通过权限/环境控制访问；
  - Cursor/开发在对接真实后端时，需移除或注释掉所有依赖 LocalStorage 模拟数据的生产代码路径。

- **复刻可行性 Feasibility 计算主导方**
  - **当前迭代 Feasibility 完全由系统算法主导**，不再通过 Gemini 输出 L/C/S/P/D/T/Q/R 的 score：
    - 由后端 CV/图像分析模块 + 规则引擎计算各指标分值与 FeasibilityScore（第 26 节的权重与阈值）；
    - Gemini 仅参与 Part1/Part2/Part3 的 **视觉+文案分析与调色参数生成**，不参与“能不能仿色”的数值判定；
  - 这样可以避免：
    - Feasibility 与实际调色参数之间的语义冲突；
    - 由于 Feasibility 额外调用带来的时延与成本；
  - Feasibility Prompt（如需使用）只负责**解释 CV 算法的结果**，而非重新做数值判断。

- **直方图数据来源与精度要求**
  - 直方图分为两类：
    - **真实像素级直方图 bins**：由前端 Canvas 或后端图像处理库（如 Pillow/sharp）根据图片像素计算，为“权威数据”；
    - **模拟后目标直方图**：在风格模拟/仿色场景中，**希望 Gemini 能给出目标直方图的数值与摘要**，再由前端据此渲染：
      - Gemini 输出的直方图数值可以采用低分辨率区间（如按 shadows/midtones/highlights 划分的比例数组），以及形状描述（峰形/双峰/偏暗等）；
      - 前端根据这些区间数值绘制“模拟目标直方图”，与真实 bins 形成对比视图；
  - 本方案约定：
    - **基础直方图**（源图、用户原图、风格模拟结果图）仍由像素级算法计算；
    - **“理想仿色直方图”或“目标直方图形态”** 由 Gemini 按 Prompt 返回区间数值 + 摘要，落在 `histogram_overview` 等字段中，前端用于绘制“建议曲线/理想直方图”；
    - 开发时以“真实 bins 驱动核心分析，模型摘要驱动解释与辅助可视化”为准，不反向依赖模型猜测 bins。

- **Feasibility 的业务行为与强制继续策略**
  - 当 Feasibility 算法检测到致命不兼容（deal-breakers）或 FeasibilityScore 较低时：
    - 前端必须弹出可行性模态框，明确风险与建议（第 26 节定义）；
  - **但允许用户选择“强制继续”**：
    - 模态框提供主按钮“继续分析（我接受风险）”，仅在用户明确确认后才调用 `POST /api/analyze/part1`；
    - 后端在日志与 `analysis_tasks.feasibility_result` 中记录该任务是“在低可行性情况下强制继续”的标记（例如 `forced_continue: true`），便于后期分析；
  - 这意味着：Feasibility 作为“强提示 +流量/成本保护”，但不会绝对阻止用户继续实验。

- **用量与订阅额度约束（严格限流）**
  - 订阅与额度绑定规则见第 27 节，本节统一补充硬约束：
    - 每次任务完成 Part1+Part2 计入一次“分析任务”；每次 Part3 成功生成预览图计入一次“生成照片”；
    - 超出当前订阅的 `analysis_per_month` / `generations_per_month` 时：
      - 后端禁止再调用 Gemini 或 CV 模型，直接返回业务错误码：
        - `USAGE_ANALYSIS_LIMIT_EXCEEDED` 或 `USAGE_GENERATION_LIMIT_EXCEEDED`；
      - 前端应在按钮上展示升级或更换套餐提示，阻止进一步点击；
  - 不允许“超额后继续悄悄扣量或软性提醒”，限额是硬边界。

- **用户抽屉“编辑资料 / 安全设置”范围**
  - 本轮迭代内，用户抽屉中的 `ProfilePanel` 需实现**完整的资料编辑与基础安全设置**：
    - 可编辑：头像、昵称、邮箱（依据业务需求）、个性签名等基本文本字段；
    - 安全相关：修改密码（输入旧密码 + 新密码 + 确认）、退出所有设备（可选）、查看最近登录记录（可选）；
  - 对应接口包括但不限于：
    - `PUT /api/user/profile`（修改资料）；
    - `POST /api/user/change-password`（修改密码）；
    - `GET /api/user/security/logins`（最近登录记录，可选）；
  - 后续更高级安全功能（多因子登录等）可以在后续版本扩展。

- **“我的仿色”点击行为**
  - “我的仿色”列表（`ReportsPanel`）点击单条记录的首选行为为：**跳转到主站的结果页，复用现有 UI**：
    - 路由示例：`/results/:taskId`，由现有 `ResultsPage` / `App` 结果视图加载 `GET /api/analyze/:taskId`；
    - 在结果页中用户可再次查看所有卡片（点评/构图/光影/色彩/LR/PS/报告导出等），保证体验一致；
  - 仿色报告的 PDF/HTML 导出仍通过按钮触发 `GET /api/report/pdf?taskId=&downloadToken=`，不在“我的仿色”列表中单独维护新 UI。

- **可选/未来扩展内容的开发策略**
  - 文档中标记为“可选/后续扩展”的模块（如审计中心、CV 深度模型替换、复杂 Analytics 维度等）在架构上已留出接口与数据结构；
  - **允许 Cursor/开发在当前迭代中实现这些可选功能**，前提是：
    - 不改变本方案中已定的核心接口与数据结构；
    - 不引入与“统一 Python 后端”矛盾的新技术栈；
    - 所有新接口与模块需在文档中补充一行描述（保持设计与实现同步）。
  - 若需限制某次开发任务的范围，可在任务描述中另行约定；本《开发方案》默认“允许在不破坏主线的前提下实现可选扩展”。

### 1. 背景与目标
- 业务背景：
- 问题与机会：
- 目标与不做清单（Out of scope）：

### 2. 需求范围
- 功能需求：
  - 用户场景 1：
  - 用户场景 2：
- 非功能需求：性能、可用性、可靠性、安全、合规、可维护性、可观测性等

### 3. 系统架构
- 总体架构图（补图）：前端 Web、后端服务、模型服务、存储、CDN、监控告警
- 关键技术栈：
  - 前端：Vite、React、TypeScript、Tailwind 等
  - 后端：Python（FastAPI/Flask）、任务队列（Celery/RQ）、缓存（Redis）
  - 模型服务：本地/容器化部署，或第三方 API（如 Gemini/OpenAI）
  - 数据库与存储：SQLite/PostgreSQL、对象存储（本地/云）
  - 日志与监控：结构化日志、Prometheus/Grafana、Sentry

### 4. 模块设计
- 前端（`src/`）：
  - 路由与页面：Landing、用户中心、订阅页、管理后台、结果页
  - 组件：风格模拟、分析进度、相似度提醒等
  - 状态管理与数据流：`lib/*Store.ts`（订阅、支付、内容等）
- 后端（`server_py/`）：
  - API 网关与鉴权：JWT/Session、速率限制、CORS
  - 业务服务：上传/任务创建/状态查询/结果回调
  - 模型服务适配：以接口封装 `services/gemini.py` 等
  - 持久化：关系库（任务、用户、订阅）、对象存储（图片/结果产物）
  - 任务异步化：长时任务入队，前端轮询或 Webhook/WS 推送

### 5. 数据模型与存储
- 核心实体：User、Subscription、Task、Asset、Result、Payment
- 关系示意：User 1—N Task；Task 1—N Asset；Task 1—1 Result；User 1—1 Subscription
- 索引与容量预估：按任务创建时间、用户维度建立索引；对象存储做生命周期管理

#### 5.2 永久化存储方案（根据永久化存储方案.md）

**数据库迁移工具**：
- 开发环境：使用 `Base.metadata.create_all(bind=engine)` 自动创建表（仅用于快速开发）
- 生产环境：**必须使用 Alembic 进行数据库迁移管理**
  - 安装：`pip install alembic`
  - 初始化：`alembic init alembic`
  - 生成迁移：`alembic revision --autogenerate -m "Initial migration"`
  - 应用迁移：`alembic upgrade head`
  - 迁移文件存储在 `server_py/alembic/versions/` 目录
  - 详细实施步骤见永久化存储方案.md 第 5 节

**Redis 缓存层**（当前未实现，需补充）：
- 应用场景：
  1. 用户会话缓存（TTL 5 分钟）
  2. 任务结果缓存（TTL 24 小时）
  3. 验证码缓存（TTL 10 分钟）
  4. 用量统计缓存（TTL 1 小时）
  5. 订阅计划缓存（TTL 1 小时）
  6. API 限流缓存（TTL 60 秒）
- 配置环境变量：`REDIS_HOST`、`REDIS_PORT`、`REDIS_PASSWORD`、`REDIS_DB`
- 开发环境：使用 Docker 运行 Redis（`docker run -d -p 6379:6379 redis:alpine`）
- 生产环境：使用云 Redis 服务（阿里云 Redis、AWS ElastiCache）
- 详细设计见永久化存储方案.md 第 7 节

**对象存储方案**（当前使用 Base64 存储，需迁移）：
- 当前状态：图片以 Base64 格式存储在数据库 `Text` 字段中（`analysis_tasks.source_image_data`、`uploads.source_image_data`）
- 问题：数据库体积快速增长、查询性能下降、无法 CDN 加速
- 推荐方案：使用对象存储服务（OSS/S3），数据库仅存储 URL
  - 开发环境：本地文件系统或 MinIO（S3 兼容）
  - 生产环境：阿里云 OSS、AWS S3、腾讯云 COS
- 存储结构：`uploads/{user_id}/{task_id}/source.jpg`、`results/{task_id}/preview.jpg`、`avatars/{user_id}/avatar.jpg`
- 迁移计划：见永久化存储方案.md 第 8 节和第 12 节（第二阶段）
- 注意：`uploads` 表已预留 `source_image_url` 和 `target_image_url` 字段，但当前未使用

**数据备份与恢复**：
- 开发环境：SQLite 文件每日备份，保留 7 天
- 生产环境：MySQL/PostgreSQL 每日全量备份，保留 30 天，每周归档到对象存储
- 灾难恢复：主从复制，RTO < 5 分钟，RPO < 1 分钟
- 详细策略见永久化存储方案.md 第 9 节

**数据归档与清理**：
- 分析任务数据：保留 1 年，超过 1 年归档到冷存储
- 上传记录：保留 6 个月
- 认证令牌：过期后保留 30 天用于审计
- 支付记录：永久保留
- 用户数据：永久保留（注销时标记 `status=disabled`）
- 详细策略见永久化存储方案.md 第 10 节

#### 5.1 SQLAlchemy 模型设计规范（强制要求）

**SQLAlchemy 保留字段名列表（禁止使用）**：
- `metadata`：用于存储表的元数据，不能作为列名
- `query`：用于查询接口，不能作为列名
- `registry`：用于注册表，不能作为列名
- `__table__`：内部表对象，不能作为列名
- `__mapper__`：内部映射器，不能作为列名

**替代方案**：
- 如需存储元数据，使用 `extra_data`、`meta_data`、`custom_metadata` 等名称
- 示例：
  ```python
  # ❌ 错误：使用保留字段名
  class Subscription(Base):
      metadata = Column(JSON, nullable=True)  # 会报错
  
  # ✅ 正确：使用替代名称
  class Subscription(Base):
      extra_data = Column(JSON, nullable=True)  # 正确
  ```

**检查方法**：
- 在定义模型后，尝试导入应用：`python3 -c "from app.models import *; from app.main import create_app; app = create_app()"`
- 如果出现 `InvalidRequestError: Attribute name 'xxx' is reserved`，说明使用了保留字段名

### 6. 接口定义（示例）
- POST `/api/tasks`：创建任务（含参考图/目标图）→ 返回 `taskId`
- GET `/api/tasks/{taskId}`：查询任务状态与结果
- POST `/api/analysis/similarity`：相似度计算
- GET `/api/subscription/me`：查询订阅状态
- 统一响应：`{ code, message, data }`；错误码与重试策略定义

### 7. 安全与合规
- 鉴权与授权：JWT 短期、Refresh Token、角色权限（用户/管理员）
- 输入校验与速率限制：防注入、防刷、防爆破
- 数据合规：个人数据最小化留存、脱敏/加密、日志留存策略

### 8. 部署与环境
- 环境：Dev / Staging / Prod，配置隔离（.env.*）
- 构建与发布：CI/CD（测试→构建→镜像→部署），前后端分离部署
- 运行时：容器编排（Docker Compose/K8s），滚动发布，健康检查与熔断

### 9. 监控与日志
- 指标：请求成功率、P95 延迟、任务成功率、模型调用失败率、资源使用
- 日志：结构化，关联 `requestId`/`taskId`
- 告警：阈值与抖动控制，按模块路由

### 10. 测试计划
- 单元测试：前端组件/Store，后端服务/适配层
- 集成测试：API 契约、任务全链路
- 端到端：关键用户路径（上传→下单/任务→结果）
- 回归与性能：基准与压力测试（QPS、并发、资源曲线）

### 11. 里程碑与排期（示例）
- M1：最小可用链路（创建任务→轮询结果）
- M2：订阅与支付对接、鉴权完善
- M3：监控日志完善、告警接入、性能优化
- M4：灰度与稳定性验收，准备发布

### 12. 风险与应对
- 第三方模型不稳定：超时与降级、本地备份模型/缓存结果
- 任务积压：限流、队列扩容、优先级与丢弃策略
- 成本不可控：缓存与复用、CDN、批处理

### 13. 附录

#### 13.1 依赖管理清单

**Python 后端依赖（`server_py/requirements.txt`）**：
- `fastapi>=0.104.0`：Web 框架
- `uvicorn[standard]>=0.24.0`：ASGI 服务器
- `sqlalchemy>=2.0.0`：ORM
- `pydantic>=2.0.0`：数据验证
- `pydantic-settings>=2.0.0`：配置管理（必需，用于 `BaseSettings`）
- `python-jose[cryptography]>=3.3.0`：JWT 认证（必需，用于 `from jose import jwt`）
- `passlib[bcrypt]>=1.7.4`：密码加密
- `python-multipart>=0.0.6`：文件上传支持
- `pillow>=10.0.0`：图像处理
- `opencv-python>=4.8.0`：计算机视觉（可行性评估）
- `numpy>=1.24.0`：数值计算
- `loguru>=0.7.0`：日志
- `google-genai>=0.2.0`：Gemini API 客户端
- `reportlab>=4.0.0`：PDF 生成（可选）
- `email-validator>=2.0.0`：邮箱验证（必需，用于 `EmailStr`）

**安装命令**：
```bash
# 标准安装
pip install -r requirements.txt

# 如果使用代理，需要添加 trusted-host
pip install --trusted-host pypi.org --trusted-host pypi.python.org --trusted-host files.pythonhosted.org -r requirements.txt
```

**依赖验证**：
```bash
# 检查关键依赖
python3 -c "from jose import jwt; from email_validator import validate_email; from pydantic_settings import BaseSettings; print('✅ 所有关键依赖已安装')"
```

#### 13.2 错误码表（补充）

**邮件验证码相关错误码**（根据注册登录与权限设计方案第 8.1 节）：
- `EMAIL_ALREADY_REGISTERED` (400) - 邮箱已注册（注册时）
- `EMAIL_NOT_REGISTERED` (400) - 邮箱未注册（登录时）
- `INVALID_VERIFICATION_CODE` (400) - 验证码错误或已过期
- `SEND_CODE_TOO_FREQUENT` (429) - 发送验证码过于频繁（60秒内）
- `EMAIL_SEND_FAILED` (500) - 邮件发送失败

**路由与启动相关错误码**：
- `ROUTE_NOT_FOUND`：路由未注册（通常表示应用启动失败）
- `MODULE_NOT_FOUND`：依赖缺失（如 `ModuleNotFoundError: No module named 'jose'`）
- `CONFIG_VALIDATION_ERROR`：配置验证失败（如 Pydantic 验证错误）
- `MODEL_DEFINITION_ERROR`：模型定义错误（如 SQLAlchemy 保留字段冲突）

**常见错误与解决方案**（见第 0.0 节）

#### 13.3 术语表、接口示例、数据字典、部署清单

### 14. 前端“去模拟化”与接口对照表

- **目标**：前端所有按钮/交互均调用真实后端接口，不再依赖本地模拟状态或随机数。
- **主站关键交互与后端映射**：
  - 上传图片（源图/目标图）：
    - 组件：`PhotoUploadZone`、`App` 上传区。
    - 接口：`POST /api/photos/upload`（multipart/form-data）。
    - 返回字段（示例）：`{ uploadId, source_image_url, target_image_url, thumbnails: { source, target }, exifDigest }`。
  - 开始 AI 分析（Part1）：
    - 触发点：主按钮“开始 AI 分析”/“开始分析”。
    - 接口：`POST /api/analyze/part1`，请求体 `{ uploadId, optional_style? }`。
    - 返回：`{ taskId, stage: 'part1', status: 'part1_completed' | 'processing', structuredAnalysis, naturalLanguage, protocolVersion, meta }`。
  - 查看详细方案（触发 Part2+Part3）：
    - 触发点：结果页"查看详细方案"按钮或 Stage2 卡片点击。
    - 接口：`POST /api/analyze/part2`，请求体 `{ taskId }`。
    - **taskId 传递规范**：
      - `taskId` 必须通过 props 传递给 `ThemeCardsGrid` 组件（从 Part1 返回的 `taskId`）
      - 组件内部**禁止声明同名 state**，应使用计算值：`const currentTaskId = propTaskId || results?.meta?.taskId || null`
      - 如果 props 中没有 `taskId`，可以从 `results.meta.taskId` 获取
    - 行为：接口快速返回 `{ status: 'processing' }`，前端开始轮询。
    - **当前实现状态**：⚠️ 当前为同步等待（不符合规范），需要后续优化为轮询机制（见第 16 节）。
  - 任务结果轮询：
    - 触发点：Part2 触发后，或从历史记录/用户中心进入结果页。
    - 接口：`GET /api/analyze/{taskId}`。
    - 返回：`{ status, stage, structured_result, natural_language_part1, natural_language_part2, meta }`。
  - 风格模拟（仿色示意图）：
    - 触发点：`StyleSimulation` 按钮/卡片。
    - 接口：推荐与 Part2 Job 串联，由 Part2 后端在 `runPart2And3Job` 内完成风格模拟，将 `preview_image_url` 合并入 `structured_result`；如需单独接口则为 `POST /api/simulate/style` + 轮询。
  - 导出（XMP/JSX/PDF/JSON）：
    - 触发点：结果页导出按钮。
    - 接口：
      - `GET /api/export/xmp?taskId=&token=`、
      - `GET /api/export/jsx?taskId=&token=`、
      - `GET /api/report/pdf?taskId=&token=`、
      - `GET /api/export/json?taskId=&token=`。
    - 行为：前端使用 `window.open()` 直接触发下载；鉴权通过 Query Token 或签名 URL。
  - 历史记录：
    - 触发点：用户中心“我的历史”页面。
    - 接口：`GET /api/analyze/history?limit=20&page=1`。
  - 相似度提示：
    - 推荐从后端 `uploads.similarity_score` 或分析结果中的 `similarity_check` 返回，不再前端随机生成。

- **前后端接口一致性检查清单（强制要求）**：
  - 所有前端 API 调用必须通过 `src/lib/api.ts` 统一封装，**禁止**直接使用 `fetch` 或 `axios`
  - 所有后端路由必须统一返回 `{code, message, data}` 格式
  - 所有接口路径必须与开发方案第 14 节对照表一致
  - 新增接口时，必须同时更新前端 `api.ts` 和后端路由，并在开发方案中记录
  - 所有接口的错误处理必须统一使用 `ApiError`（前端）和 `HTTPException`（后端）
  - 前端 API 客户端必须完善错误处理：先检查 HTTP 状态码，再解析 JSON，避免非 JSON 响应时崩溃

- **用户与订阅/支付相关交互**：
  - 注册：
    - `RegisterDialog.tsx` 中的注册逻辑：
      - `POST /api/auth/send-verification-code`（`type="register"`）：发送注册验证码
      - `POST /api/auth/register`：提交注册（邮箱+验证码+密码）
    - 成功后保存 JWT（`accessToken`）与必要的用户资料到 `localStorage`，自动登录
  - 登录：
    - `LoginDialog.tsx` 中的登录逻辑：
      - **密码登录**：`POST /api/auth/login`（邮箱+密码）
      - **验证码登录**：
        - `POST /api/auth/send-verification-code`（`type="login"`）：发送登录验证码
        - `POST /api/auth/login-with-code`：提交登录（邮箱+验证码）
      - `GET /api/auth/me`：获取当前用户信息
    - 成功后保存 JWT（`accessToken`）与必要的用户资料到 `localStorage`
  - 管理员登录：
    - `AdminLoginDialog.tsx` 中的两步验证登录：
      - `POST /api/admin/auth/login`：第一步（邮箱+密码），返回 `mfaToken`
      - `POST /api/admin/auth/verify-mfa`：第二步（`mfaToken`+验证码），返回 `adminAuthToken`
    - 成功后保存 `adminAuthToken` 到 `localStorage`（与普通用户 Token 分开存储）
  - 订阅与套餐：
    - `SubscriptionPage`、`UserCenter` 订阅模块：
      - `GET /api/subscription/plans`：获取套餐列表。
      - `GET /api/subscription/me`：获取当前订阅状态。
  - 支付与订单：
    - 结算页（Checkout）：
      - `POST /api/payments/create`：创建订单，返回 `paymentId`、收银台参数。
      - 第三方支付回调：`POST /api/payments/webhook/:channel`（后端与支付渠道对接）。
      - 前端轮询：`GET /api/payments/{paymentId}` 查看订单状态（`pending/succeeded/failed`）。

- **管理后台 Admin 交互与接口映射**：
  - 管理员登录（两步验证）：
    - 第一步：`POST /api/admin/auth/login`（邮箱+密码），返回 `mfaToken`
    - 第二步：`POST /api/admin/auth/verify-mfa`（`mfaToken`+验证码），返回 `adminAuthToken`（`admin_session` JWT）
  - 后台页面：
    - Dashboard：`GET /api/admin/dashboard/metrics`。
    - 用户管理：`GET /api/admin/users`。
    - 订阅管理：`GET /api/admin/plans`、`GET /api/admin/subscriptions`。
    - 支付管理：`GET /api/admin/payments`。
    - 任务管理：`GET /api/admin/tasks`、`GET /api/admin/tasks/{taskId}`。
    - 内容管理：`GET/POST /api/admin/content`。
    - 分析模块：`GET /api/admin/analytics/*`。

### 15. 前端 API 客户端与统一通信规范

- **API 客户端设计**：
  - 在前端新增 `src/lib/api.ts`：
    - 基于 `fetch` 或 `axios` 封装：
      - 基础配置：`baseURL`、超时、`Content-Type`。
      - 请求拦截器：自动附加 `Authorization: Bearer <accessToken>`。
      - 响应拦截器：统一处理 `{ code, message, data }`，对 `code != 0` 抛出带业务码的错误。
      - 错误分类：网络错误/超时/业务错误/鉴权错误，对应 UI 提示策略。
  - 常用方法：
    - `uploadPhotos(formData)` → `POST /api/photos/upload`。
    - `analyzePart1(uploadId, options?)` → `POST /api/analyze/part1`。
    - `analyzePart2(taskId)` → `POST /api/analyze/part2`。
    - `getAnalysis(taskId)` → `GET /api/analyze/{taskId}`。
    - `getHistory(params)` → `GET /api/analyze/history`。
    - `simulateStyle(taskId)` → `POST /api/simulate/style`（如单独实现）。
    - `exportXmp/Jsx/Json/Pdf(taskId)` → 对应导出接口。

- **通信协议与响应规范**：
  - 统一响应结构：
    - 成功：`{ code: 0, message: 'ok', data: {...} }`。
    - 业务错误：`{ code: <业务码>, message: <可展示文案>, data?: {...} }`。
  - HTTP 状态码建议：
    - 2xx：成功（含部分业务警告，可通过 `data.meta.warnings` 暴露）。
    - 4xx：参数错误/鉴权失败/资源不存在：
      - 400：参数错误（`code=INVALID_PARAMS`）。
      - 401：未登录或 Token 失效（`code=UNAUTHORIZED`）。
      - 403：无权限（`code=FORBIDDEN`）。
      - 404：资源不存在（`code=NOT_FOUND`）。
    - 5xx：服务端错误或第三方模型错误：
      - 500：内部错误（`code=INTERNAL_ERROR`）。
      - 502/504：上游模型/网络超时（`code=UPSTREAM_TIMEOUT`）。
  - 版本控制：
    - 接口版本：通过 URL 前缀预留 `/api/v1/...`。
    - 协议版本：分析结果中必须包含 `protocolVersion: '2025-02'`，前端根据版本走不同适配路径。

### 16. 任务状态机与轮询策略

- **后端任务状态机**（`analysis_tasks.status`）：
  - `pending`：任务刚创建，未开始分析。
  - `part1_completed`：第一阶段分析完成，结构化结果已可用。
  - `processing`：第二阶段/风格模拟等长任务进行中。
  - `completed`：全部阶段（Part1+Part2+Part3）完成。
  - `failed`：任务失败，`status_reason` 字段给出简要失败原因。
- **前端状态与轮询**：
  - Stage1：
    - 点击“开始分析”→ 调用 `analyzePart1()` → 进入全屏 Loading。
    - 控制台/组件状态：`analysisStage = 'loading_part1'`，完成后设为 `'stage1'`。
  - Stage2：
    - 点击“查看详细方案”等按钮→ 调用 `analyzePart2(taskId)`。
    - 服务返回 `{ status: 'processing' }` 后前端立刻开始轮询 `getAnalysis(taskId)`：
      - 轮询间隔：3 秒。
      - 最大轮询时长：建议 2 分钟（前端维护超时计时器）。
      - 接收到 `status === 'completed'` 后停止轮询，展示 Stage2 内容。
      - 若超过最大时长仍未完成：显示“分析时间过长，请稍后在历史中查看”提示，并停止轮询。
  - 风格模拟：
    - 若与 Part2 串行：不单独轮询，由 `status === 'completed'` 时一并返回 `preview_image_url`。
    - 若单独接口：`simulateStyle(taskId)` → `status: 'processing'` → 前端轮询直到返回结果或超时。
- **服务器端建议**：
  - 对于仍在 `processing` 的任务，可返回 `Retry-After` 或在 `data.retryAfterSeconds` 内指示前端轮询间隔。

### 17. 鉴权、幂等与错误码规范

- **鉴权策略**：
  - 主站用户：
    - 登录后返回 `accessToken` + 可选 `refreshToken`，前端保存于 `httpOnly cookie` 或 `localStorage`（视安全等级而定）。
    - 所有用户接口（上传、分析、历史、订阅、支付）需携带 `Authorization: Bearer <accessToken>`。
  - 管理后台：
    - `admin_session` 与普通用户 Token 区分（Payload 包含 `type: 'admin_session'`、`role: 'admin'`）。
    - 所有 `/api/admin/**` 接口强制要求 `admin_session` 且 `role=admin`。
  - 文件下载：
    - 为防止 Token 泄露，可采用签名 URL 或短期 Query Token，例如：
      - `GET /api/export/xmp?taskId=<id>&downloadToken=<one-time-token>`。
      - `downloadToken` 由前端通过受鉴权保护的接口 `POST /api/export/token` 获取。

- **幂等性与防重放**：
  - 任务创建类接口（如 `POST /api/analyze/part1`）建议支持 `Idempotency-Key` Header：
    - 后端基于 `(userId, Idempotency-Key)` 识别重复请求，返回同一任务结果。
  - 支付创建接口 `POST /api/payments/create` 必须支持幂等，防止用户多次点击“立即支付”生成多订单。

- **错误码建议**（示例，具体可在附录中落表）：
  - `ANALYSIS_TASK_NOT_FOUND`、`ANALYSIS_STAGE_INVALID`。
  - `UPLOAD_FILE_TOO_LARGE`、`UPLOAD_MIME_NOT_ALLOWED`。
  - `GEMINI_RESPONSE_INVALID_JSON`、`GEMINI_SCHEMA_VALIDATION_FAILED`。
  - `PAYMENT_CREATE_FAILED`、`PAYMENT_STATUS_UNKNOWN`。
  - `ADMIN_PERMISSION_DENIED`。

### 18. 上传/图片处理与前端直方图规范

- **上传与存储**：
  - 上传接口统一接受 multipart/form-data：
    - 字段：`sourceImage`（必填）、`targetImage`（可选）。
    - 校验：大小 ≤ 25MB，限制 MIME 为 `image/jpeg`, `image/png` 等。
  - 后端存储策略：
    - 数据库仅存储引用（如对象存储 URL）与必要的 Base64（短期）。
    - 缩略图与原图分离存储，避免前端载入超大文件。
  - 返回给前端的 URL 需要：
    - 支持 HTTPS。
    - 控制缓存策略与有效期（可通过签名 URL 实现）。

- **前端直方图（像素级计算，不由模型直接给出 bins）**：
  - 所有直方图（参考图、用户图、仿色后示意图）必须由前端通过 `Canvas` 计算：
    - 加载图片 → 绘制到隐藏 `canvas` → `getImageData` → 遍历像素计算 RGB 分布 → 用 `Chart.js` 或自定义 SVG 绘制。
  - 后端/Prompt 不负责输出 256 维 bins 等高精度直方图数据，以避免 LLM “猜数值”带来的不稳定；如模型误输出相关字段，`analysisFormatter` 直接忽略。
- **直方图摘要字段与图表生成服务（摘要由模型/算法，图由前后端绘制）**：
  - 为了在 UI 与报告中解释直方图形态，可以在协议中增加**摘要字段**，由模型或算法负责提供“形状说明”，而非原始像素 bins：
    - 示例结构：
      ```json
      "histogram_overview": {
        "luminance_distribution": { "shadows": 0.25, "midtones": 0.55, "highlights": 0.20 },
        "channel_balance": { "red": "slightly_dominant", "green": "balanced", "blue": "slightly_lower" },
        "shape": "midtones_peak_with_soft_shadows"
      }
      ```
    - 该字段可来自：
      - Gemini 的自然语言 + 结构化摘要（由 `analysisFormatter` 解析为上述 JSON）；
      - 或后端基于真实 bins 的规则计算（推荐长期采用）。
  - 后端建议新增 `chartService`（或等价服务）用于**导出报告中的静态图**生成：
    - 输入：真实直方图 bins、Part2 JSON 中的 tone_curve/rgb_curves、color_grading 等；
    - 输出：PNG/SVG 图像（直方图、曲线、色轮），由 `exportService` 嵌入 HTML/PDF 报告；
    - 前端交互页面仍由 React + Canvas/Chart.js 绘制，不依赖后端生成图片，以保证性能与交互性。

### 19. Admin 调试页与 Gemini 输出对比

- **目标**：为 Prompt 调优和协议演进提供可视化对比工具。
- **后端接口**：
  - `GET /api/admin/tasks/:taskId`：
    - 返回字段包含：
      - `gemini_result`: 原始模型返回（尽量保留结构，必要时裁剪掉 Base64 图片等敏感字段）。
      - `structured_result`: 经过 `analysisFormatter` + schema 校验后的规范结果。
      - `meta`: 包含 `warnings`、`protocolVersion`、`mappingNotes` 等。
  - 可选：`GET /api/admin/tasks/:taskId/logs` 返回关键日志片段（不含敏感数据）。
- **前端 Admin 页面**：
  - 左侧 JSON 视图：显示 `gemini_result`。
  - 右侧 JSON 视图：显示 `structured_result`。
  - 差异高亮：标出缺失字段、默认值补齐位置（可读取 `meta.warnings`）。
  - 操作按钮：
    - “复制 Prompt 请求体”——便于在外部工具复现。
    - “导出 JSON”——用于离线分析。

### 20. Prompt 版本化与缓存策略

- **Prompt 版本管理**：
  - 所有 Prompt 模板落地为代码文件：
    - `server/services/promptTemplate.ts`（或等价路径）。
    - 内部区分 `getPart1Prompt(...)`、`getPart2Prompt(...)`、`getPart3FlashPrompt(...)`。
  - Prompt 变更需：
    - 同步更新 `protocolVersion` 或以 `promptVersion` 字段记录。
    - 在 `顶层设计文档.md` 对应章节更新，保留变更说明。
- **Gemini 缓存与长上下文**：
  - 使用 Gemini 官方的 `cachedContent` 机制：
    - 将固定指令（角色、六步流程、JSON skeleton）写入缓存，设置 `TTL=43200` 秒。
    - 每次调用仅附加动态部分（图片、EXIF、Part1 摘要等）与 `cachedContent` 引用。
  - 超时与重试：
    - 设置合理超时（如 60 秒），超时后写入 `meta.warnings` 并返回友好错误。
    - 对短暂网络错误支持有限重试（如 2 次），避免用户体验受偶发错误影响。

### 21. 安全与合规补充细则

- **数据最小化与脱敏**：
  - 日志中禁止记录完整 Base64 图片数据，只记录摘要（如 hash）与尺寸。
  - 用户个人信息（邮箱、手机号）在日志中需做脱敏（如中间位替换为 `*`）。
- **访问控制与审计**：
  - 管理后台所有变更操作（套餐、价格、内容、权限）写入 `audit_logs` 表。
  - 关键安全参数（代理配置、API Key）严禁从前端可见接口透出。
- **配置管理**：
  - 所有敏感配置由环境变量提供：
    - `GEMINI_API_KEY`、`GEMINI_MODEL`、`GEMINI_FLASH_MODEL`、`GEMINI_TIMEOUT_MS`。
    - `AUTH_ADMIN_MAX_FAILED_ATTEMPTS` 等安全相关配置。
  - Dev/Staging/Prod 使用分离的 `.env` 文件，避免误用生产配置。
  - **Pydantic Settings 配置规范**：
    - `Settings` 类的 `Config` 中必须设置 `extra = "ignore"`，允许环境变量中有额外字段但不报错
    - 所有环境变量字段必须在 `Settings` 类中定义，或使用 `extra = "ignore"` 忽略未定义字段
    - 示例：
      ```python
      class Settings(BaseSettings):
          GEMINI_API_KEY: str = ""
          GEMINI_TIMEOUT_MS: int = 120000  # 必须定义所有环境变量字段
          
          class Config:
              env_file = ".env"
              extra = "ignore"  # 允许额外字段，但不报错
      ```

### 22. Gemini 调用实现与 ClashX 代理配置（Python & Node）

- **Python 侧（`server_py/app/services/gemini.py`）**：
  - 客户端封装：
    - 使用 `google.genai.Client(api_key=GEMINI_API_KEY)` 初始化，在 `GeminiClient` 中注入：
      - `api_key`：从环境变量 `GEMINI_API_KEY` 读取；
      - `model`：默认 `gemini-2.5-pro`，允许通过 `GEMINI_MODEL` 覆盖。
    - 方法设计：
      - `generate_text(contents: List[Dict], response_mime: Optional[str]) -> str`：用于 Part1/Part2 文本+JSON 输出；
      - 预留 `generate_image(...)`：用于 flash-image 图像生成（Part3）。
  - 代理配置（对接 ClashX）：
    - 在启动后端之前，通过环境变量设置 HTTP 代理：
      - `HTTPS_PROXY=http://127.0.0.1:7890`
      - `HTTP_PROXY=http://127.0.0.1:7890`
    - Gemini SDK 默认遵守上述代理环境变量，无需在代码中硬编码代理。
  - 日志与错误处理：
    - 每次调用记录：`model`、阶段（`feasibility/part1/part2/style`）、耗时、是否命中 `cachedContent`。
    - 捕获 SDK 异常时，统一包装为业务错误 `GEMINI_CALL_FAILED`，并在 `meta.warnings` 写入简要原因；避免将原始异常栈直接暴露给前端。

- **Node 侧（若继续使用 `@google/genai`）**：
  - 初始化：
    - 使用 `const client = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY })`。
    - 通过 `process.env.HTTPS_PROXY = 'http://127.0.0.1:7890'` 或启动命令里的环境变量，让所有 `fetch` 走 ClashX。
  - 服务封装：
    - `geminiService.ts` 提供：
      - `callPart1(promptArgs): Promise<GeminiRawResponse>`；
      - `callPart2(promptArgs): Promise<GeminiRawResponse>`；
      - `callFlashImage(promptArgs): Promise<FlashImageResponse>`；
      - 内部统一处理：`cachedContent` 创建/复用、重试、超时。
  - 与 Python 的关系：
    - 当前仓库已存在 Python 版 `GeminiClient`；若后端最终统一在 Node，请保持 API 设计与 Python 版本一致（相同入参/出参结构），以便迁移。

### 23. 三阶段 Prompt 模板落地规范（终版约束）

- **Prompt 代码文件与命名**
  - 在后端维护 Prompt 模板文件：
    - Node 方案：`server/src/services/promptTemplate.ts`。
    - Python 方案：`server_py/app/services/prompt_template.py`（命名示例）。
  - 必须导出/实现以下三个函数（以及可选的 Feasibility Prompt），并在文档与代码中保持一致：
    - `getPart1Prompt(referenceImage, userImage, exif, options)`;
    - `getPart2Prompt(referenceImage, userImage, part1Context, options)`;
    - `getPart3FlashPrompt(userImage, styleSummary, options)`;
    - `getFeasibilityPrompt(referenceImage, userImage, exif)`（见第 26 节）。

- **23.1 Prompt 总体角色与输出要求**
  - 角色设定：Gemini 必须同时扮演 **资深摄影师** 与 **影像后期专家**，精通 Lightroom、Camera Raw 与 Photoshop 的参数与操作流程。
  - 总体任务：对输入图片（或两张图片做对比）进行全面、专业、具体、可执行的摄影风格分析，并输出两部分内容：
    1. 一段供用户阅读的自然语言分析（摄影师口吻、连贯叙述、说明“为什么 / 如何 / 体现在哪里”）；
    2. 一份严格结构化的 JSON（供前端与本地 color-mapping / 导出模块直接使用）。
  - 输入约定：
    - `reference_image`: 参考图 URL 或 base64（必填）；
    - `user_image`: 用户图 URL 或 base64（可选；若存在必须对比）；
    - `optional_style`: 可选风格关键词（如 "日出暖光", "胶片感"）；
    - `EXIF`: 若提供，必须优先使用其中的 ImageWidth/ImageHeight、相机型号、镜头信息等。
  - 总体硬约束：
    - 输出 **自然语言报告 + JSON** 两部分，两者内容必须一致（报告中的结论在 JSON 中有对应字段）；
    - 所有调整参数必须为具体数值，禁止“稍微提高/略微降低”这类模糊用语；
    - 所有 Lightroom/Photoshop 滑块参数必须为字符串，并带显式正负号（如 `"+0.25"`、`"-45"`、`"+0"`）；
    - 不允许输出 `"未提供" / "N/A" / "示例值"` 等占位符——无调整就用 `"+0"`，无数据则省略字段并在 `analysis_meta.notes` 说明原因；
    - 当存在 `user_image` 时，必须输出对比分析表（参考图 vs 用户图 vs 差异 vs 调整建议），并在 JSON 中结构化；
    - 所有输出必须遵守“提出观点 → 分析依据 → 得出结论”的叙述结构，保证段落衔接自然。

- **23.2 Part1 Prompt（基础洞察，结合复刻可行性摘要）**
  - 角色：资深摄影师 + 构图指导教师。
  - 目标：输出自然语言 + Part1 JSON（点评、构图、光影趋势、可行性说明、工作流草案）。
  - 自然语言部分要求（Step 1）：
    - 按以下维度，使用摄影师口吻连贯叙述，每一项都要说明“为什么 / 如何 / 体现在哪里”：
      1. 视觉引导与主体（第一视觉焦点、视线引导路径、颜色/亮度/位置对视线的影响）；
      2. 焦点与曝光（对焦与景深、曝光是否有意为之、对整体情绪的影响）；
      3. 色彩与景深（主体与背景色彩关系、空间感与景深表现）；
      4. 构图与表达（主体位置、构图法则、视觉平衡、情绪与主题表达）；
      5. 技术细节（剪裁/拍摄角度/后期方向的具体建议）；
      6. 设备与技术（若有 EXIF，优先使用；若无，则基于画面推断相机/镜头类型，并说明依据）；
      7. 色彩与情感（颜色组合与情绪）；
      8. 优点评价（“好在哪里”，并给出技术或艺术层面的证据）；
      9. 对比分析（若有 `user_image`，必须给出结构化对比：对比项 / 参考图 / 用户图 / 差异 / 调整建议）。
    - 结尾必须有一句「摄影师风格总结」短句，用于前端 Summary 卡片。
  - Step 2：整体影像分析（量化）：
    - 场景类型：如 `"landscape" / "portrait" / "architecture" / "documentary"`；
    - 画面结构：主体位置（如 `"right_third"` 或精确百分比）、留白说明、构图类型（对称/三分法/引导线等）；
    - 分辨率规则：
      - 若 EXIF 有 ImageWidth/ImageHeight，必须用 EXIF 值；
      - 否则用真实像素尺寸；
      - 禁止猜测或示例值；
    - 输出平均亮度（如 `"152/255"`）、景深描述（浅/长）、拍摄时间段（如 `"golden_hour"`）、光线方向（如 `"from_left_45deg"`）；
    - 若有 EXIF，相机/镜头/光圈/快门/ISO 信息必须列出并用于后续分析。
  - Step 4：可复刻可行性说明（与第 26 节对齐）：
    - 在 Part1 中，不再重新计算数值，而是：
      - 引用 `analysis_tasks.feasibility_result` 的摘要（`feasibilityScore`、`difficulty`、`confidence`、Top-3 拖累项）；
      - 以自然语言解释“为什么可行或困难”、“哪些维度拖累可行性”、“需要在后期中注意什么”；  
    - JSON 中在 `analysis_meta.conversion_feasibility` 填入：
      - `can_transform`、`difficulty`、`confidence`、`limiting_factors[]`、`recommendation`，数据来源于 Feasibility 结果。
  - Part1 JSON 要求（新 Prompt 模版）：
    - **模块一：照片点评 (module_1_critique)**
      - `comprehensive_review`：综合描述（内容 -> 影调 -> 色调 -> 器材/参数 -> 时间）
      - `visual_subject_analysis`：视觉引导与主体分析
      - `focus_exposure_analysis`：焦点与曝光分析
      - `color_depth_analysis`：
        - `text`：色彩科学分析文本
        - `simulated_histogram_data`：**必须包含 reference 和 user 两个字段**
          - `reference`：参考图直方图数据（`description` + `data_points` 数组，255个整数）
          - `user`：用户图直方图数据（`description` + `data_points` 数组，255个整数）
      - `emotion`：情感与意境描述
      - `pros_evaluation`：高级感来源
      - `parameter_comparison_table`：参数对比表（dimension, ref_feature, user_feature）
      - `style_summary`：调色思路总结
      - `feasibility_assessment`：复刻可行性评估（score, level, limitations, recommendation, confidence）
    - **模块二：构图分析 (module_2_composition)** - 仅分析参考图
      - `main_structure`：视觉框架与几何关系
      - `subject_weight`：主体位置与视觉权重（description + layers）
      - `visual_guidance`：线条与方向引导（analysis + path）
      - `ratios_negative_space`：比例与留白（entity_ratio, space_ratio, distribution）
      - `style_class`：构图风格归类
      - **前端显示方案**：采用方案A（5个独立卡片），每个字段对应一个卡片
    - **模块三：光影参数 (module_3_lighting_params)** - 仅分析参考图
      - `exposure_control`：曝光控制参数
        - **格式要求**：必须使用"范围+描述"格式，例如："+0.3～+0.6，轻微提升使高光有"柔光""
        - 支持格式：范围（"+0.3～+0.6"）、单个值（"+0.3"）、描述（"微调"），但必须同时包含范围和描述
        - 字段：exposure, contrast, highlights, shadows, whites, blacks
      - `tone_curves`：色调曲线
        - `explanation`：曲线调整逻辑说明
        - `points_rgb`：RGB 曲线坐标点数组
        - `points_red`：红色通道曲线坐标点数组
        - `points_green`：绿色通道曲线坐标点数组
        - `points_blue`：蓝色通道曲线坐标点数组
      - `texture_clarity`：纹理与清晰度
        - **格式要求**：必须使用"范围+描述"格式
        - 字段：texture, clarity, dehaze
    - 根级元信息：`protocolVersion: "2025-02"`、`stage: "part1"`、`meta.rawNaturalLanguage`（完整原文）。

- **23.3 Part2 Prompt（执行参数与工作流，对齐科学仿色约束）**
  - 角色：影像后期专家。
  - 输入：`reference_image`、`user_image`、`part1_context`（含 Part1 摘要与 `workflow_draft`）、`feasibility_result` 摘要。
  - 目标：输出可直接驱动前端与导出模块的 Lightroom / Photoshop 全量参数 + 工作流对齐说明，并尊重可行性分析结论。
  - 自然语言报告：
    - `workflow_execution_summary`：
      - 说明如何沿用 / 调整 / 新增 Part1 草案中的步骤；
      - 如 Feasibility 判定“极高/不建议”，需要在此明确说明“本次只给出方向性建议，不保证高度还原”，并建议补拍/更换目标等。
    - `lightroom_strategy` / `photoshop_strategy`：
      - 对 LR/PS 调色思路做解释，必须与 JSON 中给出的具体参数一致，不能出现“想法一套、参数一套”的矛盾。
  - JSON 部分（严格数值输出）：
    - 基础滑块（exposure/contrast/highlights/shadows/whites/blacks/clarity/texture/dehaze/vibrance/saturation）：
      - 全部为字符串，带正负号，`"+0"` 表示不变；
    - tone_curve：
      - Luma 通道必须是 5 个控制点数组 `[[0,y1],[64,y2],[128,y3],[192,y4],[255,y5]]`；
    - RGB 曲线：
      - `rgb_curves.red/green/blue` 各通道 ≥ 4 个控制点，数值为整数坐标；
    - HSL：
      - 8 个色相（red/orange/yellow/green/aqua/blue/purple/magenta），各含 `hue/saturation/luminance` 数字值；
    - color_grading：
      - `shadows/midtones/highlights` 含 `hue`、`saturation` 数值，`balance` 为字符串（如 `"+5"`）；
    - `lightroom_panels`：
      - 面板数组，每个 panel 有 `title/description/params[]`，params 中 `value` 为字符串 + ±，`purpose` 为简短中文解释；
    - 局部蒙版：
      - `lightroom_local_adjustments` 为蒙版数组或空数组；
      - 每个蒙版包含 `type`、`position`（中心或 bbox）、`feather`、`opacity`、`params`；
      - 若为空数组，必须在 `analysis_meta.notes` 说明“不需要局部蒙版”的原因；
    - Photoshop：
      - `photoshop.steps[]`：包含从 Camera Raw → 曲线 → 色彩平衡/可选颜色 → HSL → LUT → 局部调整 → Dodge & Burn → 锐化 → 最终调整的完整步骤；
      - 每步有 `title/description/params[]`，曲线步骤必须给出各通道控制点；
      - `blendMode`、`opacity` 如有使用必须显式写出；
    - `color_mapping`：
      - 提供色彩方案与 LUT 摘要，供后续导出/调试使用；
    - 所有滑块值必须遵守：
      - 字符串 + 显式正负号；
      - tone_curve 5 点、RGB 曲线每通道 ≥ 4 点；
      - 缺失数值由 schema 默认值填充，并在 `meta.warnings` 记录；
    - 若 `feasibility_result` 判定不可行（Score < 0.3 或存在 deal-breakers），则：
      - 允许只输出“方向性参数”（偏中性曲线），但必须在 `workflow_alignment_notes` 中清晰声明“不建议按此参数强行复刻”，并引导用户重拍/更换目标。

- **23.3.1 直方图摘要字段（供曲线/色轮/报告解释使用）**
  - 虽然像素级直方图由前端/后端图像算法计算，但 Prompt 仍可要求模型输出“直方图形态摘要”，以便：
    - 在自然语言报告中解释“暗部/中间调/高光的占比与倾向”；
    - 在 JSON 中留下机器可读的结构供报告使用。
  - 建议的 JSON 结构（挂在 `sections.lighting.structured.histogram_overview` 或 `analysis_meta.image_histogram` 下）：
    ```json
    "histogram_overview": {
      "luminance_distribution": {
        "shadows": 0.25,
        "midtones": 0.55,
        "highlights": 0.20
      },
      "channel_balance": {
        "red": "slightly_dominant",
        "green": "balanced",
        "blue": "slightly_lower"
      },
      "shape": "midtones_peak_with_soft_shadows"
    }
    ```
  - 约束：
    - 模型不输出 256 维 bins，只输出归一化比例（0.0–1.0）和定性描述（`shape`）；
    - `analysisFormatter` 对该结构做 Schema 校验，失败则丢弃并记录 warning；
    - 真正的 bins 数据由前端 Canvas 或后端图像库计算，**Prompt 不承担像素级统计职责**。

- **23.4 Part3 Prompt（Gemini 2.5 flash-image 科学仿色约束）**
  - 角色：严格遵循已有风格分析结果的 AI 照片编辑器。
  - 输入：
    - `user_image`：目标图；
    - `style_summary`：从 Part2 结果中压缩出来的关键参数 JSON（曝光、对比、temperature/tint、阴影/高光 hue、整体对比度、色彩分级倾向等）。
  - 约束：
    - 只允许执行类似 Lightroom/Photoshop 的调色和局部调整；
    - 禁止增加新元素、改变构图、重塑主体；
    - 禁止“发挥创意”改变风格方向：必须在 Prompt 中明确：“严格按 `style_summary` 参数执行，不要自行发挥或改变风格方向”；
    - 输出只需要图片（以及可选 `stylePrompt` 供调试），不返回新的 JSON。
  - 实现要点：
    - `styleSimulationService` 从 `analysis_tasks.structured_result.lightroom/photoshop/color_mapping` 中抽取 `style_summary`；
    - 调用 `gemini-2.5-flash-image`，使用 `cachedContent` 引用固定模板 + 动态 `style_summary`；
    - 若 `feasibility_result` 表示不可行，应在调用前由后端阻断或降级处理（例如返回“无法提供风格模拟”的友好错误）。

- **23.5 Feasibility Prompt（复刻可行性评估，与第 26 节联动）**
  - `getFeasibilityPrompt(referenceImage, userImage, exif)` 的具体输出约束见第 26 节：
    - Ginemi 必须按 L/C/S/P/D/T/Q/R 八个维度输出 score 与 reason；
    - 检测并列出所有 `dealBreakers[]`，并给出 `dominantFactors[]`、`recommendedActions[]`、`feasibilityScore/difficulty/confidence/explanation`；
    - 输出的 JSON 必须可被 `FeasibilitySchema` 解析，并写入 `analysis_tasks.feasibility_result`；
    - Part1/Part2 在生成自然语言和 JSON 时只能“引用/解释”可行性结果，不得与该结果矛盾。

### 24. 六大块前端字段协议表（Review / Composition / Lighting / Color / Lightroom / Photoshop）

> 目的：把前端六大分析块真实使用到的字段明确成协议表，约束 Prompt 输出与 `analysisFormatter` 映射，避免任何字段被遗漏或丢弃。

- **通用约定**
  - 所有字段最终都挂在 `analysis_tasks.structured_result.sections` 下，由 `analysisAdapter` 映射成前端的 `results` 对象：
    - `sections.photoReview` → `results.review`
    - `sections.composition` → `results.composition`
    - `sections.lighting` → `results.lighting`
    - `sections.color` → `results.color`
    - `sections.lightroom` → `results.lightroom` / `results.lightroom_extra`
    - `sections.photoshop` → `results.photoshop`
  - 自然语言原文：
    - 完整原文写入 `meta.rawNaturalLanguage`；
    - 分块自然语言写入 `sections.*.naturalLanguage.*`（不允许丢弃）；
    - `analysisFormatter` 负责把纯自然语言解析/整理为后文列出的结构化字段。

- **Review（照片点评） → `results.review`**
  - 前端字段：
    - `overviewSummary?: string`
    - `dimensions?: {`
      - `visualGuidance?: { title; referenceDescription; userDescription }`
      - `focusExposure?: { ... }`
      - `colorDepth?: { ... }`
      - `composition?: { ... }`
      - `technicalDetails?: { ... }`
      - `equipment?: { ... }`
      - `colorEmotion?: { ... }`
      - `advantages?: { ... }`
      - `}`
    - `comparisonTable?: { dimension; reference; user }[]`
    - `photographerStyleSummary?: string`
    - `feasibility?: { conversion_feasibility; difficulty; confidence; limiting_factors; recommendation; notes? }`
    - `feasibilityDescription?: string`
  - 协议要求：
    - Prompt Part1 / Feasibility Prompt 中必须输出上述信息对应的自然语言段落；
    - `analysisFormatter` 从 `sections.photoReview.naturalLanguage.*` 和 `feasibility_result` 中提取并填充这些字段，缺失时写默认值并记录 `meta.warnings`。

- **Composition（构图分析） → `results.composition`**
  - 前端字段（七大固定键，对应 Figma 七段）：
    - `画面主结构分析?: string`
    - `主体位置与视觉权重?: string`
    - `线条与方向引导?: string`
    - `空间层次与分区?: string`
    - `比例与留白?: string`
    - `视觉平衡与动势?: string`
    - `构图风格归类与改进建议?: string`
  - 协议要求：
    - Prompt Part1 必须产出构图七段，自然语言中带有严格标题；
    - `sections.composition.structured.advanced_sections` 建议为数组结构，`analysisFormatter` 负责把数组映射成上述七个键（缺段落用空字符串占位并记录 warning）。

- **Lighting（光影参数） → `results.lighting`**
  - 前端字段：
    - `basic?: {`
      - `exposure?:   { range: string; note?: string }`
      - `contrast?:   { range: string; note?: string }`
      - `highlights?: { range: string; note?: string }`
      - `shadows?:    { range: string; note?: string }`
      - `whites?:     { range: string; note?: string }`
      - `blacks?:     { range: string; note?: string }`
      - `}`
    - `texture?: {`
      - `texture?:    { range: string; note?: string }`
      - `clarity?:    { range: string; note?: string }`
      - `dehaze?:     { range: string; note?: string }`
      - `saturation?: { range: string; note?: string }`
      - `vibrance?:   { range: string; note?: string }`
      - `}`
  - 协议要求：
    - Prompt Part1/Part2 允许用自然语言描述光影趋势（例如“略微增加曝光约 +0.3EV”），`analysisFormatter` 负责：
      - 解析出标准数值字符串（`range`，如 `"+0.30"`、`"-25"`）；
      - 把解释性句子写入 `note`；
      - 若只给出模糊描述（“微调”），则 `range` 使用默认值 `"+0"`，`note` 保留原文。

- **Color（色彩方案） → `results.color`**
  - 前端字段：
    - `styleKey: string`
    - `whiteBalance: {`
      - `temp: { range: string; note?: string }`
      - `tint: { range: string; note?: string }`
      - `}`
    - `grading: {`
      - `highlights: { hue: number | string; saturation: number | string }`
      - `midtones:   { hue: number | string; saturation: number | string }`
      - `shadows:    { hue: number | string; saturation: number | string }`
      - `balance:    number | string`
      - `}`
    - `hsl: Array<{`
      - `color: string;           // "红/橙/黄/绿/青/蓝/紫/洋红"`
      - `hue: string;             // "±xx"`
      - `saturation: string;      // "±xx"`
      - `luminance: string;       // "±xx"`
      - `note?: string;`
      - `}>`
  - 协议要求：
    - Prompt Part2 中必须输出可解析的 HSL / 色彩分级描述（可以是自然语言，但要包含具体数值或“略微/明显”等可推断信息）；
    - `analysisFormatter`：
      - 把自然语言解析为 `hue/saturation/luminance` 字符串（`"+10"` 等），解析失败时用默认 `"0"` 并把原文写入 `note`；
      - 把“三段色彩分级”解析为 `grading` 的 `highlights/midtones/shadows/balance`，解析不到时给默认中性值并写 warning。

- **Lightroom（LR 参数 + 可行性） → `results.lightroom` / `results.lightroom_extra`**
  - 主参数 `results.lightroom: LightroomPanel[]`：
    - `title: string`                        // 面板标题："基础调整" / "曲线" / "HSL" / "色彩分级" / "细节" 等
    - `params: { name: string; value: string; reason?: string }[]`
    - `note?: string`
    - `masks?: { title: string; description: string; params: { name; value }[] }[]`
  - 可行性与调色思路 `results.lightroom_extra`（对应可行性评估 + LR 卡片概要）：
    - `conversion_feasibility: {`
      - `can_transform: boolean`
      - `difficulty: string`
      - `confidence: number`
      - `limiting_factors?: string[]`
      - `recommendation?: string`
      - `}`
  - 协议要求：
    - Prompt Part2 中对 LR 面板可以先给自然语言（“基础面板曝光+0.3，高光-40…”），也可以给半结构化文本；
    - `analysisFormatter` 必须：
      - 将所有 LR 参数转成固定 `params[]` 列表，`value` 统一使用字符串 + 显式正负号；
      - 从 `workflow_alignment_notes` / 可行性 JSON 中填充 `conversion_feasibility`；
      - 对局部调整蒙版仅保留能映射到 UI 的必要字段，其余原文作为 `notes`。

- **Photoshop（PS 步骤） → `results.photoshop`**
  - 前端字段（数组，每一项为一个步骤）：
    - `title: string`
    - `description: string`
    - `params?: { name: string; value: string; reason?: string }[]`
    - `details?: string`
    - `blendMode?: string`
    - `opacity?: string`
  - 协议要求：
    - Prompt Part2 对 PS 步骤的输出可采用“逐步说明 + 参数列表”的自然语言形式；
    - `analysisFormatter` 将各步骤的自然语言拆解为 `steps[]`：
      - `title` 来自步骤标题或序号；
      - `description` 是步骤概括；
      - 文本中的参数对（“曝光+0.3、对比+10…”）被解析为 `params[]`；
      - 图层混合模式/不透明度从文本中抽取到 `blendMode` / `opacity`；
      - 无法结构化的说明统一放到 `details`。

### 25. 帐号与权限体系细化（结合顶层设计）

- **身份与角色模型**
  - `users` 表：
    - 基础字段：`id`、`email/phone`、`password_hash`、`display_name`、`avatar_url`、`status`（active/disabled）、`created_at/updated_at`；
    - 角色字段：`role ENUM('user','admin') DEFAULT 'user'`；如需多角色，则增加 `roles`、`role_permissions`、`user_roles` 三张表，支持一人多角色（参见顶层设计 3.5）。
  - `auth_tokens` 表：
    - 字段：`id`、`user_id`、`type`（`session` / `admin_session` / `email_otp` / `admin_mfa` 等）、`token`（或其哈希）、`expired_at`、`consumed`、`created_at`；
    - 用途：统一管理所有登录会话与一次性验证码，支持单点登出与安全审计。
  - 审计与安全表：
    - `login_attempts`：记录所有登录成功/失败（含 IP、User-Agent、result），支持风控与锁定策略；
    - `audit_logs`：记录管理后台关键操作（创建/修改/删除用户、订阅、任务、配置等）。

- **JWT 载荷与 Token 类型**
  - 主站用户 `session`（普通用户）：
    - `sub`: userId
    - `type`: `"session"`
    - `role`: `"user"`（或来自 `users.role`）
    - `exp`: 过期时间（例如 2 小时）
  - 管理后台 `admin_session`：
    - `sub`: adminUserId
    - `type`: `"admin_session"`
    - `role`: `"admin"`
    - `permissions?`: 字符串数组，可用于前端控制菜单与按钮；
    - `exp`: 更短的有效期（例如 1 小时），配合 `admin_mfa` 使用更安全。

- **后端中间件映射**
  - `authMiddleware`：
    - 从 `Authorization: Bearer <JWT>` 解析 Token；
    - 校验签名、过期时间，并从 `auth_tokens` 表检查是否已吊销；
    - 在通过后注入 `req.user = { id, role, type }`；
    - 仅允许 `type = 'session'` 访问主站接口。
  - `requireAdmin`：
    - 在 `authMiddleware` 后执行，要求：
      - `req.user.type === 'admin_session'`
      - `req.user.role === 'admin'`
    - 如开启细粒度权限，则再检查 `req.user.permissions` 是否包含所需权限；
    - 所有 `/api/admin/**` 路由必须挂载该中间件。
  - `authMiddlewareForQuery`（下载专用）：
    - 从 Query 中读取 `downloadToken`，在 `auth_tokens` 表中校验其有效性与所属用户；
    - 将 `req.user` 设置为对应用户，并在使用后标记该 token 为 `consumed`；
    - 应用于 `/api/export/xmp|jsx|json|pdf` 等导出接口。

- **前端对应实现**
  - 主站前端：
    - 登录成功后，后端返回：
      - `accessToken`（JWT，type=`session`）；
      - `user`（`id`、`display_name`、`role`、`avatar_url` 等）；
    - `AuthContext` / `userStore` 负责保存 `accessToken` 与 `user`，并在 `api.ts` 请求拦截器中自动附带 `Authorization` 头；
    - 当收到 `401/UNAUTHORIZED` 时：
      - 清理本地 Token；
      - 跳转登录页或弹出登录对话框。
  - 管理后台前端：
    - 管理员登录页调用 `POST /api/admin/auth/login`；
    - 成功后将 `adminAuthToken`（`admin_session` JWT）保存到 `localStorage`，并缓存 `adminUser`（含 `permissions`）；
    - `adminApi` 封装所有 `/api/admin/**` 请求，统一附带 `Authorization: Bearer <admin_session>`；
    - 收到 `403/ADMIN_PERMISSION_DENIED` 时，提示权限不足，并根据 `permissions` 动态隐藏功能入口。

- **安全与锁定策略**
  - 管理员登录安全：
    - 连续失败次数超过 `AUTH_ADMIN_MAX_FAILED_ATTEMPTS` 时，在 `login_attempts` 中记录并锁定账号 `AUTH_ADMIN_LOCK_MIN` 分钟；
    - 登录成功后下发一次性 `admin_mfa`（邮箱验证码或 TOTP），验证通过后才生成 `admin_session`。
  - 普通用户安全：
    - 可选启用登录失败次数限制；
    - 对重要操作（删除任务、取消订阅等）增加二次确认或邮箱验证码；
    - 所有 Token 操作（创建/失效）落到 `auth_tokens` 与 `audit_logs` 表，方便事后审计。

#### 25.1 注册流程详细设计

- **邮箱注册流程（主要方式）**
  - 用户填写邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 设置密码 → 注册成功 → 自动登录
  - **接口**：
    - `POST /api/auth/send-verification-code`：发送验证码（`type="register"`）
    - `POST /api/auth/register`：提交注册（邮箱+验证码+密码）
  - **后端逻辑**：
    - 检查邮箱是否已注册（已注册返回错误）
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="email_otp"`, `expired_at=当前时间+10分钟`）
    - 调用阿里云邮件服务发送验证码（模板ID: `417051`）
    - 验证码验证通过后创建用户（`role="user"`, `status="active"`）
    - 自动创建免费版订阅（`analysis_per_month: 10`, `generations_per_month: 5`）
    - 生成 JWT Token（`type="session"`）并返回
  - **前端实现**：
    - `RegisterDialog.tsx`：显示邮箱输入、验证码输入（带倒计时）、密码输入
    - 验证码倒计时 60 秒，防止频繁发送
    - 注册成功后保存 `accessToken` 到 `localStorage`，关闭对话框

- **手机号注册（可选，当前迭代暂不实现）**
  - 保留 UI，但后端暂不实现，前端显示"功能开发中"提示

- **微信登录（可选，当前迭代暂不实现）**
  - 保留 UI，但后端暂不实现，前端显示"功能开发中"提示

#### 25.2 登录流程详细设计

- **普通用户登录（邮箱+密码）**
  - 用户输入邮箱和密码 → 点击"登录" → 后端验证 → 生成 Token → 返回用户信息
  - **接口**：`POST /api/auth/login`
  - **后端逻辑**：
    - 查询用户（`users` 表）
    - 验证密码（bcrypt）
    - 检查账号状态（`status="active"`）
    - 生成 JWT Token（`type="session"`）
    - 保存 Token 到 `auth_tokens` 表
    - 返回 `{ accessToken, user }`
  - **前端实现**：
    - `LoginDialog.tsx`：显示邮箱输入、密码输入
    - 登录成功后保存 `accessToken` 到 `localStorage`，关闭对话框

- **普通用户登录（邮箱+验证码）**
  - 用户输入邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 登录成功
  - **接口**：
    - `POST /api/auth/send-verification-code`：发送验证码（`type="login"`）
    - `POST /api/auth/login-with-code`：提交登录（邮箱+验证码）
  - **后端逻辑**：
    - 检查邮箱是否已注册（未注册返回错误）
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="email_otp"`, `user_id=用户ID`）
    - 调用阿里云邮件服务发送验证码
    - 验证码验证通过后生成 JWT Token（`type="session"`）
    - 返回 `{ accessToken, user }`
  - **前端实现**：
    - `LoginDialog.tsx`：添加"密码登录"和"验证码登录"切换选项
    - 验证码登录表单：邮箱输入、验证码输入（带倒计时按钮）
    - 验证码倒计时 60 秒，防止频繁发送

- **管理员登录（邮箱+密码+验证码，两步验证）**
  - 第一步：用户输入邮箱和密码 → 后端验证 → 发送验证码邮件 → 返回 `mfaToken`
  - 第二步：用户输入验证码 → 后端验证 → 生成 `admin_session` Token
  - **接口**：
    - `POST /api/admin/auth/login`：第一步（邮箱+密码）
    - `POST /api/admin/auth/verify-mfa`：第二步（`mfaToken`+验证码）
  - **后端逻辑**：
    - 第一步：验证密码，检查账号状态和角色（`role="admin"`），检查是否锁定
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="admin_mfa"`, `user_id=管理员ID`）
    - 调用阿里云邮件服务发送验证码
    - 返回临时 `mfaToken`（用于第二步验证）
    - 第二步：验证 `mfaToken` 和验证码，生成 JWT Token（`type="admin_session"`）
    - 返回 `{ adminAuthToken, adminUser }`
  - **前端实现**：
    - `AdminLoginDialog.tsx`：两步登录流程
    - 第一步：邮箱+密码输入
    - 第二步：验证码输入（带倒计时按钮）
    - 登录成功后保存 `adminAuthToken` 到 `localStorage`（与普通用户 Token 分开存储）

#### 25.3 邮箱验证码服务设计（阿里云）

- **配置信息**：
  - 发信域名：`t-react.com`
  - 发信地址：`noreply@t-react.com`
  - 验证码邮件模版ID：`417051`
  - RAM 用户登录名称：`quantanova2025@1849721908321781.onaliyun.com`
  - AccessKey ID：`<请从环境变量或配置文件中获取>`
  - AccessKey Secret：`<请从环境变量或配置文件中获取>`

- **后端实现**：
  - 服务文件：`server_py/app/services/email_service.py`
  - 功能：`send_verification_code(email: str, code: str, type: str = "register") -> bool`
  - 依赖：`alibabacloud-dm20151123`
  - 配置：在 `server_py/app/config.py` 中添加 `ALIYUN_ACCESS_KEY_ID`、`ALIYUN_ACCESS_KEY_SECRET`、`ALIYUN_EMAIL_FROM`、`ALIYUN_EMAIL_TEMPLATE_ID`
  - **响应检查**：阿里云 SDK 的响应对象没有 `status_code` 属性，需要通过检查 `response.body` 或异常来判断成功/失败。如果没有异常抛出，通常表示请求成功。

- **验证码生成与存储**：
  - 生成规则：6 位数字验证码（000000-999999），使用 `secrets.randbelow(1000000)` 生成
  - 存储表：`auth_tokens`
  - 字段：`type`（`"email_otp"` 或 `"admin_mfa"`）、`token`（验证码字符串）、`user_id`（注册时为 NULL，登录时为对应用户 ID）、`expired_at`（当前时间 + 10 分钟）、`consumed`（`False`）
  - 验证逻辑：查询 `auth_tokens` 表，检查验证码、过期时间、是否已消费，验证通过后标记为已消费

- **防刷机制**：
  - 同一邮箱 60 秒内只能发送一次验证码
  - 验证码有效期 10 分钟
  - 验证码使用后立即标记为已消费，不能重复使用

#### 25.4 强制登录检查实现

- **后端权限控制**：
  - 修改 `HTTPBearer` 为强制要求：在 `server_py/app/middleware/auth.py` 中，将 `security = HTTPBearer()` 改为 `security = HTTPBearer(auto_error=True)`
  - 接口分类：
    - **普通用户接口**（需要 `type="session"`）：
      - `/api/photos/upload` - 上传图片
      - `/api/analyze/*` - 所有分析接口（feasibility, part1, part2, getTask, history）
      - `/api/simulate/*` - 风格模拟
      - `/api/export/*` - 导出（XMP/JSX/JSON/PDF）
      - `/api/user/*` - 用户相关（me, usage, reports, profile, change-password）
    - **管理员接口**（需要 `type="admin_session"` 且 `role="admin"`）：
      - `/api/admin/*` - 所有管理后台接口
    - **公开接口**（不需要登录）：
      - `/api/auth/register` - 注册
      - `/api/auth/login` - 登录（邮箱+密码）
      - `/api/auth/login-with-code` - 登录（邮箱+验证码）
      - `/api/auth/send-verification-code` - 发送验证码
      - `/api/admin/auth/login` - 管理员登录（第一步）
      - `/api/admin/auth/verify-mfa` - 管理员验证码验证
      - `/health` - 健康检查

- **前端权限控制**：
  - API 调用拦截：在 `src/lib/api.ts` 的 `request` 和 `uploadRequest` 函数中，如果收到 401 错误，自动清除 Token 并弹出登录对话框
  - 功能入口拦截：`App.tsx` 的 `handleAnalyze` 在开始分析前检查登录状态，未登录则弹出登录对话框
  - 路由保护：为需要登录的页面添加路由守卫（当前项目使用页面状态管理，在 `App.tsx` 中检查即可）

#### 25.5 订阅体系集成

- **新用户默认订阅**：
  - 注册成功后自动创建免费版订阅（`plan_id=1`，`status="active"`）
  - 免费版限制：`analysis_per_month: 10`（Part1+Part2 计 1 次），`generations_per_month: 5`（Part3 计 1 次）
  - 订阅记录保存在 `subscriptions` 表，关联到 `users.id`

- **用量检查**：
  - 在调用分析接口前检查用户用量是否超出限制
  - 接口：`usage_service.check_usage(db, user_id, usage_type)`
  - 检查逻辑：
    - 获取用户当前订阅（`subscriptions` 表，`status="active"`）
    - 获取订阅计划限制（`subscription_plans.features`）
    - 统计本月已用次数（`analysis_tasks` 表，按 `created_at` 在当月）
    - 如果超出限制，返回错误码：`USAGE_ANALYSIS_LIMIT_EXCEEDED` 或 `USAGE_GENERATION_LIMIT_EXCEEDED`
  - 前端处理：显示"升级套餐"提示，阻止进一步点击

- **管理员变更订阅计划**：
  - 接口：`PUT /api/admin/subscriptions/users/{subscriptionId}`
  - 请求体：`{ plan_id, status?, end_at?, auto_renew?, reason? }`
  - 用途：测试、补偿、促销、调试
  - 权限：仅管理员可调用
  - 立即生效：变更后用户立即享受新计划的限制

### 26. 复刻可行性评估算法与 Feasibility Prompt 设计

- **评估目标与维度补充**
  - 目标：在用户进入 Part1 正式分析之前，用一次轻量级但专业的评估，判断“这两张图是否有足够条件做高质量仿色”，避免无效等待。
  - 评估维度（每一项都要产出量化指标 + 文本说明）：
    - 光线（L）：方向 / 强度 / 硬软 / 光源类型 / 高光-暗部对比 / 阴影扩散；
    - 色彩（C）：主导色 / 配色板 / 色彩直方图 / 色温 / 色域；
    - 场景元素与语义（S）：主体类别与语义分布是否相似（人物/天空/植被/建筑等）；
    - 构图与透视（P）：主体相对位置、比例、视角与透视关系；
    - 动态属性（D）：是否存在长曝/运动模糊/流水/星轨等难以复刻的动态效果；
    - 纹理与噪点（T）：胶片颗粒、人造噪点、锐度差异；
    - 图像质量与分辨率（Q）：分辨率、压缩伪影、SNR；
    - 后期特征（R）：明显 vignette、渐变映射、特殊 LUT/滤镜；
    - 可选：EXIF/元数据（拍摄时间/光圈/快门/ISO/焦距/白平衡）与语义可替代性（是否存在可裁切对齐的区域）。

- **指标体系与权重（score_i ∈ [0,1]）**
  - 每个维度输出 0.0–1.0 的相似/可行性得分，权重总和 = 1.0，可后续通过数据调整：
    - L 光线相似度：0.25
    - C 色彩相似度：0.20
    - S 语义/场景相似度：0.18
    - P 构图/透视相似度：0.12
    - D 动态/曝光属性：0.05
    - T 纹理/颗粒相似度：0.05
    - Q 分辨率与质量：0.03
    - R 后期特征：0.07
  - 具体实现：
    - 第一期可以由 Gemini 直接给出每一项 score 与 reason（model-based estimation）；
    - 后续可将部分维度替换为独立 CV 模型（语义分割、直方图相似度等）计算，再交由 Gemini 做解释与整合。

- **致命不兼容因子（Deal-breakers）**
  - 若出现以下任一情况，直接判定不可复刻（FeasibilityScore = 0，difficulty = "极高/不建议"），并在结果中写明原因：
    - 拍摄时间/环境强矛盾：一张夜景另一张白天，或明显室内 vs 室外；
    - 主体类型不匹配：目标图为人像，用户图为纯城市风景，且无可裁切替代区域；
    - 极端镜头差异：一张为微距/极广角，一张为远景航拍，主体 scale 完全不在同一量级；
    - 特殊光学/合成效果：长曝星轨、多重曝光、复杂合成，无法用常规 LR/PS 调色复刻；
    - 明显法律/版权/人像规则限制（如检测到第三方敏感素材）——可直接业务层禁止。
  - 当触发 deal-breaker 时，`dealBreakers[]` 必须列出具体原因，前端弹窗提示用户“无法复刻，并给出替代建议（更换目标图/重新拍摄等）”。

- **综合评分公式与难度/置信度**
  - 可行性得分（0.0–1.0）：
    - `FeasibilityScore = Σ weight_i * score_i`
  - 难度映射（示例，可配置）：
    - `FeasibilityScore ≥ 0.75` → 难度 = `"低"`（高可行性，容易复刻）；
    - `0.50 ≤ Score < 0.75` → 难度 = `"中"`；
    - `0.30 ≤ Score < 0.50` → 难度 = `"高"`；
    - `Score < 0.30` → 难度 = `"极高/不建议"`（可视作基本不可行）；
  - 置信度（0.0–1.0）示例公式：
    - `Confidence = min(1.0, 0.7 * (1 - uncertainty_from_metrics) + 0.3 * meta_confidence)`
    - 其中：
      - `uncertainty_from_metrics` 来自各子指标置信（由模型或算法提供），越不确定值越大；
      - `meta_confidence` 取决于 EXIF 完整度、图像质量等元数据可靠性。

- **Feasibility 结果 JSON 结构**
  - 存储在 `analysis_tasks.feasibility_result`，用于模态框和六大块的渲染与解释：
    ```json
    {
      "feasibilityScore": 0.614,
      "difficulty": "中",
      "confidence": 0.78,
      "dealBreakers": ["目标为夜景，用户图为强烈日光"],
      "dominantFactors": [
        { "name": "色彩相似度", "score": 0.45, "weight": 0.20, "reason": "色温差 180K，主色偏蓝" },
        { "name": "语义相似度", "score": 0.90, "weight": 0.18, "reason": "主体均为人像，背景简单" },
        { "name": "光线相似度", "score": 0.55, "weight": 0.25, "reason": "光源方向相差约 30°" }
      ],
      "recommendedActions": [
        { "action": "统一白平衡", "why": "色温差距导致肤色/天空偏差" },
        { "action": "尝试裁切目标图天空区域", "why": "提升语义重叠度" }
      ],
      "metrics": {
        "L": 0.55, "C": 0.45, "S": 0.90, "P": 0.70,
        "D": 0.80, "T": 0.60, "Q": 0.95, "R": 0.60
      },
      "explanation": "总体可行，但需先从白平衡和暗部调整入手，否则肤色与天空区域会存在明显差异。"
    }
    ```

- **Feasibility Prompt 设计与 Gemini 引导**
  - 细化 `getFeasibilityPrompt(referenceImage, userImage, exif)` 的输出要求（与第 23 节保持一致）：
    - 按上述 8 个维度输出：
      - 每个维度的 `score ∈ [0,1]`；
      - 简短的 `reason`（中文解释）；
    - 检测并列出所有 `dealBreakers[]`（如存在）；
    - 给出 `dominantFactors[]`（Top-3 拖累项，包含 name/score/weight/reason）；
    - 给出 `recommendedActions[]`（针对本次拍摄的具体建议）；
    - 给出整体 `FeasibilityScore`、`difficulty`、`confidence`，以及一段自然语言 `explanation`。
  - Prompt 末尾必须给出严格 JSON skeleton，约束字段名与范围，禁止新增字段，确保 `FeasibilitySchema` 可稳定解析。
  - 后端 `feasibilityService` 可以：
    - 直接使用模型给出的 `score_i` 和 `FeasibilityScore`；
    - 或在 Schema 校验后自行重算 `FeasibilityScore` 与 `difficulty`，以保证数值一致性。

- **API 与前端弹窗流程**
  - 接口：`POST /api/analyze/feasibility`
    - 入参：`sourceImage`、`targetImage`、可选 `taskId`；
    - 返回：上文 JSON 结构，同时写入 `analysis_tasks.feasibility_result`（若已有 `taskId`），或先在 `uploads` 侧缓存等待与任务关联。
  - 前端流程（简要）：
    - 用户上传两张图 → 点击“开始 AI 分析”：
      1. 先调用 `/api/analyze/feasibility`；
      2. 若返回 `dealBreakers.length > 0`：
         - 弹出“无法复刻（致命不兼容）”模态框，只提供“更换目标/重拍”等选项，可选“强制继续（不推荐）”；
      3. 若无致命因子：
         - 弹出“复刻可行性评估”模态，显示 `feasibilityScore`、`difficulty`、`confidence`、Top-3 拖累项和推荐操作；
         - 用户选择：
           - “继续分析（接受风险）” → 调用 `POST /api/analyze/part1` 进入正式分析；
           - “按建议调整并重试” → 关闭模态，回到上传/裁切界面。
  - 结果复用：
    - `feasibility_result` 同时喂给 `ReviewSection` 与 `LightroomSection` 的“可行性徽章/建议卡片”，与第 24 节的 `results.review.feasibility`、`results.lightroom_extra.conversion_feasibility` 结构一一对应。

### 27. 用户菜单与个人中心设计（抽屉式面板）

- **整体信息架构**
  - 触发入口：主站右上角头像按钮（如 Figma 截图所示）；
  - 点击后在右侧弹出“用户抽屉”（Drawer），包含以下菜单项：
    - 个人中心：查看和编辑基础资料（头像、昵称、邮箱）、安全设置入口；
    - 我的订阅：查看当前套餐、到期时间、自动续费状态，支持升降级、取消自动续费、查看账单明细；
    - 资源用量：展示本月已用分析次数（Part1+Part2 计 1 次）与生成照片次数（Part3 调用数），与订阅套餐额度绑定；
    - 我的仿色：展示本账号的历史仿色任务列表，点击可查看详情并下载报告；
    - 退出登录。
  - 交互形式：
    - 所有菜单项都在同一个右侧 Drawer 中切换不同的内容面板，而非跳转完整新页面；
    - Drawer 支持 ESC/遮罩关闭，切换菜单时保留滚动位置与加载状态。

- **前端实现（组件与数据流）**
  - 顶层组件：
    - `TopNav` 中增加 `UserMenu` 触发按钮，点击后设置 `userDrawerOpen = true`；
    - 新增组件 `UserDrawer.tsx`（或同等命名），内部通过 tabs 或侧边菜单切换四个子面板：
      - `ProfilePanel`（个人中心）；
      - `SubscriptionPanel`（我的订阅）；
      - `UsagePanel`（资源用量）；
      - `ReportsPanel`（我的仿色）。
  - 状态管理：
    - 使用已有 `AuthContext` / `userStore` 提供当前用户基本信息（`user.id`, `display_name`, `email`, `subscription` 摘要）；
    - `UserDrawer` 内部通过 `useQuery` / `SWR` 或自封装 hook 按需请求：
      - `/api/user/me` → 个人资料、当前订阅简要信息；
      - `/api/user/usage` → 本月分析/生成次数与套餐额度；
      - `/api/user/reports` → 历史仿色任务列表；
      - `/api/payments/invoices` → 账单明细（可选，如果按顶层设计启用）。
  - UI 行为：
    - ProfilePanel：展示基础信息，提供“编辑资料”入口（V1 可仅展示）；
    - SubscriptionPanel：
      - 展示当前订阅名称、价格、剩余时长、额度使用情况（结合 `/api/user/usage`）；
      - 提供“升级套餐”、“降级套餐”、“取消自动续费”、“查看账单”的按钮，点击跳转到订阅页 / 账单页或弹出对应对话框；
    - UsagePanel：
      - 展示“本月已用分析次数 / 套餐总次数”、“本月已用生成照片次数 / 套餐总次数”；
      - 不区分 Part1/Part2：每个任务分析（完成 Part1+Part2 即计一次），Part3 计入“生成照片次数”；
    - ReportsPanel：
      - 列表展示当前用户的仿色任务（`analysis_tasks` 中 Part3 完成的任务），包含：缩略图、任务创建时间、可行性摘要、状态；
      - 每行提供“查看详情”按钮（跳转到结果页或弹出报告预览）和“下载报告”按钮（调用导出接口）。

- **后端接口设计（与现有表结构对齐）**
  - 基础用户信息：
    - `GET /api/user/me`（需要 `session`）：
      - 返回：
        - `user`: `{ id, email, display_name, avatar_url, role, created_at }`
        - `subscriptionSummary`: `{ plan_id, plan_name, status, end_at, auto_renew, limits: { analysis_per_month, generations_per_month } }`
      - 数据来源：`users`、`subscriptions`、`subscription_plans`。
  - 资源用量：
    - `GET /api/user/usage`：
      - 输入：隐式使用当前 `userId`，可选 `month`（默认当前月份）；
      - 返回：
        ```json
        {
          "analysisUsed": 12,
          "analysisLimit": 50,
          "generationUsed": 8,
          "generationLimit": 30,
          "period": "2025-11"
        }
        ```
      - 计算规则：
        - `analysisUsed`：统计本月完成 Part1+Part2 的任务数（从 `analysis_tasks` 按 `status=completed` 或 `part2_completed=1` 且 `created_at` 在当月）；  
        - `generationUsed`：统计本月调用风格模拟 Part3 成功次数（例如 `analysis_tasks` 中存在有效 `preview_image_url` 且时间在当月）；  
        - `analysisLimit` / `generationLimit`：从当前用户订阅的 `subscription_plans.features` 中读取；  
        - 不区分 Part1 与 Part2，统一算一次“分析任务”。
  - 我的订阅：
    - `GET /api/user/subscription`：
      - 返回当前订阅详细信息：计划名称、价格、周期、下次扣费时间、自动续费状态、历史变更记录（可选）；
    - `POST /api/user/subscription/change`：
      - 用于升级/降级计划，入参为 `target_plan_id`，内部创建支付订单或直接变更（视计费模型而定）；
    - `POST /api/user/subscription/cancel-auto-renew`：
      - 关闭自动续费，更新 `subscriptions.status` 或 `metadata`；
    - `GET /api/user/invoices`（可选）：
      - 列出账单明细（结合 `payments` 表）。
  - 我的仿色（报告中心视图）：
    - `GET /api/user/reports`：
      - 查询当前用户下所有已完成 Part3 的任务，支持分页：
        ```json
        {
          "items": [
            {
              "taskId": "uuid",
              "created_at": "2025-11-15T10:23:00Z",
              "feasibilityScore": 0.61,
              "difficulty": "中",
              "preview_image_url": "https://...",
              "source_image_thumbnail": "https://...",
              "status": "completed"
            }
          ],
          "page": 1,
          "pageSize": 20,
          "total": 42
        }
        ```
      - 数据来源：`analysis_tasks`（结合 `uploads` 缩略图字段），只筛选 `status='completed'` 且存在 `preview_image_url` 的记录。
    - 用户点击单个报告的“查看详情”：
      - 前端可重用现有 `GET /api/analyze/:taskId` 接口，加载完整分析结果；
    - “下载报告”：
      - 调用现有/规划中的导出接口（例如 `GET /api/report/pdf?taskId=&downloadToken=`）生成 PDF；
      - 可通过 `ColorCloningReport` 的 HTML 模板 + chartService（直方图/曲线/色轮）生成完整仿色报告。

- **订阅与用量绑定规则**
  - 订阅计划表 `subscription_plans.features` 中需至少包含：
    - `analysis_per_month`：每月允许的分析任务次数（Part1+Part2 合计）；  
    - `generations_per_month`：每月允许的风格模拟（Part3）次数；
  - `usageService`（后端）负责：
    - 每次任务完成 Part1+Part2 时增加分析计数；  
    - 每次 Part3 成功生成预览图时增加生成计数；  
    - 提供 `getUserUsage(userId, period)` 方法给 `/api/user/usage` 使用；
    - 在超出额度前返回友好错误码（如 `USAGE_ANALYSIS_LIMIT_EXCEEDED`、`USAGE_GENERATION_LIMIT_EXCEEDED`），前端据此在按钮处展示“升级套餐”提示。

- **权限与安全**
  - 所有 `/api/user/**` 接口都必须挂载 `authMiddleware`，仅允许 `type='session'` 的用户访问；
  - `GET /api/user/reports`、`/api/user/usage` 必须基于 `userId` 做严格过滤，防止越权查看他人用量或任务；
  - 下载报告时通过第 17 节定义的 `downloadToken` 机制保护链接安全。

#### 27.1 Admin 功能 → 接口对照 Check List

> 目的：为 Cursor/开发同学提供一张“功能 → 接口”一览表，避免在实现管理后台时发散开发或遗漏接口，仅需按照表中映射实现代码。

| Admin 页面/模块            | 前端组件                     | 关键按钮/交互                               | 后端接口（示例）                                                       | 说明 |
|---------------------------|------------------------------|---------------------------------------------|------------------------------------------------------------------------|------|
| Dashboard（运营概览）     | `Dashboard`                  | 仅展示指标与图表                             | `GET /api/admin/dashboard/metrics`                                     | 返回用户数、订阅数、任务数、收入等汇总指标 |
| 用户管理                  | `UsersManagement`            | 添加用户                                    | `POST /api/admin/users`                                               | 创建用户账号，写入 `users` 表 |
|                           |                              | 查看详情                                    | `GET /api/admin/users/:userId`                                        | 返回用户基本信息、订阅摘要、任务统计 |
|                           |                              | 停用账号                                    | `PATCH /api/admin/users/:userId { status: "disabled" }`               | 更新 `users.status` |
| 订阅管理 - 订阅计划       | `SubscriptionsManagement`    | 新建计划                                    | `POST /api/admin/plans`                                               | 创建 `subscription_plans` 记录 |
|                           |                              | 编辑计划                                    | `PUT /api/admin/plans/:planId`                                        | 修改名称/描述/价格/feature/limits |
|                           |                              | 启用/禁用计划                               | `PATCH /api/admin/plans/:planId/status`                               | 切换 `is_active` |
|                           |                              | （可选）恢复默认计划/清空计划               | `POST /api/admin/plans/reset-defaults` / `DELETE /api/admin/plans/*`  | 仅在 dev/运维场景使用 |
| 订阅管理 - 订阅用户       | `SubscriptionUsersList`      | 筛选（状态/计划）、搜索                     | `GET /api/admin/subscriptions/users?status=&planId=&q=`               | 基于 `subscriptions` + `users` 查询 |
|                           |                              | 导出数据                                    | `GET /api/admin/subscriptions/users/export`                           | 导出 CSV/JSON |
|                           |                              | 查看详情                                    | `GET /api/admin/subscriptions/users/:id`                              | 查看单个订阅用户详情 |
|                           |                              | 编辑信息（变更计划/状态）                   | `PUT /api/admin/subscriptions/users/:id`                              | 调整订阅计划、自动续费等 |
|                           |                              | 账单记录                                    | `GET /api/admin/users/:id/invoices`                                   | 基于 `payments` 表返回账单列表 |
|                           |                              | 删除订阅用户（或解除订阅）                  | `DELETE /api/admin/subscriptions/users/:id`                           | 谨慎使用，可仅做“取消订阅” |
| 支付管理 - 支付订单        | `PaymentsManagement`         | 筛选 / 搜索订单                             | `GET /api/admin/payments?status=&method=&q=`                          | 按状态/渠道/关键字查询 |
|                           |                              | 查看订单详情                                | `GET /api/admin/payments/:paymentId`                                  | 返回订单全量信息与回调日志摘要 |
|                           |                              | 发起退款（已完成订单）                      | `POST /api/admin/refunds` 或 `/api/admin/payments/:paymentId/refund` | 创建退款记录并触发渠道退款流程 |
|                           |                              | 导出订单数据                                | `GET /api/admin/payments/export`                                      | 导出 CSV |
| 支付管理 - 退款管理        | `PaymentsManagement`/Refunds Tab | 审核通过                                   | `POST /api/admin/refunds/:id/approve`                                 | 更新 `refunds.status="completed"` |
|                           |                              | 拒绝退款                                    | `POST /api/admin/refunds/:id/reject`                                  | 更新 `refunds.status="rejected"` |
| 支付管理 - 支付方式配置     | `PaymentsManagement`/Methods Tab | 启用/禁用支付方式                          | `PATCH /api/admin/payment-methods/:id { enabled: boolean }`           | 控制渠道可用性 |
| 任务管理                  | `TasksManagement`            | 筛选状态 / 搜索任务                         | `GET /api/admin/tasks?status=&q=`                                     | 从 `analysis_tasks` 查询 |
|                           |                              | 查看任务详情                                | `GET /api/admin/tasks/:taskId`                                        | 返回 `gemini_result` + `structured_result` + meta（第 19 节） |
|                           |                              | 重试失败任务                                | `POST /api/admin/tasks/:taskId/retry`                                 | 重新排队执行 Part2+Part3 Job |
| 内容管理                  | `ContentManagement` / `ContentEditor` | 加载内容块                           | `GET /api/admin/content?position=`                                    | 读取 `cms_blocks` |
|                           |                              | 创建/更新内容                               | `POST /api/admin/content` / `PUT /api/admin/content/:id`              | 新建或修改内容块 |
|                           |                              | 删除内容块                                  | `DELETE /api/admin/content/:id`                                       | 删除 CMS 记录 |
| 用量管理                  | `UsageManagement`            | 加载系统用量（任务数/分析量/生成量等）     | `GET /api/admin/usage/metrics`                                        | 基于 `analysis_tasks`、`uploads` 统计 |
| 数据分析                  | `Analytics`                  | 加载用户行为/来源数据                       | `GET /api/admin/analytics/metrics` 或更细分的 `/analytics/*`          | 顶层设计 12.1 中定义 |
| Admin 登录/退出           | `AdminLoginDialog` / `AdminPage` | 登录（第一步：邮箱+密码）                 | `POST /api/admin/auth/login`                                          | 返回 `mfaToken` |
|                           |                              | 登录（第二步：验证码）                   | `POST /api/admin/auth/verify-mfa`                                     | 返回 `adminAuthToken`（`admin_session` JWT） |
|                           |                              | （可选）退出登录                            | `POST /api/admin/auth/logout`                                         | 失效 `auth_tokens` 中对应记录 |

