# 注册、登录与权限设计方案

## 一、当前状态分析

### 1.1 前端交互逻辑（保持不变）

根据代码分析，当前的交互逻辑如下：

1. **滚动触发注册**（`ScrollableHero.tsx`）：
   - 当用户滚动超过 200px 且未登录时，自动弹出注册对话框
   - 已登录用户不会触发
   - **保持不变**

2. **点击"开始 AI 分析"触发登录**（`App.tsx`）：
   - 当前：直接调用 `handleAnalyze`，没有登录检查
   - **需要修改**：在 `handleAnalyze` 开始时检查登录状态，未登录则弹出登录对话框

3. **顶部导航栏登录按钮**（`TopNav.tsx`）：
   - 右上角"Log in"按钮，点击弹出登录对话框
   - **保持不变**

4. **登录/注册对话框切换**：
   - `LoginDialog` 和 `RegisterDialog` 支持相互切换
   - **保持不变**

### 1.2 后端认证状态

**问题**：
- 所有路由虽然都有 `credentials: HTTPAuthorizationCredentials = Depends(security)`，但 `HTTPBearer` 默认是 **optional** 的
- 未登录时 `credentials` 为 `None`，但代码中直接调用 `get_current_user` 会报错
- 实际上未登录也能调用接口（会报 401，但前端没有拦截）

**需要修复**：
- 所有需要登录的接口，必须强制要求 Token
- 前端在调用前检查登录状态，未登录则弹出登录对话框

## 二、设计方案

### 2.1 账号体系设计

#### 2.1.1 用户账号类型

1. **普通用户（user）**：
   - 注册方式：邮箱注册（必须邮箱验证码）
   - 登录方式：邮箱+密码，或邮箱+验证码
   - 权限：可以使用所有分析功能（受订阅限制）
   - 默认订阅：免费版（`analysis_per_month: 10`, `generations_per_month: 5`）

2. **管理员账号（admin）**：
   - 创建方式：**仅能通过数据库直接创建或后端管理接口创建**（不允许前端注册）
   - 登录方式：邮箱+密码+邮箱验证码（二次验证）
   - 权限：可以访问所有 `/api/admin/*` 接口
   - 特殊要求：
     - 连续失败登录 5 次锁定 15 分钟
     - 登录成功后必须验证邮箱验证码（MFA）
     - 验证码有效期 10 分钟，最多错误 5 次

#### 2.1.2 账号状态

- `active`：正常状态，可以使用所有功能
- `disabled`：被禁用，无法登录和使用功能
- `pending_verification`：注册后未验证邮箱（可选，当前迭代可暂不实现）

### 2.2 注册流程设计

#### 2.2.1 邮箱注册流程（主要方式）

```
用户填写邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 设置密码 → 注册成功 → 自动登录
```

**详细步骤**：

1. **用户输入邮箱**：
   - 前端验证邮箱格式
   - 点击"获取验证码"按钮

2. **后端发送验证码**：
   - 接口：`POST /api/auth/send-verification-code`
   - 请求体：`{ "email": "user@example.com", "type": "register" }`
   - 后端逻辑：
     - 检查邮箱是否已注册（已注册返回错误）
     - 生成 6 位数字验证码
     - 调用阿里云邮件服务发送验证码
     - 将验证码保存到 `auth_tokens` 表（`type="email_otp"`, `expired_at=当前时间+10分钟`）
     - 返回：`{ "code": 0, "message": "验证码已发送", "data": { "expiresIn": 600 } }`

3. **用户输入验证码和密码**：
   - 前端显示倒计时（60秒）
   - 用户输入验证码和密码（密码需符合规则：至少8位，包含字母和数字）

4. **提交注册**：
   - 接口：`POST /api/auth/register`
   - 请求体：`{ "email": "user@example.com", "verification_code": "123456", "password": "password123", "display_name": "用户名（可选）" }`
   - 后端逻辑：
     - 验证验证码（从 `auth_tokens` 表查询，检查是否过期、是否已消费）
     - 验证密码强度
     - 创建用户（`role="user"`, `status="active"`）
     - 标记验证码为已消费（`consumed=True`）
     - 生成 JWT Token（`type="session"`）
     - 保存 Token 到 `auth_tokens` 表
     - 返回：`{ "code": 0, "message": "注册成功", "data": { "accessToken": "...", "user": {...} } }`

5. **前端处理**：
   - 保存 `accessToken` 到 `localStorage`
   - 设置 `isLoggedIn = true`
   - 关闭注册对话框
   - 可以继续使用系统功能

#### 2.2.2 手机号注册（可选，当前迭代暂不实现）

- 保留 UI，但后端暂不实现
- 前端显示"功能开发中"提示

#### 2.2.3 微信登录（可选，当前迭代暂不实现）

- 保留 UI，但后端暂不实现
- 前端显示"功能开发中"提示

### 2.3 登录流程设计

#### 2.3.1 普通用户登录（邮箱+密码）

```
用户输入邮箱和密码 → 点击"登录" → 后端验证 → 生成 Token → 返回用户信息
```

**详细步骤**：

1. **用户输入邮箱和密码**：
   - 前端验证邮箱格式
   - 点击"登录"按钮

2. **提交登录**：
   - 接口：`POST /api/auth/login`
   - 请求体：`{ "email": "user@example.com", "password": "password123" }`
   - 后端逻辑：
     - 查询用户（`users` 表）
     - 验证密码（bcrypt）
     - 检查账号状态（`status="active"`）
     - 生成 JWT Token（`type="session"`）
     - 保存 Token 到 `auth_tokens` 表
     - 记录登录成功到 `login_attempts` 表（可选）
     - 返回：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`

3. **前端处理**：
   - 保存 `accessToken` 到 `localStorage`
   - 设置 `isLoggedIn = true`
   - 关闭登录对话框
   - 可以继续使用系统功能

#### 2.3.2 普通用户登录（邮箱+验证码）

**功能说明**：普通用户可以使用邮箱验证码登录，无需记住密码，提升用户体验。

```
用户输入邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 登录成功
```

**详细步骤**：

1. **用户输入邮箱**：
   - 前端验证邮箱格式
   - 点击"获取验证码"按钮

2. **后端发送验证码**：
   - 接口：`POST /api/auth/send-verification-code`
   - 请求体：`{ "email": "user@example.com", "type": "login" }`
   - 后端逻辑：
     - 检查邮箱是否已注册（未注册返回错误）
     - 检查账号状态（`status="active"`）
     - 生成 6 位数字验证码
     - 调用阿里云邮件服务发送验证码
     - 将验证码保存到 `auth_tokens` 表（`type="email_otp"`, `user_id=用户ID`, `expired_at=当前时间+10分钟`）
     - 返回：`{ "code": 0, "message": "验证码已发送", "data": { "expiresIn": 600 } }`

3. **用户输入验证码**：
   - 前端显示倒计时（60秒）
   - 用户输入验证码

4. **提交登录**：
   - 接口：`POST /api/auth/login-with-code`
   - 请求体：`{ "email": "user@example.com", "verification_code": "123456" }`
   - 后端逻辑：
     - 查询用户（`users` 表）
     - 验证验证码（从 `auth_tokens` 表查询，检查是否过期、是否已消费、是否属于该用户）
     - 检查账号状态（`status="active"`）
     - 标记验证码为已消费（`consumed=True`）
     - 生成 JWT Token（`type="session"`）
     - 保存 Token 到 `auth_tokens` 表
     - 返回：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`

5. **前端处理**：
   - 保存 `accessToken` 到 `localStorage`
   - 设置 `isLoggedIn = true`
   - 关闭登录对话框
   - 可以继续使用系统功能

**与注册验证码的区别**：
- 注册时：`user_id=NULL`，通过 `email` 字段查询验证码
- 登录时：`user_id=用户ID`，通过 `user_id` 和 `email` 查询验证码（双重验证，防止验证码被其他用户使用）

#### 2.3.3 管理员登录（邮箱+密码+验证码）

```
管理员输入邮箱和密码 → 点击"登录" → 后端验证密码 → 发送验证码邮件 → 管理员输入验证码 → 验证通过 → 生成 admin_session Token
```

**详细步骤**：

1. **管理员输入邮箱和密码**：
   - 前端：使用 `AdminLoginDialog` 组件
   - 点击"登录"按钮

2. **第一次验证（密码）**：
   - 接口：`POST /api/admin/auth/login`
   - 请求体：`{ "email": "admin@example.com", "password": "password123" }`
   - 后端逻辑：
     - 查询用户（`users` 表，`role="admin"`）
     - 验证密码
     - 检查账号状态和锁定状态（连续失败次数）
     - 生成临时 `admin_mfa` Token（有效期 10 分钟）
     - 调用阿里云邮件服务发送验证码
     - 将验证码保存到 `auth_tokens` 表（`type="admin_mfa"`）
     - 返回：`{ "code": 0, "message": "验证码已发送", "data": { "mfaToken": "...", "expiresIn": 600 } }`

3. **管理员输入验证码**：
   - 前端显示验证码输入框
   - 用户输入验证码

4. **第二次验证（验证码）**：
   - 接口：`POST /api/admin/auth/verify-mfa`
   - 请求体：`{ "mfaToken": "...", "verification_code": "123456" }`
   - 后端逻辑：
     - 验证 `mfaToken` 和验证码（从 `auth_tokens` 表查询）
     - 检查验证码是否过期、是否已消费、错误次数
     - 标记验证码为已消费（`consumed=True`）
     - 生成 `admin_session` JWT Token
     - 保存 Token 到 `auth_tokens` 表
     - 记录登录成功
     - 返回：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`

5. **前端处理**：
   - 保存 `adminAuthToken` 到 `localStorage`（与普通用户 Token 分开存储）
   - 跳转到管理后台页面

### 2.4 权限控制设计

#### 2.4.1 后端权限控制

**需要强制登录的接口**（所有分析、上传、导出、用户相关接口）：

1. **修改 `HTTPBearer` 为强制要求**：
   - 在 `server_py/app/middleware/auth.py` 中，将 `security = HTTPBearer()` 改为 `security = HTTPBearer(auto_error=True)`
   - 这样未提供 Token 时会自动返回 401

2. **接口分类**：

   **普通用户接口**（需要 `type="session"`）：
   - `/api/photos/upload` - 上传图片
   - `/api/analyze/*` - 所有分析接口（feasibility, part1, part2, getTask, history）
   - `/api/simulate/*` - 风格模拟
   - `/api/export/*` - 导出（XMP/JSX/JSON/PDF）
   - `/api/user/*` - 用户相关（me, usage, reports, profile, change-password）

   **管理员接口**（需要 `type="admin_session"` 且 `role="admin"`）：
   - `/api/admin/*` - 所有管理后台接口

**公开接口**（不需要登录）：
  - `/api/auth/register` - 注册
  - `/api/auth/login` - 登录（邮箱+密码）
  - `/api/auth/login-with-code` - 登录（邮箱+验证码）
  - `/api/auth/send-verification-code` - 发送验证码（支持 `type="register"` 或 `type="login"`）
  - `/api/admin/auth/login` - 管理员登录（第一步）
  - `/api/admin/auth/verify-mfa` - 管理员验证码验证
  - `/health` - 健康检查

#### 2.4.2 前端权限控制

1. **API 调用拦截**：
   - 在 `src/lib/api.ts` 的 `request` 和 `uploadRequest` 函数中，如果收到 401 错误，自动清除 Token 并弹出登录对话框

2. **功能入口拦截**：
   - `App.tsx` 的 `handleAnalyze`：在开始分析前检查登录状态，未登录则弹出登录对话框
   - `PhotoUploadZone`：上传前检查登录状态（可选，因为上传接口本身会返回 401）

3. **路由保护**（如果使用 React Router）：
   - 为需要登录的页面添加路由守卫
   - 当前项目使用页面状态管理，在 `App.tsx` 中检查即可

### 2.5 邮箱验证码服务设计（阿里云）

#### 2.5.1 配置信息

- **发信域名**：`t-react.com`
- **发信地址**：`noreply@t-react.com`
- **验证码邮件模版ID**：`417051`
- **RAM 用户登录名称**：`quantanova2025@1849721908321781.onaliyun.com`
- **AccessKey ID**：`<请从环境变量或配置文件中获取>`
- **AccessKey Secret**：`<请从环境变量或配置文件中获取>`

#### 2.5.2 后端实现

**服务文件**：`server_py/app/services/email_service.py`

**功能**：
1. `send_verification_code(email: str, code: str, type: str = "register") -> bool`
   - 调用阿里云邮件服务 API
   - 使用模板 `417051` 发送验证码
   - 支持 `type="register"`（注册）和 `type="login"`（登录）
   - 返回发送是否成功

**依赖**：
- 需要安装阿里云 SDK：`pip install alibabacloud-dm20151123`

**配置**：
- 在 `server_py/app/config.py` 中添加：
  ```python
  ALIYUN_ACCESS_KEY_ID: str = ""
  ALIYUN_ACCESS_KEY_SECRET: str = ""
  ALIYUN_EMAIL_FROM: str = "noreply@t-react.com"
  ALIYUN_EMAIL_TEMPLATE_ID: str = "417051"
  ```

#### 2.5.3 验证码生成与存储

**生成规则**：
- 6 位数字验证码（000000-999999）
- 使用 `secrets.randbelow(1000000)` 生成

**存储**：
- 表：`auth_tokens`
- 字段：
  - `type`: `"email_otp"`（普通用户注册/登录）或 `"admin_mfa"`（管理员二次验证）
  - `token`: 验证码字符串（6位数字）
  - `user_id`: 用户 ID（注册时为 NULL，登录时为对应用户 ID）
  - `expired_at`: 当前时间 + 10 分钟
  - `consumed`: `False`（未使用）

**验证逻辑**：
1. 查询 `auth_tokens` 表，条件：
   - `type="email_otp"` 或 `"admin_mfa"`
   - `token=验证码`
   - `email=用户邮箱`（通过 `user_id` 关联，或单独存储 `email` 字段）
   - `consumed=False`
   - `expired_at > 当前时间`
2. 如果找到，标记为 `consumed=True`
3. 如果未找到或已过期，返回错误

**防刷机制**：
- 同一邮箱 60 秒内只能发送一次验证码
- 检查 `auth_tokens` 表中该邮箱最近一次发送时间

### 2.6 前端交互逻辑修改（最小改动）

#### 2.6.1 App.tsx 修改

**在 `handleAnalyze` 函数开始处添加登录检查**：

```typescript
const handleAnalyze = async () => {
  // 检查登录状态
  const isLoggedIn = localStorage.getItem('isLoggedIn') === 'true';
  if (!isLoggedIn) {
    // 弹出登录对话框（需要添加状态管理）
    setShowLoginDialog(true);
    toast.info('请先登录后再进行分析');
    return;
  }

  if (!sourceImage || !targetImage) return;
  
  // 原有逻辑...
};
```

**需要添加的状态**：
- `const [showLoginDialog, setShowLoginDialog] = useState(false);`
- 在 `renderUploadContent` 中添加 `<LoginDialog isOpen={showLoginDialog} onClose={() => setShowLoginDialog(false)} />`

#### 2.6.2 api.ts 修改

**在 `request` 和 `uploadRequest` 函数中添加 401 拦截**：

```typescript
// 在 response 处理之后，检查 401 错误
if (response.status === 401) {
  // 清除 Token
  localStorage.removeItem('accessToken');
  localStorage.removeItem('isLoggedIn');
  localStorage.removeItem('userData');
  
  // 抛出特殊错误，前端可以捕获并弹出登录对话框
  throw new ApiError(401, '请先登录', { requireLogin: true });
}
```

#### 2.6.3 LoginDialog.tsx 修改

**添加邮箱验证码登录选项**：
- 保留现有邮箱+密码登录
- 添加"使用验证码登录"选项（UI 已存在，需要实现后端对接）
- 实现逻辑：
  1. 用户选择"邮箱登录"标签页
  2. 添加"使用验证码登录"切换按钮（或下拉选项）
  3. 切换到验证码登录模式时：
     - 显示邮箱输入框和"获取验证码"按钮
     - 显示验证码输入框
     - 隐藏密码输入框
  4. 点击"获取验证码"：
     - 调用 `POST /api/auth/send-verification-code`（`type="login"`）
     - 显示 60 秒倒计时
  5. 输入验证码后点击"登录"：
     - 调用 `POST /api/auth/login-with-code`
     - 登录成功后处理同密码登录

**修改注册流程**：
- 添加"获取验证码"按钮功能
- 调用 `POST /api/auth/send-verification-code`（`type="register"`）
- 添加倒计时显示
- 提交注册时包含验证码

#### 2.6.4 RegisterDialog.tsx 修改

**完善邮箱注册流程**：
1. 添加"获取验证码"按钮点击事件
2. 调用 `POST /api/auth/send-verification-code`
3. 添加 60 秒倒计时
4. 提交注册时包含验证码字段
5. 显示验证码输入错误提示

### 2.7 数据库模型补充

#### 2.7.1 auth_tokens 表（已存在，需要确认字段）

当前字段：
- `id`, `user_id`, `type`, `token`, `expired_at`, `consumed`, `created_at`

**需要补充**（如果不存在）：
- `email`（可选）：用于存储邮箱，方便验证码查询（当 `user_id` 为 NULL 时）

**或者**：
- 保持现有结构，验证码查询时通过 `user_id` 关联 `users` 表获取邮箱

#### 2.7.2 login_attempts 表（可选，当前迭代可暂不实现）

用于记录登录尝试，支持账号锁定功能。

### 2.8 API 接口设计

#### 2.8.1 注册相关接口

**1. 发送验证码**
- `POST /api/auth/send-verification-code`
- 请求体：`{ "email": "user@example.com", "type": "register" | "login" }`
- 响应：`{ "code": 0, "message": "验证码已发送", "data": { "expiresIn": 600 } }`
- 错误码：
  - `EMAIL_ALREADY_REGISTERED`：邮箱已注册（仅当 `type="register"` 时）
  - `EMAIL_NOT_REGISTERED`：邮箱未注册（仅当 `type="login"` 时）
  - `SEND_CODE_TOO_FREQUENT`：发送过于频繁（60秒内）
  - `EMAIL_SEND_FAILED`：邮件发送失败
  - `ACCOUNT_DISABLED`：账号已被禁用（仅当 `type="login"` 时）

**2. 注册**
- `POST /api/auth/register`
- 请求体：`{ "email": "user@example.com", "verification_code": "123456", "password": "password123", "display_name": "用户名（可选）" }`
- 响应：`{ "code": 0, "message": "注册成功", "data": { "accessToken": "...", "user": {...} } }`
- 错误码：
  - `INVALID_VERIFICATION_CODE`：验证码错误或已过期
  - `WEAK_PASSWORD`：密码强度不足
  - `EMAIL_ALREADY_REGISTERED`：邮箱已注册

#### 2.8.2 登录相关接口

**1. 用户登录（邮箱+密码）**
- `POST /api/auth/login`
- 请求体：`{ "email": "user@example.com", "password": "password123" }`
- 响应：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`
- 错误码：
  - `INVALID_CREDENTIALS`：邮箱或密码错误
  - `ACCOUNT_DISABLED`：账号已被禁用
  - `ACCOUNT_LOCKED`：账号已锁定（连续失败次数过多）

**2. 用户登录（邮箱+验证码）**
- `POST /api/auth/login-with-code`
- 请求体：`{ "email": "user@example.com", "verification_code": "123456" }`
- 响应：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`
- 错误码：
  - `EMAIL_NOT_REGISTERED`：邮箱未注册
  - `INVALID_VERIFICATION_CODE`：验证码错误或已过期
  - `ACCOUNT_DISABLED`：账号已被禁用
  - `VERIFICATION_CODE_MISMATCH`：验证码不属于该用户（安全保护）

**3. 管理员登录（第一步）**
- `POST /api/admin/auth/login`
- 请求体：`{ "email": "admin@example.com", "password": "password123" }`
- 响应：`{ "code": 0, "message": "验证码已发送", "data": { "mfaToken": "...", "expiresIn": 600 } }`
- 错误码：
  - `INVALID_CREDENTIALS`：邮箱或密码错误
  - `NOT_ADMIN`：不是管理员账号
  - `ACCOUNT_LOCKED`：账号已锁定

**4. 管理员验证码验证（第二步）**
- `POST /api/admin/auth/verify-mfa`
- 请求体：`{ "mfaToken": "...", "verification_code": "123456" }`
- 响应：`{ "code": 0, "message": "登录成功", "data": { "accessToken": "...", "user": {...} } }`
- 错误码：
  - `INVALID_MFA_TOKEN`：MFA Token 无效或已过期
  - `INVALID_VERIFICATION_CODE`：验证码错误
  - `MFA_CODE_EXPIRED`：验证码已过期
  - `MFA_MAX_ATTEMPTS_EXCEEDED`：验证码错误次数过多

#### 2.8.3 其他接口

**退出登录**（可选）：
- `POST /api/auth/logout`
- 需要 Token
- 后端逻辑：将当前 Token 标记为 `consumed=True`
- 前端逻辑：清除 `localStorage` 中的 Token

### 2.9 订阅体系集成

#### 2.9.1 新用户默认订阅

- 注册成功后，自动创建免费版订阅
- 在 `register_user` 方法中，创建用户后立即创建订阅记录

#### 2.9.2 用量检查

- 所有分析接口（`/api/analyze/*`）在开始处理前检查用户用量
- 如果超出限制，返回 `USAGE_ANALYSIS_LIMIT_EXCEEDED` 或 `USAGE_GENERATION_LIMIT_EXCEEDED`
- 前端显示升级提示

#### 2.9.3 后端管理员变更订阅计划（随机变更）

**功能说明**：管理员可以在后台随机变更用户的订阅计划，用于测试、补偿、促销等场景。

**接口设计**：
- `PUT /api/admin/subscriptions/users/{subscriptionId}`
- 请求体：`{ "plan_id": 2, "status": "active", "end_at": "2025-12-31T23:59:59Z", "auto_renew": true, "reason": "测试补偿" }`
- 响应：`{ "code": 0, "message": "订阅已更新", "data": { "subscription": {...} } }`

**后端逻辑**：
1. 验证管理员权限
2. 查询订阅记录（`subscriptions` 表）
3. 查询目标订阅计划（`subscription_plans` 表）
4. 更新订阅记录：
   - `plan_id`：新的计划 ID
   - `status`：订阅状态（`active`/`paused`/`canceled`）
   - `end_at`：到期时间（可选，不传则按新计划的周期计算）
   - `auto_renew`：自动续费（可选）
   - `extra_data`：记录变更原因和操作人
5. 记录审计日志（`audit_logs` 表）：
   - `action`: `"change_subscription"`
   - `target_type`: `"subscription"`
   - `target_id`: `subscriptionId`
   - `before`: 变更前的订阅信息（JSON）
   - `after`: 变更后的订阅信息（JSON）
   - `admin_id`: 操作的管理员 ID

**使用场景**：
- 测试：给测试账号分配高级套餐
- 补偿：用户投诉后补偿高级套餐
- 促销：活动期间临时升级用户套餐
- 调试：验证不同套餐的用量限制逻辑

**注意事项**：
- 变更订阅计划后，用户立即享受新计划的限制（用量检查会使用新计划）
- 如果新计划的限制更严格，用户可能立即无法使用某些功能（需要前端提示）
- 建议在变更时记录原因，便于后续审计

### 2.10 安全增强

#### 2.10.1 密码强度要求

- 至少 8 位字符
- 包含字母和数字
- 前端和后端双重验证

#### 2.10.2 验证码安全

- 验证码有效期：10 分钟
- 验证码只能使用一次（`consumed=True`）
- 防刷：同一邮箱 60 秒内只能发送一次
- 验证码错误次数限制（管理员 MFA：最多 5 次）

#### 2.10.3 账号锁定

- 管理员连续失败登录 5 次，锁定 15 分钟
- 普通用户暂不实现锁定（可选）

## 三、实现优先级

### 第一阶段（必须实现）

1. ✅ **强制登录检查**：
   - 修改 `HTTPBearer` 为 `auto_error=True`
   - 前端 `handleAnalyze` 添加登录检查
   - 前端 API 客户端添加 401 拦截

2. ✅ **邮箱验证码服务**：
   - 实现 `email_service.py`
   - 集成阿里云邮件服务
   - 实现验证码生成、存储、验证逻辑

3. ✅ **注册流程完善**：
   - 实现 `POST /api/auth/send-verification-code`
   - 修改 `POST /api/auth/register` 支持验证码
   - 前端 `RegisterDialog` 添加验证码功能

4. ✅ **管理员登录流程**：
   - 实现 `POST /api/admin/auth/login`（第一步）
   - 实现 `POST /api/admin/auth/verify-mfa`（第二步）
   - 前端 `AdminLoginDialog` 添加验证码输入

### 第二阶段（可选，当前迭代暂不实现）

1. ⏸️ 手机号注册/登录
2. ⏸️ 微信登录
3. ⏸️ 邮箱验证码登录（普通用户）
4. ⏸️ 账号锁定（普通用户）
5. ⏸️ 忘记密码功能

## 四、交互逻辑确认

### 4.1 保持不变

1. ✅ **滚动触发注册**：滚动超过 200px 且未登录时弹出注册对话框
2. ✅ **顶部登录按钮**：右上角"Log in"按钮点击弹出登录对话框
3. ✅ **登录/注册切换**：两个对话框可以相互切换

### 4.2 需要修改

1. ✅ **点击"开始 AI 分析"**：
   - **当前**：直接调用分析接口
   - **修改后**：先检查登录状态，未登录则弹出登录对话框，登录成功后再继续分析

2. ✅ **API 调用失败**：
   - **当前**：401 错误直接显示错误消息
   - **修改后**：401 错误自动清除 Token，弹出登录对话框

## 五、技术实现细节

### 5.1 后端实现

#### 5.1.1 邮箱服务（`server_py/app/services/email_service.py`）

```python
"""
邮箱服务 - 使用阿里云邮件服务发送验证码
"""
from alibabacloud_dm20151123.client import Client as DmClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_dm20151123 import models as dm_models
from loguru import logger
from ..config import get_settings

class EmailService:
    def __init__(self):
        self.settings = get_settings()
        self.client = self._create_client()
    
    def _create_client(self) -> DmClient:
        """创建阿里云邮件服务客户端"""
        config = open_api_models.Config(
            access_key_id=self.settings.ALIYUN_ACCESS_KEY_ID,
            access_key_secret=self.settings.ALIYUN_ACCESS_KEY_SECRET,
            endpoint='dm.aliyuncs.com'
        )
        return DmClient(config)
    
    def send_verification_code(self, email: str, code: str, type: str = "register") -> bool:
        """
        发送验证码邮件
        
        Args:
            email: 收件人邮箱
            code: 验证码（6位数字）
            type: 类型（register/login/admin_mfa）
        
        Returns:
            bool: 发送是否成功
        """
        try:
            request = dm_models.SingleSendMailRequest(
                account_name=self.settings.ALIYUN_EMAIL_FROM,
                address_type=1,  # 1: 发信地址
                to_address=email,
                template_code=self.settings.ALIYUN_EMAIL_TEMPLATE_ID,
                template_param=f'{{"code":"{code}"}}'  # 模板参数，根据实际模板调整
            )
            response = self.client.single_send_mail(request)
            logger.info(f"验证码邮件发送成功: {email}, code: {code}")
            return True
        except Exception as e:
            logger.error(f"验证码邮件发送失败: {email}, error: {e}")
            return False
```

#### 5.1.2 认证服务扩展（`server_py/app/services/auth_service.py`）

添加方法：
- `send_verification_code(db, email, type) -> str`：生成并发送验证码（支持 `type="register"` 和 `type="login"`）
- `verify_code(db, email, code, type, user_id=None) -> bool`：验证验证码
  - 注册时：`user_id=None`，通过 `email` 查询验证码
  - 登录时：`user_id=用户ID`，通过 `user_id` 和 `email` 双重验证
- `register_with_code(db, email, code, password, display_name) -> User`：使用验证码注册
- `login_with_code(db, email, code) -> Dict[str, Any]`：使用验证码登录

#### 5.1.3 认证路由扩展（`server_py/app/routes/auth.py`）

添加接口：
- `POST /api/auth/send-verification-code`（支持 `type="register"` 和 `type="login"`）
- 修改 `POST /api/auth/register` 支持验证码
- `POST /api/auth/login-with-code`（邮箱验证码登录）

#### 5.1.4 管理员认证路由（`server_py/app/routes/admin.py`）

添加接口：
- `POST /api/admin/auth/login`（第一步：密码验证+发送验证码）
- `POST /api/admin/auth/verify-mfa`（第二步：验证码验证+生成 admin_session）

#### 5.1.5 中间件修改（`server_py/app/middleware/auth.py`）

```python
# 修改为强制要求 Token
security = HTTPBearer(auto_error=True)  # 原来是 HTTPBearer()
```

### 5.2 前端实现

#### 5.2.1 API 客户端扩展（`src/lib/api.ts`）

添加接口：
- `authApi.sendVerificationCode(email, type)`（`type="register"` 或 `type="login"`）
- `authApi.registerWithCode(email, code, password, display_name)`
- `authApi.loginWithCode(email, code)`（邮箱验证码登录）
- `adminApi.login(email, password)`
- `adminApi.verifyMfa(mfaToken, code)`
- `adminApi.updateUserSubscription(subscriptionId, { plan_id, status, end_at, auto_renew, reason })`（变更订阅计划）

修改 `request` 和 `uploadRequest`：
- 401 错误时清除 Token 并抛出特殊错误

#### 5.2.2 App.tsx 修改

- 添加 `showLoginDialog` 状态
- `handleAnalyze` 开始时检查登录状态
- 添加 `LoginDialog` 组件

#### 5.2.3 RegisterDialog.tsx 修改

- 实现"获取验证码"按钮功能
- 添加倒计时显示
- 提交注册时包含验证码

#### 5.2.4 LoginDialog.tsx 修改

- 保持现有功能（邮箱+密码登录）
- 可选：添加验证码登录选项（后端暂不实现）

#### 5.2.5 AdminLoginDialog.tsx 修改

- 实现两步登录流程
- 第一步：邮箱+密码，显示"验证码已发送"
- 第二步：输入验证码，完成登录

### 5.3 配置更新

#### 5.3.1 config.py

```python
# 阿里云邮件服务配置
ALIYUN_ACCESS_KEY_ID: str = ""
ALIYUN_ACCESS_KEY_SECRET: str = ""
ALIYUN_EMAIL_FROM: str = "noreply@t-react.com"
ALIYUN_EMAIL_TEMPLATE_ID: str = "417051"
```

#### 5.3.2 requirements.txt

```
alibabacloud-dm20151123>=2.0.0
```

## 六、测试计划

### 6.1 功能测试

1. **注册流程**：
   - 发送验证码成功
   - 验证码过期处理
   - 验证码错误处理
   - 注册成功并自动登录

2. **登录流程**：
   - 邮箱+密码登录成功
   - 密码错误处理
   - 账号禁用处理

3. **管理员登录**：
   - 第一步（密码验证）成功
   - 验证码发送成功
   - 验证码验证成功
   - 验证码错误处理
   - 验证码过期处理

4. **权限控制**：
   - 未登录无法调用分析接口
   - 未登录无法上传图片
   - 普通用户无法访问管理后台
   - 管理员可以访问管理后台

### 6.2 安全测试

1. **验证码安全**：
   - 验证码过期后无法使用
   - 验证码使用后无法再次使用
   - 同一邮箱 60 秒内只能发送一次
   - 验证码错误次数限制（管理员 MFA）

2. **密码安全**：
   - 密码强度验证（前端+后端）
   - 密码加密存储（bcrypt）

3. **Token 安全**：
   - Token 过期后无法使用
   - Token 被标记为 consumed 后无法使用
   - 管理员 Token 和普通用户 Token 隔离

4. **权限控制**：
   - 普通用户无法访问管理员接口
   - 未登录用户无法访问需要认证的接口

### 6.3 集成测试

1. **完整注册流程**：
   - 发送验证码 → 输入验证码 → 设置密码 → 注册成功 → 自动登录 → 可以使用系统功能

2. **完整登录流程**：
   - 输入邮箱密码 → 登录成功 → 可以使用系统功能

3. **管理员登录流程**：
   - 输入邮箱密码 → 收到验证码 → 输入验证码 → 登录成功 → 可以访问管理后台

4. **权限拦截**：
   - 未登录点击"开始分析" → 弹出登录对话框 → 登录后继续分析

## 七、数据库模型补充

### 7.1 auth_tokens 表字段补充

**当前字段**：
- `id`, `user_id`, `type`, `token`, `expired_at`, `consumed`, `created_at`

**需要补充**：
- `email`（可选，`String(255), nullable=True`）：用于存储邮箱，方便验证码查询（当 `user_id` 为 NULL 时，如注册场景）

**设计说明**：
- 注册时：`user_id=NULL`, `email=用户邮箱`, `type="email_otp"`, `token=验证码`
- 登录时（普通用户验证码登录）：`user_id=用户ID`, `email=NULL`（可通过 user_id 关联获取）, `type="email_otp"`, `token=验证码`
- 登录时（管理员 MFA）：`user_id=管理员ID`, `email=NULL`（可通过 user_id 关联获取）, `type="admin_mfa"`, `token=验证码`
- 查询验证码时：
  - 注册场景：通过 `email` 和 `type="email_otp"` 查询（`user_id=NULL`）
  - 普通用户登录：通过 `user_id` 和 `type="email_otp"` 查询，并验证邮箱匹配
  - 管理员 MFA：通过 `user_id` 和 `type="admin_mfa"` 查询

**或者保持现有结构**：
- 不添加 `email` 字段
- 注册时验证码查询：先通过 `email` 查询 `users` 表获取 `user_id`，再查询 `auth_tokens`（但注册时用户还不存在，所以需要 `email` 字段）

**推荐方案**：添加 `email` 字段，因为注册时用户还不存在，无法通过 `user_id` 关联。

### 7.2 login_attempts 表（可选，当前迭代可暂不实现）

用于记录登录尝试，支持账号锁定功能。

**字段设计**：
- `id`, `user_id`, `email`, `ip_address`, `user_agent`, `result`（success/failed）, `failed_reason`, `created_at`

**用途**：
- 记录所有登录尝试（成功/失败）
- 统计连续失败次数
- 实现账号锁定功能

## 八、错误码表

### 8.1 认证相关错误码

| 错误码 | HTTP 状态码 | 说明 | 前端处理 |
|--------|------------|------|---------|
| `UNAUTHORIZED` | 401 | 未提供 Token 或 Token 无效 | 清除 Token，弹出登录对话框 |
| `INVALID_CREDENTIALS` | 401 | 邮箱或密码错误 | 显示错误提示 |
| `ACCOUNT_DISABLED` | 403 | 账号已被禁用 | 显示错误提示，引导联系客服 |
| `ACCOUNT_LOCKED` | 403 | 账号已锁定（连续失败次数过多） | 显示锁定提示和剩余时间 |
| `NOT_ADMIN` | 403 | 不是管理员账号 | 显示错误提示 |
| `INVALID_VERIFICATION_CODE` | 400 | 验证码错误或已过期 | 显示错误提示，允许重新发送 |
| `EMAIL_ALREADY_REGISTERED` | 400 | 邮箱已注册 | 显示错误提示，引导登录 |
| `SEND_CODE_TOO_FREQUENT` | 429 | 发送验证码过于频繁（60秒内） | 显示倒计时，禁用发送按钮 |
| `EMAIL_SEND_FAILED` | 500 | 邮件发送失败 | 显示错误提示，建议重试 |
| `WEAK_PASSWORD` | 400 | 密码强度不足 | 显示密码要求提示 |
| `INVALID_MFA_TOKEN` | 401 | MFA Token 无效或已过期 | 显示错误提示，引导重新登录 |
| `MFA_CODE_EXPIRED` | 400 | 验证码已过期 | 显示错误提示，允许重新发送 |
| `MFA_MAX_ATTEMPTS_EXCEEDED` | 403 | 验证码错误次数过多 | 显示错误提示，引导重新登录 |

### 8.2 权限相关错误码

| 错误码 | HTTP 状态码 | 说明 | 前端处理 |
|--------|------------|------|---------|
| `FORBIDDEN` | 403 | 无权限访问 | 显示权限不足提示 |
| `REQUIRE_LOGIN` | 401 | 需要登录 | 清除 Token，弹出登录对话框 |
| `REQUIRE_ADMIN` | 403 | 需要管理员权限 | 显示权限不足提示 |

### 8.3 用量相关错误码

| 错误码 | HTTP 状态码 | 说明 | 前端处理 |
|--------|------------|------|---------|
| `USAGE_ANALYSIS_LIMIT_EXCEEDED` | 403 | 分析次数已用完 | 显示升级提示，跳转订阅页 |
| `USAGE_GENERATION_LIMIT_EXCEEDED` | 403 | 生成次数已用完 | 显示升级提示，跳转订阅页 |

## 九、订阅体系集成详细设计

### 9.1 新用户默认订阅创建

**实现位置**：`server_py/app/services/auth_service.py` 的 `register_user` 方法

**流程**：
1. 创建用户成功后
2. 查询免费版订阅计划（`SubscriptionPlan` 表中 `name="免费版"` 或 `id=1`）
3. 如果不存在免费版计划，创建默认计划：
   ```python
   free_plan = SubscriptionPlan(
       name="免费版",
       description="免费体验套餐",
       price=0.00,
       period="monthly",
       features={
           "analysis_per_month": 10,
           "generations_per_month": 5
       },
       is_active=True,
       sort_order=0
   )
   db.add(free_plan)
   db.flush()  # 获取 plan.id
   ```
4. 创建用户订阅记录：
   ```python
   from datetime import datetime, timedelta
   
   subscription = Subscription(
       user_id=user.id,
       plan_id=free_plan.id,
       status="active",
       start_at=datetime.utcnow(),
       end_at=datetime.utcnow() + timedelta(days=30),  # 免费版默认 30 天
       extra_data={"auto_renew": False}
   )
   db.add(subscription)
   db.commit()
   ```

**注意事项**：
- 如果免费版计划已存在，直接使用
- 订阅创建失败不应影响用户注册（记录日志，后续可手动创建）

### 9.2 用量检查实现

**实现位置**：`server_py/app/services/usage_service.py` 的 `check_usage` 方法

**检查时机**：
- `POST /api/analyze/feasibility`：检查分析次数
- `POST /api/analyze/part1`：检查分析次数
- `POST /api/analyze/part2`：检查分析次数（如果 Part1 和 Part2 分开计费）
- `POST /api/simulate/style`：检查生成次数

**检查逻辑**：
```python
def check_usage(self, db: Session, user_id: int, usage_type: str) -> tuple[bool, Optional[str]]:
    """
    检查用户用量是否超出限制
    
    Args:
        db: 数据库会话
        user_id: 用户 ID
        usage_type: 用量类型（"analysis" 或 "generation"）
    
    Returns:
        (是否允许, 错误消息)
    """
    # 1. 获取用户当前订阅
    subscription = db.query(Subscription).filter(
        Subscription.user_id == user_id,
        Subscription.status == "active"
    ).first()
    
    if not subscription:
        return False, "未找到有效订阅"
    
    # 2. 获取订阅计划
    plan = db.query(SubscriptionPlan).filter(
        SubscriptionPlan.id == subscription.plan_id
    ).first()
    
    if not plan:
        return False, "订阅计划不存在"
    
    # 3. 获取计划限制
    features = plan.features or {}
    limit_key = "analysis_per_month" if usage_type == "analysis" else "generations_per_month"
    limit = features.get(limit_key, 0)
    
    # 4. 统计本月已用次数
    current_month = datetime.utcnow().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    if usage_type == "analysis":
        # 统计完成 Part1+Part2 的任务数
        used = db.query(func.count(AnalysisTask.id)).filter(
            AnalysisTask.user_id == user_id,
            AnalysisTask.status == "completed",
            AnalysisTask.part2_completed == True,
            AnalysisTask.created_at >= current_month
        ).scalar() or 0
    else:
        # 统计 Part3 成功生成的次数
        used = db.query(func.count(AnalysisTask.id)).filter(
            AnalysisTask.user_id == user_id,
            AnalysisTask.preview_image_url.isnot(None),
            AnalysisTask.created_at >= current_month
        ).scalar() or 0
    
    # 5. 检查是否超出限制
    if used >= limit:
        error_code = "USAGE_ANALYSIS_LIMIT_EXCEEDED" if usage_type == "analysis" else "USAGE_GENERATION_LIMIT_EXCEEDED"
        return False, error_code
    
    return True, None
```

**在路由中使用**：
```python
@router.post("/part1")
async def analyze_part1(...):
    # 检查用量
    allowed, error = usage_service.check_usage(db, current_user.id, "analysis")
    if not allowed:
        raise HTTPException(
            status_code=403,
            detail={
                "code": error if error.startswith("USAGE_") else "USAGE_ANALYSIS_LIMIT_EXCEEDED",
                "message": "分析次数已用完，请升级套餐"
            }
        )
    
    # 继续处理...
```

## 十、实现检查清单

### 10.1 后端实现清单

- [ ] **1. 配置更新**
  - [ ] 在 `config.py` 中添加阿里云邮件服务配置
  - [ ] 在 `requirements.txt` 中添加 `alibabacloud-dm20151123`

- [ ] **2. 数据库模型**
  - [ ] 确认 `auth_tokens` 表是否有 `email` 字段（如无，添加迁移）
  - [ ] 确认 `SubscriptionPlan` 表有免费版计划（如无，创建默认数据）

- [ ] **3. 邮箱服务**
  - [ ] 创建 `server_py/app/services/email_service.py`
  - [ ] 实现 `send_verification_code` 方法
  - [ ] 测试阿里云邮件服务连接

- [ ] **4. 认证服务扩展**
  - [ ] 在 `auth_service.py` 中添加 `send_verification_code` 方法（支持 `type="register"` 和 `type="login"`）
  - [ ] 在 `auth_service.py` 中添加 `verify_code` 方法
  - [ ] 修改 `register_user` 方法支持验证码
  - [ ] 修改 `register_user` 方法创建默认订阅
  - [ ] 在 `auth_service.py` 中添加 `login_with_code` 方法（邮箱验证码登录）

- [ ] **5. 认证路由扩展**
  - [ ] 在 `auth.py` 中添加 `POST /api/auth/send-verification-code`（支持 `type="register"` 和 `type="login"`）
  - [ ] 修改 `POST /api/auth/register` 支持验证码参数
  - [ ] 在 `auth.py` 中添加 `POST /api/auth/login-with-code`（邮箱验证码登录）

- [ ] **6. 管理员认证路由**
  - [ ] 在 `admin.py` 中添加 `POST /api/admin/auth/login`（第一步）
  - [ ] 在 `admin.py` 中添加 `POST /api/admin/auth/verify-mfa`（第二步）

- [ ] **7. 管理员订阅管理路由**
  - [ ] 在 `admin.py` 中添加 `PUT /api/admin/subscriptions/users/{subscriptionId}`（变更订阅计划）
  - [ ] 实现订阅计划变更逻辑
  - [ ] 记录审计日志

- [ ] **8. 中间件修改**
  - [ ] 修改 `middleware/auth.py` 中的 `security = HTTPBearer(auto_error=True)`

- [ ] **9. 用量检查**
  - [ ] 在所有分析接口中添加用量检查
  - [ ] 测试超出限制时的错误返回

### 10.2 前端实现清单

- [ ] **1. API 客户端扩展**
- [ ] 在 `api.ts` 中添加 `authApi.sendVerificationCode(email, type)`
- [ ] 在 `api.ts` 中修改 `authApi.register` 支持验证码
- [ ] 在 `api.ts` 中添加 `authApi.loginWithCode(email, code)`（邮箱验证码登录）
- [ ] 在 `api.ts` 中添加 `adminApi.login` 和 `adminApi.verifyMfa`
- [ ] 在 `api.ts` 中添加 `adminApi.updateUserSubscription(subscriptionId, data)`（变更订阅计划）
- [ ] 在 `request` 和 `uploadRequest` 中添加 401 拦截

- [ ] **2. App.tsx 修改**
  - [ ] 添加 `showLoginDialog` 状态
  - [ ] 在 `handleAnalyze` 开始时添加登录检查
  - [ ] 添加 `LoginDialog` 组件到 `renderUploadContent`

- [ ] **3. RegisterDialog.tsx 修改**
  - [ ] 实现"获取验证码"按钮点击事件
  - [ ] 调用 `POST /api/auth/send-verification-code`
  - [ ] 添加 60 秒倒计时显示
  - [ ] 提交注册时包含验证码字段
  - [ ] 显示验证码输入错误提示

- [ ] **4. LoginDialog.tsx 修改**
  - [ ] 保持现有功能（邮箱+密码登录）
  - [ ] 添加验证码登录选项（切换按钮或下拉选项）
  - [ ] 实现验证码登录流程：
    - [ ] 显示"获取验证码"按钮
    - [ ] 调用 `POST /api/auth/send-verification-code`（`type="login"`）
    - [ ] 添加 60 秒倒计时
    - [ ] 调用 `POST /api/auth/login-with-code` 完成登录

- [ ] **5. AdminLoginDialog.tsx 修改**
  - [ ] 实现两步登录流程
  - [ ] 第一步：邮箱+密码，调用 `POST /api/admin/auth/login`
  - [ ] 显示"验证码已发送"提示
  - [ ] 第二步：输入验证码，调用 `POST /api/admin/auth/verify-mfa`
  - [ ] 登录成功后跳转管理后台

### 10.3 测试清单

- [ ] **1. 注册流程测试**
  - [ ] 发送验证码成功
  - [ ] 验证码过期处理
  - [ ] 验证码错误处理
  - [ ] 注册成功并自动登录
  - [ ] 注册后自动创建免费版订阅

- [ ] **2. 登录流程测试**
  - [ ] 邮箱+密码登录成功
  - [ ] 密码错误处理
  - [ ] 账号禁用处理
  - [ ] 邮箱+验证码登录成功
  - [ ] 验证码登录时验证码错误处理
  - [ ] 验证码登录时验证码过期处理
  - [ ] 验证码登录时邮箱未注册处理

- [ ] **3. 管理员登录测试**
  - [ ] 第一步（密码验证）成功
  - [ ] 验证码发送成功
  - [ ] 验证码验证成功
  - [ ] 验证码错误处理
  - [ ] 验证码过期处理

- [ ] **4. 权限控制测试**
  - [ ] 未登录无法调用分析接口（返回 401）
  - [ ] 未登录无法上传图片（返回 401）
  - [ ] 普通用户无法访问管理后台（返回 403）
  - [ ] 管理员可以访问管理后台

- [ ] **5. 交互逻辑测试**
  - [ ] 滚动超过 200px 且未登录时弹出注册对话框
  - [ ] 点击"开始分析"且未登录时弹出登录对话框
  - [ ] 登录成功后可以继续分析
  - [ ] 401 错误自动清除 Token 并弹出登录对话框

## 十一、注意事项

### 11.1 交互逻辑保持不变

1. ✅ **滚动触发注册**：滚动超过 200px 且未登录时弹出注册对话框（`ScrollableHero.tsx`）
2. ✅ **顶部登录按钮**：右上角"Log in"按钮点击弹出登录对话框（`TopNav.tsx`）
3. ✅ **登录/注册切换**：两个对话框可以相互切换

### 11.2 需要修改的交互逻辑

1. ✅ **点击"开始 AI 分析"**：
   - **当前**：直接调用 `handleAnalyze`，没有登录检查
   - **修改后**：在 `handleAnalyze` 开始时检查登录状态，未登录则弹出登录对话框，登录成功后再继续分析

2. ✅ **API 调用失败**：
   - **当前**：401 错误直接显示错误消息
   - **修改后**：401 错误自动清除 Token，弹出登录对话框

### 11.3 实现优先级

**第一阶段（必须实现）**：
1. 强制登录检查（后端 `auto_error=True`，前端登录检查）
2. 邮箱验证码服务（阿里云集成）
3. 注册流程完善（验证码+密码）
4. 管理员登录流程（两步验证）
5. **普通用户邮箱验证码登录**（新增）
6. **后端管理员变更订阅计划功能**（新增）

**第二阶段（可选，当前迭代暂不实现）**：
1. 手机号注册/登录
2. 微信登录
3. 账号锁定（普通用户）
4. 忘记密码功能

### 11.4 安全注意事项

1. **验证码安全**：
   - 验证码有效期 10 分钟
   - 验证码只能使用一次
   - 同一邮箱 60 秒内只能发送一次
   - 验证码错误次数限制（管理员 MFA：最多 5 次）

2. **密码安全**：
   - 至少 8 位字符
   - 包含字母和数字
   - 前端和后端双重验证

3. **Token 安全**：
   - Token 过期时间 2 小时
   - Token 存储在 `auth_tokens` 表，支持单点登出
   - 管理员 Token 和普通用户 Token 隔离

4. **账号锁定**：
   - 管理员连续失败登录 5 次，锁定 15 分钟
   - 普通用户暂不实现锁定（可选）

## 十二、阿里云邮件服务配置详情

### 12.1 配置信息

- **发信域名**：`t-react.com`
- **发信地址**：`noreply@t-react.com`
- **验证码邮件模版ID**：`417051`
- **RAM 用户登录名称**：`quantanova2025@1849721908321781.onaliyun.com`
- **AccessKey ID**：`<请从环境变量或配置文件中获取>`
- **AccessKey Secret**：`<请从环境变量或配置文件中获取>`

### 12.2 环境变量配置

在 `.env` 文件中添加：
```bash
# 阿里云邮件服务配置
ALIYUN_ACCESS_KEY_ID=<请填写您的 AccessKey ID>
ALIYUN_ACCESS_KEY_SECRET=<请填写您的 AccessKey Secret>
ALIYUN_EMAIL_FROM=noreply@t-react.com
ALIYUN_EMAIL_TEMPLATE_ID=417051
```

### 12.3 模板参数格式

根据阿里云邮件服务文档，模板参数应为 JSON 字符串，例如：
```json
{"code":"123456"}
```

**注意**：需要确认模板 `417051` 的实际参数格式，可能需要调整代码中的 `template_param` 格式。

## 十四、普通用户邮箱验证码登录详细实现方案

### 14.1 前端 UI 设计

**LoginDialog.tsx 修改**：

1. **添加登录方式切换**：
   - 在"邮箱登录"标签页内，添加"密码登录"和"验证码登录"两个选项
   - 使用 Tab 切换或单选按钮组

2. **验证码登录表单**：
   ```typescript
   {loginMethod === 'email' && loginSubMethod === 'code' && (
     <>
       {/* 邮箱输入 */}
       <input type="email" value={email} ... />
       
       {/* 验证码输入区域 */}
       <div className="flex gap-3">
         <input 
           type="text" 
           value={verificationCode} 
           placeholder="输入验证码"
           maxLength={6}
           ...
         />
         <button 
           type="button"
           onClick={handleSendCode}
           disabled={emailCountdown > 0 || !email}
           className={...}
         >
           {emailCountdown > 0 ? `${emailCountdown}秒后重试` : '获取验证码'}
         </button>
       </div>
     </>
   )}
   ```

3. **状态管理**：
   ```typescript
   const [loginSubMethod, setLoginSubMethod] = useState<'password' | 'code'>('password');
   const [emailCountdown, setEmailCountdown] = useState(0);
   const [verificationCode, setVerificationCode] = useState('');
   ```

4. **发送验证码函数**：
   ```typescript
   const handleSendCode = async () => {
     if (!email || !validateEmail(email)) {
       toast.error('请输入正确的邮箱地址');
       return;
     }
     
     try {
       await authApi.sendVerificationCode(email, 'login');
       setEmailCountdown(60);
       toast.success('验证码已发送到您的邮箱');
     } catch (error) {
       if (error instanceof ApiError) {
         if (error.code === 'EMAIL_NOT_REGISTERED') {
           toast.error('该邮箱未注册，请先注册');
         } else if (error.code === 'SEND_CODE_TOO_FREQUENT') {
           toast.error('发送过于频繁，请稍后再试');
         } else {
           toast.error(error.message);
         }
       }
     }
   };
   ```

5. **验证码登录提交**：
   ```typescript
   const handleLoginWithCode = async (e: React.FormEvent) => {
     e.preventDefault();
     if (!email || !verificationCode) {
       toast.error('请输入邮箱和验证码');
       return;
     }
     
     setIsLoading(true);
     try {
       const result = await authApi.loginWithCode(email, verificationCode);
       localStorage.setItem('accessToken', result.accessToken);
       localStorage.setItem('isLoggedIn', 'true');
       localStorage.setItem('userName', result.user.display_name || result.user.email);
       localStorage.setItem('userData', JSON.stringify(result.user));
       onClose();
       toast.success('登录成功');
     } catch (error) {
       if (error instanceof ApiError) {
         if (error.code === 'INVALID_VERIFICATION_CODE') {
           toast.error('验证码错误或已过期，请重新获取');
         } else {
           toast.error(error.message);
         }
       }
     } finally {
       setIsLoading(false);
     }
   };
   ```

### 14.2 后端实现

**auth_service.py 扩展**：

```python
def send_verification_code_for_login(self, db: Session, email: str) -> str:
    """
    发送登录验证码
    
    Args:
        db: 数据库会话
        email: 用户邮箱
    
    Returns:
        str: 验证码（6位数字）
    
    Raises:
        ValueError: 邮箱未注册或账号已禁用
    """
    # 1. 查询用户
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise ValueError("邮箱未注册")
    
    if user.status != "active":
        raise ValueError("账号已被禁用")
    
    # 2. 检查发送频率（60秒内只能发送一次）
    recent_code = db.query(AuthToken).filter(
        AuthToken.user_id == user.id,
        AuthToken.type == "email_otp",
        AuthToken.created_at > datetime.utcnow() - timedelta(seconds=60)
    ).first()
    if recent_code:
        raise ValueError("发送过于频繁，请稍后再试")
    
    # 3. 生成验证码
    import secrets
    code = f"{secrets.randbelow(1000000):06d}"
    
    # 4. 保存验证码到数据库
    expire = datetime.utcnow() + timedelta(minutes=10)
    auth_token = AuthToken(
        user_id=user.id,  # 登录时已有 user_id
        type="email_otp",
        token=code,
        expired_at=expire,
        consumed=False,
    )
    db.add(auth_token)
    db.commit()
    
    # 5. 发送邮件
    from ..services.email_service import EmailService
    email_service = EmailService()
    success = email_service.send_verification_code(email, code, type="login")
    if not success:
        raise ValueError("邮件发送失败，请稍后再试")
    
    return code

def login_with_code(self, db: Session, email: str, code: str) -> Dict[str, Any]:
    """
    使用验证码登录
    
    Args:
        db: 数据库会话
        email: 用户邮箱
        code: 验证码（6位数字）
    
    Returns:
        Dict[str, Any]: 包含 accessToken 和 user 信息
    
    Raises:
        ValueError: 验证码错误、已过期或邮箱不匹配
    """
    # 1. 查询用户
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise ValueError("邮箱未注册")
    
    if user.status != "active":
        raise ValueError("账号已被禁用")
    
    # 2. 查询验证码（通过 user_id 查询，确保验证码属于该用户）
    auth_token = db.query(AuthToken).filter(
        AuthToken.user_id == user.id,
        AuthToken.type == "email_otp",
        AuthToken.token == code,
        AuthToken.consumed == False,
        AuthToken.expired_at > datetime.utcnow()
    ).first()
    
    if not auth_token:
        raise ValueError("验证码错误或已过期")
    
    # 3. 标记验证码为已消费
    auth_token.consumed = True
    db.commit()
    
    # 4. 生成 JWT Token
    token = self.create_token(user.id, token_type="session", role=user.role)
    
    # 5. 保存 Token 到数据库
    expire = datetime.utcnow() + timedelta(minutes=self.settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    session_token = AuthToken(
        user_id=user.id,
        type="session",
        token=token,
        expired_at=expire,
        consumed=False,
    )
    db.add(session_token)
    db.commit()
    
    return {
        "accessToken": token,
        "user": {
            "id": user.id,
            "email": user.email,
            "display_name": user.display_name,
            "avatar_url": user.avatar_url,
            "role": user.role,
        },
    }
```

**auth.py 路由扩展**：

```python
class LoginWithCodeRequest(BaseModel):
    email: EmailStr
    verification_code: str

@router.post("/login-with-code")
async def login_with_code(request: LoginWithCodeRequest, db: Session = Depends(get_db)):
    """用户登录（邮箱+验证码）"""
    try:
        result = auth_service.login_with_code(db, request.email, request.verification_code)
        return {"code": 0, "message": "登录成功", "data": result}
    except ValueError as e:
        error_msg = str(e)
        if "验证码错误" in error_msg or "已过期" in error_msg:
            raise HTTPException(status_code=400, detail={"code": "INVALID_VERIFICATION_CODE", "message": error_msg})
        elif "邮箱未注册" in error_msg:
            raise HTTPException(status_code=400, detail={"code": "EMAIL_NOT_REGISTERED", "message": error_msg})
        elif "已被禁用" in error_msg:
            raise HTTPException(status_code=403, detail={"code": "ACCOUNT_DISABLED", "message": error_msg})
        else:
            raise HTTPException(status_code=400, detail=error_msg)
```

**send_verification_code 接口扩展**：

```python
class SendCodeRequest(BaseModel):
    email: EmailStr
    type: str  # "register" 或 "login"

@router.post("/send-verification-code")
async def send_verification_code(request: SendCodeRequest, db: Session = Depends(get_db)):
    """发送验证码"""
    try:
        if request.type == "register":
            # 注册验证码逻辑（已有）
            code = auth_service.send_verification_code_for_register(db, request.email)
        elif request.type == "login":
            # 登录验证码逻辑（新增）
            code = auth_service.send_verification_code_for_login(db, request.email)
        else:
            raise HTTPException(status_code=400, detail="type 必须是 register 或 login")
        
        return {"code": 0, "message": "验证码已发送", "data": {"expiresIn": 600}}
    except ValueError as e:
        error_msg = str(e)
        if "已注册" in error_msg:
            raise HTTPException(status_code=400, detail={"code": "EMAIL_ALREADY_REGISTERED", "message": error_msg})
        elif "未注册" in error_msg:
            raise HTTPException(status_code=400, detail={"code": "EMAIL_NOT_REGISTERED", "message": error_msg})
        elif "过于频繁" in error_msg:
            raise HTTPException(status_code=429, detail={"code": "SEND_CODE_TOO_FREQUENT", "message": error_msg})
        elif "发送失败" in error_msg:
            raise HTTPException(status_code=500, detail={"code": "EMAIL_SEND_FAILED", "message": error_msg})
        else:
            raise HTTPException(status_code=400, detail=error_msg)
```

## 十五、后端管理员变更订阅计划详细实现方案

### 15.1 接口设计

**接口**：`PUT /api/admin/subscriptions/users/{subscriptionId}`

**请求体**：
```json
{
  "plan_id": 2,                    // 新的订阅计划 ID（必填）
  "status": "active",              // 订阅状态（可选，默认保持原状态）
  "end_at": "2025-12-31T23:59:59Z", // 到期时间（可选，不传则按新计划周期计算）
  "auto_renew": true,              // 自动续费（可选）
  "reason": "测试补偿"              // 变更原因（可选，用于审计日志）
}
```

**响应**：
```json
{
  "code": 0,
  "message": "订阅已更新",
  "data": {
    "subscription": {
      "id": 123,
      "user_id": 456,
      "plan_id": 2,
      "plan_name": "高级版",
      "status": "active",
      "start_at": "2025-01-01T00:00:00Z",
      "end_at": "2025-12-31T23:59:59Z",
      "auto_renew": true,
      "updated_at": "2025-01-15T10:30:00Z"
    }
  }
}
```

**错误码**：
- `SUBSCRIPTION_NOT_FOUND`：订阅不存在
- `PLAN_NOT_FOUND`：目标订阅计划不存在
- `PLAN_NOT_ACTIVE`：目标订阅计划已禁用
- `INVALID_STATUS`：订阅状态无效

### 15.2 后端实现

**admin.py 路由**：

```python
from pydantic import BaseModel
from typing import Optional
from datetime import datetime, timedelta
from dateutil import parser

class UpdateSubscriptionRequest(BaseModel):
    plan_id: int
    status: Optional[str] = None
    end_at: Optional[str] = None  # ISO 格式时间字符串
    auto_renew: Optional[bool] = None
    reason: Optional[str] = None

@router.put("/subscriptions/users/{subscriptionId}")
async def update_user_subscription(
    subscriptionId: int,
    request: UpdateSubscriptionRequest,
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db),
):
    """管理员变更用户订阅计划"""
    current_user = await get_current_user(credentials=credentials, db=db, require_admin=True)
    
    # 1. 查询订阅记录
    subscription = db.query(Subscription).filter(Subscription.id == subscriptionId).first()
    if not subscription:
        raise HTTPException(
            status_code=404,
            detail={"code": "SUBSCRIPTION_NOT_FOUND", "message": "订阅不存在"}
        )
    
    # 2. 查询目标订阅计划
    target_plan = db.query(SubscriptionPlan).filter(SubscriptionPlan.id == request.plan_id).first()
    if not target_plan:
        raise HTTPException(
            status_code=404,
            detail={"code": "PLAN_NOT_FOUND", "message": "订阅计划不存在"}
        )
    
    if not target_plan.is_active:
        raise HTTPException(
            status_code=400,
            detail={"code": "PLAN_NOT_ACTIVE", "message": "目标订阅计划已禁用"}
        )
    
    # 3. 保存变更前的状态（用于审计日志）
    before_state = {
        "plan_id": subscription.plan_id,
        "status": subscription.status,
        "end_at": subscription.end_at.isoformat() if subscription.end_at else None,
        "auto_renew": subscription.extra_data.get("auto_renew") if subscription.extra_data else None,
    }
    
    # 4. 更新订阅记录
    subscription.plan_id = request.plan_id
    
    if request.status:
        if request.status not in ["active", "paused", "canceled", "expired"]:
            raise HTTPException(
                status_code=400,
                detail={"code": "INVALID_STATUS", "message": "订阅状态无效"}
            )
        subscription.status = request.status
    
    if request.end_at:
        subscription.end_at = parser.isoparse(request.end_at)
    elif not subscription.end_at:
        # 如果未提供 end_at 且原订阅也没有，按新计划的周期计算
        if target_plan.period == "monthly":
            subscription.end_at = datetime.utcnow() + timedelta(days=30)
        elif target_plan.period == "yearly":
            subscription.end_at = datetime.utcnow() + timedelta(days=365)
        else:
            subscription.end_at = datetime.utcnow() + timedelta(days=30)  # 默认30天
    
    if request.auto_renew is not None:
        if not subscription.extra_data:
            subscription.extra_data = {}
        subscription.extra_data["auto_renew"] = request.auto_renew
    
    # 5. 记录变更原因和操作人（存储在 extra_data 中）
    if request.reason:
        if not subscription.extra_data:
            subscription.extra_data = {}
        subscription.extra_data["change_reason"] = request.reason
        subscription.extra_data["changed_by"] = current_user.id
        subscription.extra_data["changed_at"] = datetime.utcnow().isoformat()
    
    subscription.updated_at = datetime.utcnow()
    
    # 6. 保存变更后的状态（用于审计日志）
    after_state = {
        "plan_id": subscription.plan_id,
        "status": subscription.status,
        "end_at": subscription.end_at.isoformat() if subscription.end_at else None,
        "auto_renew": subscription.extra_data.get("auto_renew") if subscription.extra_data else None,
    }
    
    # 7. 记录审计日志（如果存在 audit_logs 表，可选实现）
    # from ..models import AuditLog
    # audit_log = AuditLog(
    #     admin_id=current_user.id,
    #     action="change_subscription",
    #     target_type="subscription",
    #     target_id=subscriptionId,
    #     before=before_state,
    #     after=after_state,
    #     ip=request.client.host if hasattr(request, 'client') else None,
    #     user_agent=request.headers.get("user-agent"),
    # )
    # db.add(audit_log)
    
    db.commit()
    db.refresh(subscription)
    
    return {
        "code": 0,
        "message": "订阅已更新",
        "data": {
            "subscription": {
                "id": subscription.id,
                "user_id": subscription.user_id,
                "plan_id": subscription.plan_id,
                "plan_name": target_plan.name,
                "status": subscription.status,
                "start_at": subscription.start_at.isoformat(),
                "end_at": subscription.end_at.isoformat() if subscription.end_at else None,
                "auto_renew": subscription.extra_data.get("auto_renew") if subscription.extra_data else False,
                "updated_at": subscription.updated_at.isoformat(),
            }
        }
    }
```

### 15.3 前端实现（Admin 后台）

**SubscriptionUsersList.tsx 或 UsersManagement.tsx**：

```typescript
// 变更订阅计划
const handleChangeSubscription = async (
  subscriptionId: number, 
  newPlanId: number, 
  reason?: string
) => {
  try {
    await adminApi.updateUserSubscription(subscriptionId, {
      plan_id: newPlanId,
      reason: reason || '管理员手动变更'
    });
    toast.success('订阅计划已更新');
    // 刷新列表
    refetch();
  } catch (error) {
    if (error instanceof ApiError) {
      toast.error(error.message);
    }
  }
};
```

**API 客户端扩展（src/lib/api.ts）**：

```typescript
export const adminApi = {
  // ... 其他接口 ...
  
  updateUserSubscription: async (
    subscriptionId: number,
    data: {
      plan_id: number;
      status?: string;
      end_at?: string;
      auto_renew?: boolean;
      reason?: string;
    }
  ): Promise<{ subscription: any }> => {
    return request(`/api/admin/subscriptions/users/${subscriptionId}`, {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  },
};
```

### 15.4 使用场景示例

1. **测试场景**：
   - 给测试账号分配高级套餐，验证功能是否正常
   - 变更后立即生效，用量检查使用新计划限制

2. **补偿场景**：
   - 用户投诉后，管理员手动升级到高级套餐作为补偿
   - 记录变更原因："用户投诉补偿"

3. **促销场景**：
   - 活动期间临时升级用户套餐
   - 活动结束后可以降级回原套餐

4. **调试场景**：
   - 验证不同套餐的用量限制逻辑
   - 测试订阅到期、自动续费等流程

### 15.5 注意事项

1. **立即生效**：变更订阅计划后，用户立即享受新计划的限制（用量检查会使用新计划）
2. **限制变更**：如果新计划的限制更严格，用户可能立即无法使用某些功能（需要前端提示）
3. **审计记录**：建议在变更时记录原因，便于后续审计和追溯
4. **权限控制**：只有管理员可以调用此接口，普通用户无法修改自己的订阅计划

## 十三、总结

本设计方案完整覆盖了注册、登录、权限控制、订阅体系集成的所有细节，确保：

1. ✅ **交互逻辑保持不变**：滚动触发注册、顶部登录按钮、登录/注册切换
2. ✅ **强制登录检查**：所有分析功能必须登录后才能使用
3. ✅ **邮箱验证码优先**：注册、普通用户登录和管理员登录均支持邮箱验证码
4. ✅ **权限区分明确**：普通用户和管理员账号完全隔离
5. ✅ **订阅体系集成**：新用户自动创建免费版订阅，用量检查严格限流
6. ✅ **管理员订阅管理**：支持后端管理员随机变更用户订阅计划，用于测试、补偿、促销等场景

### 13.1 核心功能清单

**认证功能**：
- ✅ 邮箱注册（验证码+密码）
- ✅ 邮箱+密码登录
- ✅ 邮箱+验证码登录（普通用户）
- ✅ 管理员两步验证登录（密码+验证码）
- ✅ JWT Token 认证与权限控制

**订阅管理功能**：
- ✅ 新用户自动创建免费版订阅
- ✅ 用量检查（分析次数/生成次数）
- ✅ 管理员变更订阅计划（随机变更）

**安全功能**：
- ✅ 验证码防刷机制（60秒限制）
- ✅ 验证码有效期控制（10分钟）
- ✅ 密码强度验证
- ✅ 账号状态检查
- ✅ 管理员账号锁定（连续失败5次锁定15分钟）

### 13.2 实现检查清单

**已完成设计**：
- ✅ 所有接口设计（注册、登录、验证码、订阅管理）
- ✅ 前端 UI 交互逻辑
- ✅ 后端服务实现方案
- ✅ 数据库模型补充
- ✅ 错误码表
- ✅ 安全增强措施

**待实现**：
- ⏳ 后端代码实现（按照设计方案逐步实现）
- ⏳ 前端代码实现（按照设计方案逐步实现）
- ⏳ 集成测试
- ⏳ 安全测试

**下一步**：请确认设计方案，确认后开始实现。