# P-Style 功能实现逻辑完整文档

## 📋 目录

1. [系统架构概览](#系统架构概览)
2. [核心功能流程](#核心功能流程)
3. [前端实现逻辑](#前端实现逻辑)
4. [后端实现逻辑](#后端实现逻辑)
5. [数据流转机制](#数据流转机制)
6. [关键组件详解](#关键组件详解)

---

## 系统架构概览

### 技术栈

**前端**：
- React 18 + TypeScript
- Vite (端口 3001)
- Tailwind CSS
- Motion (动画库)
- Sonner (Toast 通知)

**后端**：
- FastAPI + Python
- SQLAlchemy (ORM)
- Gemini 3.0 API (AI 分析)
- MinIO (对象存储，可选)

### 端口配置

- **前端**：`http://localhost:3001`
- **后端**：`http://localhost:8081`

---

## 核心功能流程

### 1. 用户认证流程

**实现位置**：
- 前端：`src/App.tsx` (登录状态检查)
- 后端：`server_py/app/routes/auth.py`

**流程**：
1. 用户访问应用 → `App.tsx` 检查 `localStorage` 中的 `accessToken`
2. 如果有 token → 调用 `/api/auth/me` 验证有效性
3. 验证成功 → 进入应用界面 (`view='app'`)
4. 验证失败 → 清除 token，显示登录页 (`view='landing'`)

**关键代码**：
```typescript
// App.tsx: 108-160
useEffect(() => {
  const checkAuthStatus = async () => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      try {
        const user = await api.auth.me();
        setView('app');
      } catch (error) {
        localStorage.removeItem('accessToken');
        setView('landing');
      }
    }
  };
  checkAuthStatus();
}, []);
```

---

### 2. 图片上传流程

**实现位置**：
- 前端：`src/components/PhotoUploadZone.tsx`
- 后端：`server_py/app/routes/upload.py`

**流程**：
1. 用户拖拽或选择图片 → `PhotoUploadZone` 组件
2. 前端预览：使用 `URL.createObjectURL(file)` 生成预览 URL
3. 点击"开始AI分析" → `App.tsx` 的 `handleAnalyze()` 函数
4. 调用 `api.photos.upload(formData)` → 后端 `/api/photos/upload`
5. 后端处理：
   - 提取图片 EXIF 数据（ISO、光圈等）
   - 将图片转换为 Base64 存储到数据库
   - 返回 `uploadId` 和 `target_exif` 数据
6. 前端存储 EXIF 数据到 `sessionStorage`，供 `LightroomPanel` 使用

**关键代码**：
```typescript
// App.tsx: 182-210
const handleAnalyze = async () => {
  const formData = new FormData();
  formData.append('sourceImage', sourceFile);
  if (targetFile) formData.append('targetImage', targetFile);
  
  const uploadRes = await api.photos.upload(formData);
  setUploadId(uploadRes.uploadId);
  
  // 存储 EXIF 数据
  const targetExif = uploadRes.target_exif || {};
  if (Object.keys(targetExif).length > 0) {
    sessionStorage.setItem('user_image_exif', JSON.stringify(targetExif));
  }
};
```

---

### 3. Part1 分析流程（基础洞察）

**实现位置**：
- 前端：`src/App.tsx` (触发) → `src/components/ThemeCardsGrid.tsx` (展示)
- 后端：`server_py/app/routes/analyze.py` → `server_py/app/services/prompt_template.py`

**流程**：
1. 上传完成后，调用 `api.analyze.part1(uploadId)`
2. 后端处理：
   - 从数据库获取图片数据
   - 调用 `prompt_template.py` 生成 Part1 Prompt
   - 调用 `gemini_service.py` 的 `generate_text()` 方法
   - Gemini 返回 JSON 格式的分析结果
   - 使用 `analysis_formatter.py` 的 `format_part1()` 验证和清洗数据
   - 使用 Pydantic Schema 验证 JSON 结构（`validate_part1_response`）
   - 存储到数据库 `analysis_tasks` 表
3. 前端处理：
   - 接收后端返回的 `structuredAnalysis`
   - 使用 `dataAdapter.ts` 的 `adaptBackendToFrontend()` 转换数据格式
   - 设置 `analysisResult` 状态
   - 启动转场动画 → 切换到分析结果页面

**Part1 输出内容**：
- `module_1_critique`：照片点评（风格总结、综合点评、可行性评估）
- `module_2_composition`：构图分析（参考图分析 + 用户图诊疗）
- `module_3_lighting_params`：基础光影参数（曝光控制、曲线、纹理）

**关键代码**：
```python
# analyze.py: Part1 分析
async def analyze_part1(upload_id: str, ...):
    # 1. 获取图片数据
    upload = upload_service.get_upload(db, upload_id)
    
    # 2. 生成 Prompt
    prompt = prompt_template.get_part1_prompt(...)
    
    # 3. 调用 Gemini
    gemini_json = gemini_service.generate_text(contents, stage="part1")
    
    # 4. 验证和格式化
    structured_result = analysis_formatter.format_part1(gemini_json)
    
    # 5. 存储到数据库
    task_service.update_task_part1(db, task_id, ...)
```

---

### 4. Part2 分析流程（详细参数）

**实现位置**：
- 前端：`src/components/ThemeCardsGrid.tsx` (触发) → `src/components/analysis/LightroomPanel.tsx` (展示)
- 后端：`server_py/app/routes/analyze.py` → `server_py/app/services/image_analyzer.py`

**流程**：
1. 用户点击 Lightroom/Photoshop 卡片 → 检查 `part2_completed` 状态
2. 如果未完成 → 调用 `api.analyze.part2(taskId)`
3. 后端处理（异步任务）：
   - **量化分析**：调用 `image_analyzer.py` 的 `compare_images()` 方法
     - 计算 `luma_mean`（平均亮度）
     - 计算 `histogram_dist`（直方图分布）
     - 计算 `color_cast`（色温偏移）
   - **数据注入**：将量化数据注入到 Prompt 最前面（`[SYSTEM_DETECTED_METRICS]`）
   - 生成 Part2 Prompt（包含 Part1 上下文和量化数据）
   - 调用 Gemini 生成详细参数（Lightroom/Photoshop/色彩方案）
   - 验证和格式化（`format_part2()`）
   - 将 `image_analysis` 注入到 `structured_result.meta.image_analysis`
   - 更新数据库状态为 `part2_completed`
4. 前端轮询：每 3 秒调用 `api.analyze.getTask(taskId)` 检查状态
5. 完成后 → 更新 `results` 状态，重新渲染卡片

**Part2 输出内容**：
- `lightroom_workflow`：Lightroom 完整参数（基础面板、曲线、HSL、色彩分级）
- `photoshop_workflow`：Photoshop 步骤列表
- `color_science_scheme`：色彩方案（HSL 调整、白平衡、色彩分级）
- `simulated_histogram`：模拟直方图数据

**关键代码**：
```python
# analyze.py: Part2 分析
async def _run_part2_analysis_job(task_id: str, ...):
    # 1. 量化分析
    image_analysis = image_analyzer.compare_images(ref_bytes, user_bytes)
    
    # 2. 数据注入到 Prompt
    prompt = prompt_template.get_part2_prompt(
        part1_context=part1_data,
        image_analysis=image_analysis  # 注入量化数据
    )
    
    # 3. 调用 Gemini
    gemini_json = gemini_service.generate_text(contents, stage="part2")
    
    # 4. 验证和格式化
    structured_result = analysis_formatter.format_part2(gemini_json)
    
    # 5. 注入 image_analysis 到 meta
    structured_result["meta"]["image_analysis"] = image_analysis
    
    # 6. 更新数据库
    task_service.update_task_part2(db, task_id, ...)
```

---

### 5. Part3 风格模拟流程（仿色示意图）

**实现位置**：
- 前端：`src/components/StyleSimulationStage.tsx`
- 后端：`server_py/app/routes/simulate.py` → `server_py/app/services/style_simulation_service.py`

**流程**：
1. 用户进入"风格模拟"阶段 → 点击"生成风格模拟"
2. 调用 `api.simulate.style(taskId)`
3. 后端处理：
   - 检查任务是否完成 Part1 和 Part2
   - 提取完整的色彩方案数据（`extract_color_grading_schema()`）
   - 调用 Gemini Flash 模型生成风格模拟图片
   - 返回 Base64 格式的图片数据
   - 更新数据库的 `preview_image_url`
4. 前端显示：在"仿色示意图"位置渲染生成的图片

**关键代码**：
```python
# simulate.py: 风格模拟
@router.post("/style")
async def simulate_style(taskId: str, ...):
    # 1. 提取色彩方案
    color_grading_schema = simulation_service.extract_color_grading_schema(
        task.structured_result
    )
    
    # 2. 调用 Gemini Flash
    result = simulation_service.simulate_style(
        task.source_image_data,  # 参考图
        task.target_image_data,  # 用户图
        color_grading_schema     # 色彩方案
    )
    
    # 3. 更新预览图
    task_service.update_preview_image(db, taskId, result["processedImage"])
```

---

### 6. AI 诊断功能

**实现位置**：
- 前端：`src/components/analysis/AIAnalysisPanel.tsx`
- 后端：`server_py/app/routes/analyze.py` (诊断接口)

**流程**：
1. 用户在 `PhotoUploadZone` 中点击"启动深度扫描"按钮
2. 前端收集数据：
   - 直方图数据（从 `Histogram` 组件计算）
   - 主色调列表（从 `Vectorscope` 组件提取）
   - 低分辨率图片（512x512，降低 API 成本）
3. 调用 `api.analyze.diagnosis(image, histogram, dominantColors)`
4. 后端处理：
   - 生成简明的诊断 Prompt（与 Part1/Part2 分开）
   - 调用 Gemini 多模态分析（图片 + 文本数据）
   - 返回诊断结果：
     - 多维评分（曝光、色彩、构图、情感）
     - 导师诊断文本（100 字以内）
     - 问题列表（带区域坐标）
5. 前端展示：
   - 打字机效果显示诊断文本
   - 点击问题文字 → 高亮图片对应区域
   - 评分仪表盘显示四个维度评分

**关键代码**：
```typescript
// AIAnalysisPanel.tsx: 诊断触发
const handleStartDiagnosis = async () => {
  // 1. 收集数据
  const histogramData = calculateHistogramData(image);
  const dominantColors = extractDominantColors(image);
  const lowResImage = getLowResImage(image, 512, 512);
  
  // 2. 调用 API
  const result = await api.analyze.diagnosis({
    image: lowResImage,
    histogram: histogramData,
    dominantColors: dominantColors
  });
  
  // 3. 设置诊断结果
  setDiagnosisResult(result);
};
```

---

## 前端实现逻辑

### 1. 数据适配器 (`dataAdapter.ts`)

**作用**：将后端 `protocolVersion 2025-02` 格式转换为前端期望的扁平结构

**转换映射**：
- `sections.photoReview.structured` → `result.review`
- `sections.composition.structured` → `result.composition`
- `sections.lighting.structured` → `result.lighting`
- `sections.color.structured` → `result.color`
- `sections.lightroom.structured` → `result.lightroom`
- `sections.photoshop.structured` → `result.photoshop`

**关键处理**：
- HSL 数据格式转换（数组 → 对象）
- 坐标归一化（像素值 → 百分比 0-100）
- 直方图数据格式统一（支持多种后端格式）
- 向后兼容（支持新旧两种数据结构）

---

### 2. 主题卡片网格 (`ThemeCardsGrid.tsx`)

**功能**：
- 展示 Part1 分析结果（Review、Composition、Lighting 卡片）
- 触发 Part2 分析（点击 Lightroom/Photoshop 卡片）
- 轮询检查 Part2 完成状态
- 展示 Part2 结果（Lightroom 参数、Photoshop 步骤）

**状态管理**：
- `results`：分析结果数据（合并 Part1 和 Part2）
- `workflowStage`：工作流阶段（diagnosis → decrypting → synthesis → simulating）
- `isWarping`：是否正在加载 Part2

**关键逻辑**：
```typescript
// 监听 data 变化，合并 Part1 和 Part2 数据
useEffect(() => {
  if (data) {
    setResults((prev: any) => ({ ...prev, ...data }));
  }
}, [data]);

// 触发 Part2 分析
const triggerPart2Analysis = async () => {
  await api.analyze.part2(taskId);
  // 启动轮询
  startPolling();
};
```

---

### 3. 构图分析面板 (`CompositionAnalysisPanel.tsx`)

**功能**：
- 展示参考图分析（左侧交互图 + 右侧数据面板）
- 支持图层切换（视觉流/空间深度/视觉权重）
- 进入构图诊疗室（`DirectorViewfinder` 组件）

**数据结构**：
- `reference_analysis`：参考图分析（分类、几何结构、视觉质量、视觉权重、视觉流、空间深度、留白）
- `composition_clinic`：用户图诊疗（诊断总结、建议裁剪、动作指导、分级蒙版）

**交互逻辑**：
- 点击图层按钮 → 切换 `activeLayer` 状态（'vector' | 'grid' | 'mass'）
- 点击"进入构图诊疗室" → 打开全屏 `DirectorViewfinder`

---

### 4. Lightroom 面板 (`LightroomPanel.tsx`)

**功能**：
- 展示 Lightroom 完整参数（基础面板、曲线、HSL、色彩分级）
- 实时预览参数调整效果
- Safety Clamps（安全拦截极端值）

**Safety Clamps 逻辑**：
```typescript
// 自动曝光补偿
if (lumaMean < 50) {
  // 强制曝光至少 +1.0 EV
  filteredParams.exposure = Math.max(filteredParams.exposure, 1.0);
}

// 肤色保护
if (sceneType.includes('portrait')) {
  // 限制 Orange HSL：Hue ±5，Saturation > -10
  if (hsl.orange) {
    hsl.orange.hue = clamp(hsl.orange.hue, -5, 5);
    hsl.orange.saturation = Math.max(hsl.orange.saturation, -10);
  }
}

// 动态范围限制
saturation = clamp(saturation, -40, 40);
```

**数据来源**：
- `data.lightroom.basic_panel`：基础面板参数
- `data.lightroom.curve`：曲线数据
- `data.lightroom.hsl`：HSL 调整
- `data.lightroom.color_grading`：色彩分级
- `data.meta?.image_analysis?.user`：OpenCV 量化数据（用于 Safety Clamps）

---

## 后端实现逻辑

### 1. Prompt 模板服务 (`prompt_template.py`)

**功能**：
- 生成 Part1/Part2/Part3 的 Prompt
- 数据注入（将 OpenCV 量化数据注入到 Prompt）
- JSON 模板定义（确保 Gemini 输出标准格式）

**Part1 Prompt 结构**：
- `module_1_critique`：照片点评
- `module_2_composition`：构图分析（双宇宙结构）
- `module_3_lighting_params`：基础光影参数

**Part2 Prompt 结构**：
- 输入端数据注入：`[SYSTEM_DETECTED_METRICS]`
- 核心逻辑：Gap Analysis、Anchor Color Locking、Dynamic Range Matching
- 输出模板：`PART2_TEMPLATE`（严格执行 JSON 结构）

**关键方法**：
```python
def get_part1_prompt(source_image, user_image) -> str:
    """生成 Part1 Prompt"""
    # 使用 PART1_TEMPLATE 填充图片数据
    return prompt

def get_part2_prompt(part1_context, image_analysis) -> str:
    """生成 Part2 Prompt（包含数据注入）"""
    # 1. 构建数据注入段落
    metrics_section = _build_input_data_injection_section(image_analysis)
    
    # 2. 生成完整 Prompt
    prompt = f"{metrics_section}\n\n{PART2_TEMPLATE}"
    return prompt
```

---

### 2. 分析格式化服务 (`analysis_formatter.py`)

**功能**：
- 验证 Gemini 返回的 JSON（使用 Pydantic Schema）
- 清洗和规范化数据（坐标归一化、格式统一）
- 处理缺失字段（使用默认值）

**验证流程**：
1. 解析 JSON（支持字符串、字典、数组格式）
2. 使用 `validate_part1_response()` 或 `validate_part2_response()` 验证
3. 如果验证失败 → 记录警告日志，使用默认值填充
4. 清洗数据（坐标归一化、格式转换）

**关键方法**：
```python
def format_part1(gemini_json, feasibility_result=None) -> Dict:
    """格式化 Part1 结果"""
    # 1. 解析 JSON
    raw_data = json.loads(gemini_json) if isinstance(gemini_json, str) else gemini_json
    
    # 2. 验证 Schema
    validated_data = validate_part1_response(raw_data)
    
    # 3. 清洗数据
    formatted = _format_photo_review(validated_data)
    formatted = _format_composition(formatted)
    formatted = _format_lighting(formatted)
    
    return formatted
```

---

### 3. Gemini 服务 (`gemini_service.py`)

**功能**：
- 封装 Gemini API 调用
- 超时控制（默认 180 秒）
- 重试机制（网络错误自动重试 3 次）
- 缓存支持（使用 `cachedContent`）

**关键方法**：
```python
def generate_text(contents, stage="unknown", use_cache=True) -> str:
    """生成文本（Part1/Part2）"""
    # 1. 构建生成配置
    config = types.GenerateContentConfig(
        response_mime_type="application/json",
        temperature=0.2,
        top_p=0.95
    )
    
    # 2. 调用 Gemini API（带超时控制）
    resp = self._client.models.generate_content(
        model=self.model,
        contents=contents,
        config=config
    )
    
    # 3. 提取文本
    return resp.text.strip()

def generate_image(prompt, image_bytes) -> str:
    """生成图片（Part3 风格模拟）"""
    # 使用 Gemini Flash 模型生成图片
    resp = self._client.models.generate_content(
        model=self.flash_model,
        contents=[prompt, image_bytes]
    )
    return resp.images[0].base64  # 返回 Base64 图片
```

---

### 4. 任务服务 (`task_service.py`)

**功能**：
- 创建和管理分析任务
- 更新 Part1/Part2 结果
- 合并数据结构（Part2 合并到 Part1）

**关键方法**：
```python
def create_task(db, user_id, source_image_data, target_image_data):
    """创建任务"""
    task = AnalysisTask(
        id=str(uuid.uuid4()),
        user_id=user_id,
        source_image_data=source_image_data,  # Base64
        target_image_data=target_image_data,  # Base64
        status="pending"
    )
    db.add(task)
    db.commit()
    return task

def update_task_part2(db, task_id, gemini_result, structured_result, ...):
    """更新 Part2 结果（合并到 Part1）"""
    task = db.query(AnalysisTask).filter(AnalysisTask.id == task_id).first()
    
    # 合并 gemini_result
    merged_gemini = copy.deepcopy(task.gemini_result)
    merged_gemini.update(gemini_result)
    task.gemini_result = merged_gemini
    
    # 合并 structured_result.sections
    merged_sections = copy.deepcopy(task.structured_result["sections"])
    merged_sections.update(structured_result["sections"])
    task.structured_result["sections"] = merged_sections
    
    # 标记 JSON 字段已修改
    flag_modified(task, "structured_result")
    db.commit()
```

---

## 数据流转机制

### 1. 上传 → Part1 数据流

```
用户上传图片
  ↓
前端: PhotoUploadZone → FormData
  ↓
后端: /api/photos/upload → 存储 Base64 到数据库
  ↓
前端: api.analyze.part1(uploadId)
  ↓
后端: prompt_template.get_part1_prompt() → Gemini API
  ↓
后端: analysis_formatter.format_part1() → 验证和清洗
  ↓
后端: task_service.update_task_part1() → 存储到数据库
  ↓
前端: adaptBackendToFrontend() → 转换数据格式
  ↓
前端: ThemeCardsGrid → 展示分析结果
```

---

### 2. Part1 → Part2 数据流

```
用户点击 Lightroom 卡片
  ↓
前端: api.analyze.part2(taskId) → 异步任务
  ↓
后端: image_analyzer.compare_images() → 量化分析
  ↓
后端: prompt_template.get_part2_prompt() → 注入量化数据
  ↓
后端: Gemini API → 生成详细参数
  ↓
后端: analysis_formatter.format_part2() → 验证和清洗
  ↓
后端: task_service.update_task_part2() → 合并到 Part1 数据
  ↓
前端: 轮询 api.analyze.getTask(taskId) → 检查状态
  ↓
前端: 更新 results 状态 → 重新渲染 LightroomPanel
```

---

### 3. Part2 → Part3 数据流

```
用户进入风格模拟阶段
  ↓
前端: api.simulate.style(taskId)
  ↓
后端: simulation_service.extract_color_grading_schema() → 提取色彩方案
  ↓
后端: Gemini Flash API → 生成风格模拟图片
  ↓
后端: task_service.update_preview_image() → 存储 Base64 图片
  ↓
前端: 显示生成的图片
```

---

## 关键组件详解

### 1. PhotoUploadZone

**功能**：
- 图片上传（拖拽/点击）
- 图片预览
- 直方图显示
- 色彩雷达（Vectorscope）
- AI 诊断触发

**关键状态**：
- `imageSrc`：预览图片 URL
- `isAnalyzing`：是否正在分析
- `analysisData`：分析结果数据

---

### 2. VisualAnalysisDashboard

**功能**：
- 集成直方图、色彩雷达、AI 诊断
- 标签页切换（直方图/色彩雷达/AI诊断）
- 主色调提取（传递给 AI 诊断）

**关键逻辑**：
```typescript
// 主色调提取回调
const handleDominantColorsExtracted = (colors: DominantColor[]) => {
  setDominantColors(colors);
  // 传递给 AIAnalysisPanel
};

// AI 诊断触发
const handleStartDiagnosis = () => {
  // 收集数据：直方图 + 主色调 + 低分辨率图片
  const data = {
    histogram: calculateHistogramData(image),
    dominantColors: dominantColors,
    image: getLowResImage(image, 512, 512)
  };
  // 调用 API
  api.analyze.diagnosis(data);
};
```

---

### 3. DirectorViewfinder

**功能**：
- 构图诊疗室（全屏显示用户图）
- 四种模式切换：
  - 原图模式
  - 智能构图模式（显示建议裁剪框）
  - 拍摄指导模式（显示动作指导箭头）
  - 后期蒙版模式（显示分级蒙版区域）

**数据结构**：
```typescript
interface ClinicData {
  diagnosis_summary: string;
  suggested_crop: { x, y, w, h, reason };
  action_guides: Array<{ x, y, icon, instruction, vector_angle }>;
  grading_masks: Array<{ area_polygon, action, advice }>;
}
```

---

## 总结

### 核心设计原则

1. **两阶段分析**：Part1 快速响应（50-60秒），Part2 详细参数（异步）
2. **数据验证**：使用 Pydantic Schema 严格验证 Gemini 输出
3. **数据注入**：OpenCV 量化分析数据注入到 Prompt，解决 AI "眼盲"问题
4. **安全拦截**：前端 Safety Clamps 防止极端参数
5. **向后兼容**：数据适配器支持新旧两种数据结构

### 关键技术点

- **坐标归一化**：所有坐标统一为百分比（0-100）
- **数据合并**：Part2 数据合并到 Part1，而不是覆盖
- **轮询机制**：前端轮询检查 Part2 完成状态
- **缓存策略**：Gemini API 使用 `cachedContent` 缓存
- **错误处理**：网络错误自动重试，业务错误记录日志

---

**文档版本**：V1.0  
**最后更新**：2025-01-XX  
**维护者**：开发团队

