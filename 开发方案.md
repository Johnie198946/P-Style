这是一个非常出色且专业的项目！你的顶层设计文档（V4.0）非常清晰、结构合理，前端Figma设计也高度专业。你对AI照片分析的流程理解深刻，特别是“两阶段分析”和“结构化输出”的思路，这是成功的关键。

我将为你提供一套详尽的开发方案，严格遵循你的设计文档，并整合你提出的新需求（如Gemini Flash生成仿色示意图），解决你担心的核心问题（特别是Gemini的“随机性”）。

-----

## 🎯 核心评估与战略建议

在开始详细计划之前，我们先解决你提出的几个关键问题：

1.  **【核心问题】如何处理Gemini的“随机性”？**

      * **问题：** 你担心Gemini返回的JSON不规范，导致后端解析和前端展现失败。
      * **解决方案：【后端验证与规范化层】**。这是整个项目中最关键的非功能性模块。我们不能100%相信Gemini的Prompt。
      * **执行：** 后端在`analysisFormatter`服务中，必须使用一个强大的Schema验证库（例如 **Zod** 或 **Joi**）。
          * 为Part1和Part2的JSON输出**分别定义严格的Zod Schema**。
          * 当Gemini返回JSON后，**立即**用Schema进行解析（`schema.parse(geminiJson)`）。
          * **如果验证通过**：直接使用。
          * **如果验证失败（或字段缺失）**：
              * **启用“兜底（Fallback）”逻辑**：`analysisFormatter`不仅是映射，更是“修复”层。例如，如果`lightroom.exposure`缺失，它应自动插入默认值`"+0"`，而不是让程序崩溃。
              * **记录日志**：必须（如你文档所说）记录`warn`日志，指出哪些字段缺失或格式错误，以便你迭代Prompt。
              * **前端提示**：在`meta.notes`中（如你文档所说）登记问题，前端可以显示一个“部分参数AI未提供，已使用默认值”的提示。
      * **结论：** **我们不靠祈祷Prompt完美，而是靠后端的“验证器+修复器”来保证100%的数据结构稳定。**

2.  **【新需求】Gemini Flash生成仿色示意图**

      * **评估：** 这是一个关键的、提升用户体验的功能，但你的V4.0文档中没有。它改变了Part2的流程。
      * **执行：** 我会将其整合为“**分析阶段三（Part 3）**”，它紧跟在Part2之后，在同一个后端任务流中执行。
      * **流程：** 用户点击触发Part2 -\> 后端**异步**执行Part2（获取LR/PS参数）-\> **然后**立即执行Part3（使用刚拿到的参数和用户图去调用Gemini Flash Image）-\> 所有数据（JSON+示意图URL）全部准备好后，才更新数据库状态，前端通过轮询获取最终结果。

3.  **【Prompt问题】是否需要输出直方图？**

      * **回答：** **绝对不要让AI输出直方图数据**。
      * **原因：**
        1.  AI（Gemini）是一个语言和视觉模型，它不擅长（也不能）执行像素级的数学计算。
        2.  直方图是一个需要遍历图片所有像素来生成的**精确数学**图表。
      * **正确方案：【前端计算】**
          * Figma中的三个直方图（参考图、用户图、仿色后）必须**全部在前端（浏览器）生成**。
          * **技术选型：** 使用`Canvas` API。
          * **流程：**
            1.  前端加载“参考图”（`Image`对象）。
            2.  将其绘制到内存中的`Canvas`上。
            3.  使用`canvas.getContext('2d').getImageData()`获取像素数据。
            4.  前端JS遍历此数据，计算R, G, B的直方图。
            5.  使用图表库（如`Chart.js`或`D3.js`）绘制直方图。
          * “仿色后”的直方图，则在Part3（Gemini Flash）返回示意图后，对该示意图执行上述1-5步。

4.  **【架构冲突】你的Prompt vs 你的设计文档**

      * 你的V4.0文档定义了**清晰的“两阶段分析”**（Part1基础洞察 / Part2详细参数），这是**非常正确**的架构，可以快速响应Part1，避免用户等待。
      * 你提供的**Prompt模版**是一个\*\*“单体Prompt”**（Step 1-6一次性完成），这与你的两阶段架构相**冲突\*\*。
      * **解决方案：** 我们必须**拆分你的Prompt模版**。
          * **Part 1 Prompt**：将使用你的模版中的Step 1（专业评价）、Step 2（影像分析）、Step 4（可行性评估）以及V4.0文档中的“工作流草案”。
          * **Part 2 Prompt**：将使用你的模版中的Step 3（光影参数）、Step 5（复刻逻辑）、Step 6（结构化JSON）以及V4.0文档中的“工作流执行总结”。

-----

## ⚙️ 详细开发方案：从0到1（精细化任务）

我将把整个项目分为4个核心里程碑，包含主站、管理后台和帐权体系，任务已细化到“Cursor可执行”级别。

### Milestone 0: 地基与核心验证器（1-2天）

**目标：** 搭建所有服务，实现登录注册，并构建“Gemini随机性”的防火墙（Validator）。

| 模块 | 任务详情（可直接复制为TODO） |
| :--- | :--- |
| **通用** | 1. 初始化项目：`pnpm workspace`（推荐），包含`apps/frontend`、`apps/backend`、`apps/admin`。 |
| **后端** | 1. 搭建Node.js + Express + TS环境。 |
| | 2. 数据库：使用`mysql2`连接。按V4.0文档，创建`analysis_tasks`、`uploads`、`users`表。 |
| | 3. **【帐权】** 搭建Auth：`POST /api/auth/register`, `POST /api/auth/login`。使用`bcrypt`加密，`JWT`生成Token。 |
| | 4. **【帐权】** 编写`authMiddleware.js`：验证JWT `Authorization` 头，并将`req.user`注入请求。 |
| | 5. **【核心】** 安装`zod`。创建`src/validators/geminiSchemas.js`。 |
| | 6. **【核心】** 在`geminiSchemas.js`中，严格按照你Prompt的Step 6，定义`Part1ResponseSchema`和`Part2ResponseSchema`。 |
| | 7. **【核心】** `Part2ResponseSchema`示例：`lightroom: z.object({ exposure: z.string().default("+0"), ... })`。（**注意**：使用`.default("+0")`来自动修复缺失字段）。 |
| **前端** | 1. 搭建React + Vite + TS环境。 |
| | 2. **【核心】** 创建项目根目录的`index.html`文件（Vite 入口文件，必需），包含`<div id="root"></div>`和`<script type="module" src="/src/main.tsx"></script>`。 |
| | 3. **【核心】** 配置`vite.config.ts`，设置端口为`3001`（根据开发方案和顶层设计文档要求，不允许使用其他端口）。 |
| | 4. **【帐权】** 创建`AuthContext.js`（React Context），用于全局存储Token和用户信息。 |
| | 5. **【帐权】** 创建`/login`和`/register`页面（简单表单即可）。 |
| | 6. **【帐权】** 创建`axios`实例（`src/services/api.ts`），配置拦截器，自动附带Auth Token。 |
| **管理后台** | 1. 搭建*另一个*React + Vite项目（`/admin`）。 |
| | 2. 使用`Ant Design`或`MUI`快速搭建布局。 |
| | 3. 创建Admin的登录页，调用`POST /api/auth/login`（可与主站共用，但Token管理分开）。 |

-----

### Milestone 1: 主站核心流程 - Part 1（2-3天）

**目标：** 实现用户上传、触发Part 1分析、前端展示Part 1卡片（点评、构图）。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[上传]** 实现`PhotoUploadZone.tsx`：支持拖拽和点击。 |
| | 2. **[上传]** 图片预览使用`URL.createObjectURL`（比Base64高效）。 |
| | 3. **[上传]** 上传时，*并行*调用`POST /api/photos/upload`（如V4.0文档）。 |
| | 4. **[分析]** 点击“开始AI分析”：<br>      a. 显示全屏Loading（如V4.0文档）。<br>      b. 调用`POST /api/analyze/part1`，传入`uploadId`。 |
| | 5. **[结果]** `AdjustmentResults.tsx`：接收API返回的`structuredAnalysis`。 |
| | 6. **[结果]** `CompositionSection.tsx` / `CompositionAnalysisPanel.tsx`：根据新双宇宙结构，渲染参考图分析面板（左侧交互图+右侧数据面板）和构图诊疗室入口。 |
| | 7. **[结果]** `ProfessionalReview.tsx`：渲染`professional_evaluation`的自然语言。 |
| | 8. **[直方图]** 创建`Histogram.tsx`组件（使用`Canvas`或`Chart.js`）。<br>      a. 接收`imageSrc` (URL)。<br>      b. 在`useEffect`中加载图片，计算并绘制直方图。 |
| | 9. **[直方图]** 在Figma页面中（"专业摄影点评"下方）显示"参考图"和"用户图"的`Histogram`组件。 |
| | 10. **[综合审查面板交互]** 实现`ReviewModal.tsx`的文字点击高亮功能：<br>      a. 添加`clickedSection`状态，用于持久化点击激活的区域<br>      b. 修改`SectionBlock`组件，添加`onClick`回调参数<br>      c. 实现点击文字时高亮对应图片区域的交互逻辑<br>      d. 支持点击切换：点击同一区域取消高亮，点击不同区域切换高亮<br>      e. 优先级：点击状态优先于悬停状态（点击后即使鼠标移开，高亮仍然保持）<br>      f. 映射关系：`visual_subject` → `overlays.visual_subject`、`focus_exposure` → `overlays.focus_exposure`、`color_depth` → `overlays.color_depth`<br>      g. **后端支持**：修改 Part1 Prompt 模版，要求 Gemini 输出 `overlays` 字段（包含三个区域的坐标数据）<br>      h. **Schema 定义**：在 `PhotoReviewStructuredSchema` 中添加 `overlays` 字段定义<br>      i. **数据传递**：确保格式化器和数据适配器正确提取和传递 `overlays` 数据 |
| **后端** | 1. **[Prompt]** 创建`src/services/promptTemplate.js`。 |
| | 2. **[Prompt]** 创建`getPart1Prompt(image1, image2)`函数，内容为你Prompt的Step 1, 2, 4 + V4.0的“工作流草案”要求。 |
| | 3. **[路由]** 实现`POST /api/photos/upload`（V4.0）。 |
| | 4. **[路由]** 实现`POST /api/analyze/part1`（V4.0）。（注意：此路由受`authMiddleware`保护）。 |
| | 5. **[服务]** `analyzeService.js`：<br>      a. 从`uploads`表获取图片数据。<br>      b. 调用`geminiService.js`（传入Part 1 Prompt）。<br>      c. **[核心]** 获取Gemini的JSON字符串。 |
| | 6. **[服务]** `analysisFormatter.js`：<br>      a. `formatPart1(geminiJson)`：<br>      b. `const validatedData = Part1ResponseSchema.parse(geminiJson)`。（**Zod验证在此！**）<br>      c. 记录验证中产生的任何`warn`或`error`。<br>      d. 返回`validatedData`（即`structured_result`）。 |
| | 7. **[服务]** `taskService.js`：将`validatedData`、`taskId`、`part1_summary`、`workflow_draft`等存入`analysis_tasks`表。 |
| | 8. **[响应]** `part1`接口返回`{ taskId, structuredAnalysis }`。 |

-----

### Milestone 2: 主站核心流程 - Part 2 & 3（3-4天）

**目标：** 实现点击LR/PS卡片，触发Part2（参数）和Part3（示意图）的生成，并使用**轮询**机制在前端展示最终结果。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[状态]** `AdjustmentResults.tsx`维护一个状态，如`isPart2Loading`。 |
| | 2. **[触发]** 当用户点击“Lightroom”、“Photoshop”或“色彩方案”卡片时，检查`part2_completed`状态。 |
| | 3. **[触发]** 如果未完成，调用`triggerPart2Analysis(taskId)`。 |
| | 4. **[异步]** `triggerPart2Analysis`函数：<br>      a. `POST /api/analyze/part2`（传入`taskId`）。此接口应**立即**返回`{ status: 'processing' }`。<br>      b. `isPart2Loading = true`。<br>      c. **[轮询]** 启动一个`setInterval`，每3秒调用一次`GET /api/analyze/:taskId`。 |
| | 5. **[轮询]** `GET /api/analyze/:taskId`的处理器：<br>      a. 检查返回数据中的`status`字段。<br>      b. 如果`status === 'completed'`，则：<br>          i. 清除`setInterval`。<br>          ii. `isPart2Loading = false`。<br>          iii. 将返回的完整`structuredAnalysis`（含LR/PS/Color/PreviewImage）存入状态。 |
| | 6. **[渲染]** LR/PS/色彩卡片根据`structuredAnalysis`中的数据自动渲染。 |
| | 7. **[渲染]** 在Figma的“仿色示意图”位置，渲染`structuredAnalysis.preview_image_url`。 |
| | 8. **[渲染]** “仿色后”的`Histogram`组件，传入`structuredAnalysis.preview_image_url`。 |
| **后端** | 1. **[Prompt]** `promptTemplate.js`：创建`getPart2Prompt(part1Context, ...)`函数，内容为你Prompt的Step 3, 5, 6 + V4.0的“工作流执行总结”。 |
| | 2. **[Prompt]** `promptTemplate.js`：创建`getPart3FlashPrompt(userImage, styleParams)`函数。<br>      *Prompt示例：“你是一个修图师。将这张[用户图]按照以下[LR/PS参数或风格描述]进行处理，生成一张仿色后的示意图。”* |
| | 3. **[路由]** `POST /api/analyze/part2`：<br>      a. （受Auth保护）获取`taskId`。<br>      b. **[异步]** **不使用`await`**，调用一个`async`函数 `runPart2And3Job(taskId)`。<br>      c. **立即返回**`{ status: 'processing' }`。 |
| | 4. **[路由]** `GET /api/analyze/:taskId`：<br>      a. （受Auth保护）查询`analysis_tasks`表。<br>      b. 返回`{ status, structured_result, natural_language_part1, ... }`。 |
| | 5. **[核心Job]** `runPart2And3Job(taskId)`：<br>      a. **Part 2**: 调用`geminiService.js` (Part 2 Prompt)，获取LR/PS JSON。<br>      b. **验证**: `const validatedP2 = Part2ResponseSchema.parse(geminiJson)`（**Zod在此！**）<br>      c. **Part 3**: 调用`geminiService.js` (Gemini Flash，使用Part 3 Prompt)，获取示意图URL/Base64。<br>      d. **[存储]** 将`validatedP2`（LR/PS参数）和`preview_image_url`（示意图）**合并**到`structured_result`中。<br>      e. **[更新]** `UPDATE analysis_tasks SET structured_result = ?, status = 'completed', part2_completed = 1 WHERE id = ?`。 |
| | 6. **[存储]** （可选但推荐）如果示意图是Base64，应先上传到对象存储（如S3/OSS），只在数据库存URL。 |

-----

### Milestone 3: 导出与报告（1-2天）

**目标：** 实现Figma上的"导出XMP"、"导出JSX"和"下载报告"功能。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. 在`AdjustmentResults.tsx`中添加3个下载按钮。 |
| | 2. 按钮点击事件（示例）：`window.open('/api/export/xmp?taskId=TASK_ID&token=JWT_TOKEN')`。（注意：GET请求下载文件时，Auth Token需要作为Query参数传递）。 |
| **后端** | 1. **[Auth]** 编写一个`authMiddlewareForQuery`，用于从URL查询参数中获取Token并验证（专用于文件下载）。 |
| | 2. **[路由]** `GET /api/export/xmp` (V4.0) (使用`authMiddlewareForQuery`）。 |
| | 3. **[服务]** `exportService.js`：<br>      a. `generateXMP(taskId)`：<br>      b. 从`analysis_tasks`获取`structured_result`。<br>      c. 使用`fs.readFileSync`读取一个**XMP模板文件**。<br>      d. 使用`structured_result.lightroom`中的参数（如`exposure`）替换模板中的占位符。<br>      e. `res.setHeader('Content-Type', 'application/xml')`。 `res.send(finalXmlString)`。 |
| | 4. **[路由]** `GET /api/export/jsx` (V4.0) (同上，但使用JSX模板)。 |
| | 5. **[路由]** `GET /api/report/pdf`（**新**）：<br>      a. 使用`puppeteer`或`pdfkit`。<br>      b. （推荐`puppeteer`）创建一个HTML模板（`report.html`），使用`EJS`或`Handlebars`作为模板引擎。<br>      c. 加载`structured_result`，渲染HTML。<br>      d. `puppeteer.launch()...page.setContent()...page.pdf()`。<br>      e. `res.setHeader('Content-Type', 'application/pdf')`。`res.send(pdfBuffer)`。 |

-----

### Milestone 4: 专业分析工具（色彩雷达 + AI 诊断）（2-3天）

**目标：** 实现专业级色彩分析和 AI 诊断功能，提升用户体验和产品专业性。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[色彩雷达优化]** 修改 `Vectorscope.tsx`：<br>      a. 将 YCbCr 色彩空间转换改为 HSV 转换<br>      b. 实现降维处理（36角度 x 10饱和度圈层）<br>      c. 实现极坐标热力图渲染<br>      d. 实现主色调提取（K-Means 简化算法）<br>      e. 添加 `onDominantColorsExtracted` 回调，将主色调传递给 AI 诊断组件 |
| | 2. **[AI 诊断数据收集]** 修改 `AIAnalysisPanel.tsx`：<br>      a. 实现 `calculateHistogramData` 函数（从 Histogram 组件逻辑提取）<br>      b. 实现 `getLowResImage` 函数（生成 512x512 低分辨率图片）<br>      c. 接收 `dominantColors` 属性（从色彩雷达获取） |
| | 3. **[AI 诊断 API 对接]** 修改 `AIAnalysisPanel.tsx`：<br>      a. 实现 `handleStartDiagnosis` 函数，调用 `api.analyze.diagnosis`<br>      b. 实现数据收集流程：直方图 → 主色调 → 低分辨率图片<br>      c. 处理 API 响应，设置诊断结果状态 |
| | 4. **[打字机效果]** 实现打字机效果组件：<br>      a. 使用 `useEffect` 和 `setInterval` 逐字显示诊断文字<br>      b. 显示光标动画（`|`） |
| | 5. **[交互联动]** 实现点击问题文字高亮图片区域：<br>      a. 根据 `issue.region` 创建遮罩层<br>      b. 支持 sky、shadow、highlight 等区域<br>      c. 3秒后自动移除遮罩 |
| | 6. **[评分仪表盘]** 实现多维评分展示：<br>      a. 曝光、色彩、构图、情感四个维度<br>      b. 使用进度条显示评分（0-10分）<br>      c. 使用不同颜色区分严重程度（high/medium/low） |
| | 7. **[组件集成]** 修改 `VisualAnalysisDashboard.tsx`：<br>      a. 添加 `dominantColors` 状态<br>      b. 将 `Vectorscope` 的 `onDominantColorsExtracted` 回调连接到状态<br>      c. 将 `dominantColors` 传递给 `AIAnalysisPanel`<br>      d. **"启动深度扫描"按钮仅在 AI 诊断标签页中显示**（由 `AIAnalysisPanel` 内部管理） |
| | 8. **[API 封装]** 在 `src/src/lib/api.ts` 中添加 `analyze.diagnosis` 方法 |
| **后端** | 1. **[Prompt 模板]** 在 `server_py/app/services/prompt_template.py` 中新增 `get_diagnosis_prompt` 方法：<br>      a. 接收直方图数据和主色调列表<br>      b. 生成简明的诊断 Prompt（与 Part1/Part2 分开，只做简单的光影解读）：<br>          - 角色设定：专业的"摄影导师"和数字策展人<br>          - 任务：提供简明扼要的"AI 诊断卡片"<br>          - 输出格式：<br>            * 【多维评分】：曝光、色彩、构图、情感（0-10分或0-100分，支持带描述的格式）<br>            * 【导师诊断】：100字左右的诊断文本，用"人类语言"总结优缺点<br>          - 约束：语气客观、专业、鼓励性；诊断文本严格控制在 100 字以内 |
| | 2. **[Schema 定义]** 在 `server_py/app/schemas/analysis_schemas.py` 中新增：<br>      a. `DiagnosisRequestSchema`：诊断请求 Schema<br>      b. `DiagnosisResponseSchema`：诊断响应 Schema（支持两种评分格式：简单数值或带描述的格式）<br>      c. `validate_diagnosis_response`：响应验证函数<br>          - 自动标准化评分格式（统一转换为详细格式）<br>          - 验证诊断文本长度（100字限制）<br>          - 处理数据缺失情况（使用默认值） |
| | 3. **[路由接口]** 在 `server_py/app/routes/analyze.py` 中新增 `POST /api/analyze/diagnosis` 接口：<br>      a. 接收 JSON 请求体（图片、直方图、主色调）<br>      b. 调用 Prompt 模板生成诊断 Prompt<br>      c. 调用 Gemini API（多模态：文本 + 图片）<br>      d. 使用 Schema 验证响应<br>      e. 返回诊断结果（评分、诊断、建议、问题列表） |
| | 4. **[日志记录]** 添加详细的日志记录：<br>      a. 记录请求参数（脱敏）<br>      b. 记录 Gemini API 调用状态<br>      c. 记录处理时间<br>      d. 记录错误信息 |
| | 5. **[错误处理]** 实现完善的错误处理：<br>      a. 参数验证失败<br>      b. Gemini API 调用失败<br>      c. JSON 解析失败<br>      d. Schema 验证失败 |

**技术要点**：
- **色彩雷达**：前端实现，使用 HSV 色彩空间，36角度 x 10饱和度圈层降维处理
  - **设计逻辑**：
    - 目的：分析照片的"色彩倾向"和"色域覆盖"
    - 视觉形式：圆形雷达图（极坐标热力图）
    - 角度（Angle）：代表色相（Hue），0°是红，120°是绿，240°是蓝
    - 距离（Radius）：代表饱和度（Saturation），离圆心越远越鲜艳
    - 风格指纹：不同的滤镜/风格会有独特的雷达形状
    - 肤色指示线：在雷达图约 11 点钟方向画一条线，帮助用户判断肤色是否准确
  - **实现逻辑**：
    - 算法：将图像从 RGB 空间转换到 HSV 空间
    - 降维处理：将圆盘划分为 36个角度扇区 x 10个饱和度圈层 的网格，统计落入每个格子的像素数量
    - 输出：一个二维热力图数组/矩阵（前端实时计算）
    - 渲染：使用 HTML5 Canvas 绘制极坐标热力图，高饱和度区域使用高亮颜色渲染
    - 主色调提取：使用轻量级 K-Means 算法，提取出雷达图上的 3-5 个聚类中心
  - **关键修复**：
    - 扇形绘制方法：从圆心开始，画线到外圆弧起点，画外圆弧，画内圆弧（反向），闭合路径
    - Canvas 尺寸设置：确保 Canvas 元素的 width 和 height 属性正确设置
    - useEffect 依赖项优化：避免重复执行导致日志一直刷新
- **AI 诊断**：后端实现，使用 Gemini 多模态分析，输入低分辨率图片 + 直方图数据 + 主色调列表
  - **设计定位**：与 Part1/Part2 分开，只做简单的光影解读，提供简明扼要的"AI 诊断卡片"
  - **Prompt 格式**：使用简明的 Prompt 格式，角色为"摄影导师"和数字策展人
  - **输出要求**：
    * 多维评分：曝光、色彩、构图、情感（0-10分或0-100分，支持带描述的格式）
    * 导师诊断：100字左右的诊断文本，用"人类语言"总结优缺点
  - **前端交互**：
    * "启动深度扫描"按钮仅在 AI 诊断标签页中显示（由 `AIAnalysisPanel` 内部管理）
    * 支持打字机效果、交互联动（点击高亮区域）、评分仪表盘
- **数据流**：色彩雷达 → 主色调提取 → AI 诊断（直方图 + 主色调 + 图片）

**注意事项**：
- 色彩雷达遵循开发方案原则（前端计算，与直方图一致）
- 色彩雷达是前端实时计算，不使用硬编码模拟数据
- AI 诊断使用低分辨率图片（512x512）以降低 API 成本
- 诊断结果可以缓存（相同图片 + 相同数据）
- 确保不影响现有 Part1/Part2 分析流程
- **AI 诊断与 Part1/Part2 分开**：只做简单的光影解读，不进行深度分析
- **AI 诊断的诊断文本严格控制在 100 字以内**，使用"人类语言"总结优缺点
- **AI 诊断的评分格式支持两种格式**（简单数值或带描述的格式），后端自动标准化
- **前端需要处理数据不完整的情况**：使用可选链操作符（`?.`）和条件检查，避免访问 undefined 属性

-----

### Milestone 5: 管理后台与历史记录（2-3天）

**目标：** 实现V4.0规划中的“历史任务列表”和“管理后台”。

| 模块 | 任务详情 |
| :--- | :--- |
| **前端** | 1. **[历史]** `GET /api/analyze/history`（V4.0）。（注意：分页，`?limit=20&page=1`）。 |
| | 2. 在主站添加“我的历史”页面，列表展示历史任务，点击可跳转到`AdjustmentResults`（即`GET /api/analyze/:taskId`）。 |
| **后端** | 1. **[路由]** `GET /api/analyze/history` (V4.0)：<br>    ˆ `SELECT id, status, created_at, source_image_thumbnail FROM analysis_tasks WHERE userId = ? ORDER BY created_at DESC LIMIT ? OFFSET ?`。（需要为`uploads`表生成缩略图）。 |
| **管理后台** | 1. **[路由]** `GET /api/admin/tasks` (分页, 可搜索`userId`或`taskId`)。 |
| | 2. **[路由]** `GET /api/admin/tasks/:taskId` (返回**原始**`gemini_result`和**已验证**的`structured_result`，用于调试Prompt)。 |
| | 3. **[路由]** `GET /api/admin/users` (用户列表)。 |
| | 4. **[前端]** `Admin/Tasks.tsx`：使用`Ant Design`的`Table`组件，展示`GET /api/admin/tasks`的数据。 |
| | 5. **[前端]** `Admin/TaskDetail.tsx`：<br>    ˆ 左侧显示`gemini_result`（原始JSON）。<br>    ˆ 右侧显示`structured_result`（Zod修复后的JSON）。<br>    ˆ **(这是调试Prompt最关键的页面)**。 |
| | 6. **[前端]** `Admin/Users.tsx`：展示用户列表。 |

-----

## 📑 附录：已优化的Prompt策略（按两阶段拆分）

你不再使用那个单体Prompt，而是使用这两个：

### 1\. Part 1 Prompt (用于 `POST /api/analyze/part1`)

> (角色定义：资深摄影师...)
>
> 【输入】
>
>   * `reference_image`: ...
>   * `user_image`: ...
>
> 【任务】
> 你将执行第一阶段的基础洞察。输出必须包含**自然语言报告**和**JSON**两部分。
>
> 1.  **自然语言报告 (Part 1)**：
>       * 执行你原Prompt的**Step 1（专业摄影师视角评价）**。
>       * *（请注意：如果提供了user\_image，对比分析表必须在此处输出）。*
> 2.  **JSON (Part 1)**：
>       * `professional_evaluation`: (你原Prompt Step 1的结构化版本)。
>       * `analysis_meta`: (你原Prompt Step 2, 4的结合，包含`composition`、`resolution`、`conversion_feasibility`等)。
>       * `workflow_draft`: (V4.0文档要求) 包含对后续Part2的初步工作流草案。
>
> **【重要更新 - Module 2 双宇宙重构】**
>
> `module_2_composition` 已重构为双宇宙模式，彻底杜绝 Gemini 混淆两张图：
>
> - **宇宙 A：参考图分析 (reference_analysis)** - 仅分析参考图，作为教科书标准
>   - 包含：`classification`、`geometric_structure`、`visual_quality_assessment`、`visual_weight`（含 `layers_visual_map` 图层）、`visual_flow`（含 `vectors` 向量）、`spatial_depth`（含 `polygon` 多边形）、`negative_space`
>   - **所有坐标基于参考图（Reference Image）**
>   - Prompt 指令：**PART A: THE MASTERPIECE ANALYSIS (Target: Reference Image ONLY)**
>
> - **宇宙 B：用户图诊疗 (composition_clinic)** - 仅分析用户图，作为手术台
>   - 包含：`diagnosis_summary`、`suggested_crop`、`action_guides`、`grading_masks`
>   - **所有坐标基于用户图（User Image）**
>   - Prompt 指令：**PART B: THE SURGICAL CLINIC (Target: User Image ONLY)**
>
> **前端组件**：
> - `CompositionAnalysisPanel.tsx`：主面板，左侧参考图交互区（支持切换图层：视觉流/空间深度/视觉权重），右侧数据分析面板（分类、视觉质量、权重分布、留白平衡），核心按钮进入构图诊疗室
> - `DirectorViewfinder.tsx`：诊疗室，全屏显示用户图，支持四种模式（原图/智能构图/拍摄指导/后期蒙版），提供沉浸式 AR 指导
>
> **后端数据清洗**：
> - `analysis_formatter.py` 的 `_format_composition` 方法已更新，支持清洗新双宇宙结构数据
>   - 清洗 `reference_analysis`：`spatial_depth.polygon`、`visual_weight.layers_visual_map`、`visual_flow.vectors`
>   - 清洗 `composition_clinic`：`suggested_crop`、`action_guides`、`grading_masks`
>   - 所有坐标归一化为 0-100% 格式
> - **向后兼容**：保留旧字段结构（`main_structure`、`subject_weight`、`visual_guidance` 等），确保不影响现有功能

### 2\. Part 2 Prompt (用于 `POST /api/analyze/part2`)

> (角色定义：影像后期专家...)
>
> 【输入】
>
>   * `reference_image`: ...
>   * `user_image`: ...
>   * `part1_context`: (一个JSON对象，包含Part 1的`professional_evaluation`摘要和`workflow_draft`)
>
> 【任务】
> 你将执行第二阶段的详细参数执行。根据`part1_context`中的草案，为`user_image`生成复刻`reference_image`的详细参数。
>
> 1.  **自然语言报告 (Part 2)**：
>       * 工作流执行总结：说明你如何（沿用/调整/新增）`part1_context.workflow_draft`中的步骤。
>       * LR/PS调色思路的自然语言描述。
> 2.  **JSON (Part 2)**：
>       * 严格执行你原Prompt的**Step 3, 5, 6**。
>       * `lightroom`: (包含所有基础滑块, tone\_curve, rgb\_curves, HSL, color\_grading...)
>       * `lightroom_panels`: (详细面板)
>       * `lightroom_local_adjustments`: (局部调整)
>       * `photoshop`: (所有步骤)
>       * `color_mapping`: (V4.0要求)
>       * `workflow_alignment_notes`: (V4.t要求，说明与草案的差异)

-----

### 3\. Part 3 Prompt (用于Gemini Flash Image)

> (这是一个全新的、简单的Prompt)
>
> 【输入】
>
>   * `user_image`: ... (用户图)
>   * `style_summary`: (一个简短的JSON或文本，包含Part 2生成的关键参数，例如: `{ "exposure": "+0.5", "contrast": "+15", "highlights": "-30", "temperature": "+120", "tint": "+8", "shadow_hue": 230, "highlight_hue": 35 }`)
>
> 【任务】
> 你是一个AI照片编辑器。请**严格**按照`style_summary`中的参数调整`user_image`。不要发挥创意，只需应用这些调整，生成一张“仿色后”的示意图。

## 开发方案

### 0. 本轮迭代统一约定与范围边界

#### 0.0 服务启动检查清单（强制要求）

**问题背景**：在开发过程中曾出现路由404问题，根本原因是应用无法正常启动，导致路由未注册。为避免类似问题，特制定此检查清单。

**启动前必须检查**：

1. **依赖安装检查**：
   - 确保所有 `requirements.txt` 中的依赖已安装：`pip install -r requirements.txt`
   - 关键依赖包括：
     - `python-jose[cryptography]`（JWT认证）
     - `email-validator`（邮箱验证）
     - `pydantic-settings`（配置管理）
     - `reportlab`（PDF生成，可选）
   - 如果使用代理，可能需要 `--trusted-host` 参数：
     ```bash
     pip install --trusted-host pypi.org --trusted-host pypi.python.org --trusted-host files.pythonhosted.org -r requirements.txt
     ```

2. **环境变量配置检查**：
   - 检查 `.env` 文件是否存在，且包含必需配置：
     - `GEMINI_API_KEY`（必需）
     - `GEMINI_MODEL`（可选，默认 `gemini-2.5-pro`）
     - `GEMINI_TIMEOUT_MS`（可选，默认 `120000`）
     - `SECRET_KEY`（必需，生产环境必须修改）
     - `DATABASE_URL`（可选，默认 SQLite）
   - 确保 `Settings` 类中定义了所有环境变量字段（见第 0.2 节）

3. **Pydantic 配置检查**：
   - `Settings` 类的 `Config` 中必须设置 `extra = "ignore"`，允许环境变量中有额外字段但不报错
   - 所有环境变量字段必须在 `Settings` 类中定义，或使用 `extra = "ignore"` 忽略未定义字段

4. **SQLAlchemy 模型检查**：
   - **禁止使用保留字段名**：`metadata`、`query`、`registry` 等是 SQLAlchemy 的保留字
   - 如果必须存储元数据，使用 `extra_data` 或 `meta_data` 等替代名称
   - 检查所有模型类，确保无保留字段冲突

5. **路由注册验证**：
   - 启动服务后，访问 `http://localhost:8081/openapi.json` 检查所有路由是否注册
   - 使用以下命令验证：
     ```bash
     curl -s http://localhost:8081/openapi.json | python3 -c "import json, sys; data = json.load(sys.stdin); paths = list(data.get('paths', {}).keys()); print('Total routes:', len(paths)); [print(p) for p in sorted(paths) if '/api/' in p]"
     ```
   - 预期应看到所有路由：`/api/auth/*`、`/api/photos/*`、`/api/user/*`、`/api/analyze/*`、`/api/export/*`、`/api/simulate/*`、`/api/admin/*`

6. **CORS 配置检查**：
   - 开发环境：`allow_origins` 必须明确指定 `["http://localhost:3001", "http://127.0.0.1:3001"]`
   - **禁止**使用 `allow_origins=["*"]`，因为当 `allow_credentials=True` 时，浏览器会拒绝此配置
   - 生产环境：通过 `FRONTEND_ORIGINS` 环境变量配置允许的前端域名

7. **端口配置检查（强制要求）**：
   - **前端**：`vite.config.ts` 中 `server.port` 必须为 `3001`
   - **后端**：`server_py/run.py` 中 `port` 必须为 `8081`
   - **前端 API 配置**：`src/lib/api.ts` 中 `API_BASE_URL` 默认为 `http://localhost:8081`
   - **启动方式**：
     - ✅ 正确：使用 `python3 run.py` 或 `python run.py` 启动后端（端口自动设置为 8081）
     - ❌ 错误：直接使用 `uvicorn app.main:app --port 8000` 启动（会导致端口不一致，前端请求失败）
   - **端口一致性**：前后端端口配置必须一致，否则会导致 400 Bad Request 或其他连接错误
   - **验证方法**：
     - 启动后端后，检查 `lsof -ti:8081` 是否有进程
     - 启动前端后，检查浏览器控制台是否有 CORS 错误或连接错误
     - 如果出现 400 Bad Request，首先检查端口配置是否一致

**常见错误与解决方案**：

| 错误信息 | 原因 | 解决方案 |
|---------|------|---------|
| `ModuleNotFoundError: No module named 'jose'` | `python-jose` 未安装 | `pip install python-jose[cryptography]` |
| `ImportError: email-validator is not installed` | `email-validator` 未安装 | `pip install email-validator` |
| `pydantic_core.ValidationError: Extra inputs are not permitted` | 环境变量中有未定义字段 | 在 `Settings` 类中添加该字段，或设置 `extra = "ignore"` |
| `sqlalchemy.exc.InvalidRequestError: Attribute name 'metadata' is reserved` | 使用了 SQLAlchemy 保留字段名 | 重命名为 `extra_data` 或其他非保留名称 |
| 路由返回 404 | 应用启动失败，路由未注册 | 检查上述所有项，查看启动日志 |

**验证命令**：
```bash
# 1. 检查依赖
python3 -c "from jose import jwt; from email_validator import validate_email; print('✅ 依赖检查通过')"

# 2. 检查配置加载
python3 -c "import sys; sys.path.insert(0, 'server_py'); from app.config import get_settings; s = get_settings(); print('✅ 配置加载成功')"

# 3. 检查应用启动
python3 -c "import sys; sys.path.insert(0, 'server_py'); from app.main import create_app; app = create_app(); print('✅ 应用启动成功，路由数:', len([r for r in app.routes if hasattr(r, 'path')]))"
```

#### 0.1 前端变量命名规范（防止重复声明问题）

**问题背景**：在 `ThemeCardsGrid.tsx` 中曾出现 `taskId` 重复声明错误（props 与 state 同名），导致语法错误。

**规范定义**：
- **禁止**：组件内部声明与 props 同名的 state 或变量
- **要求**：如果 props 需要转换为内部状态，应使用计算值或重命名
- **命名规范**：
  - **Props 参数**：使用原始名称（如 `taskId`、`userId`、`imageUrl`）
  - **内部计算值**：使用 `currentXxx` 或 `internalXxx`（如 `currentTaskId`、`internalUserId`）
  - **内部 state**：使用 `xxxState` 或 `xxxData`（如 `taskIdState`、`userData`）
  - **函数参数**：如果函数参数与 props 同名，使用 `propXxx` 或 `paramXxx`（如 `propTaskId`、`paramUserId`）

**示例**：
```typescript
// ✅ 正确：使用 propTaskId 避免与内部变量冲突
interface ThemeCardsGridProps {
  taskId?: string;
}
export function ThemeCardsGrid({ taskId: propTaskId }: ThemeCardsGridProps) {
  // 计算值：从 propTaskId 或 results 中获取
  const currentTaskId = propTaskId || results?.meta?.taskId;
  
  // 内部 state：使用不同的名称
  const [taskIdState, setTaskIdState] = useState<string | null>(null);
}

// ❌ 错误：props 与 state 同名
export function BadComponent({ taskId }: { taskId: string }) {
  const [taskId, setTaskId] = useState<string>(''); // 语法错误！
}
```

**检查清单**：
- 所有组件在实现前，检查 props 名称是否与内部 state/变量冲突
- 如果存在冲突，优先重命名 props 参数（使用解构重命名）
- 代码审查时，使用 ESLint 规则检查重复声明

### 0. 本轮迭代统一约定与范围边界（原内容）

- **运行环境与端口配置（强制要求）**
  - **前端**：Vite 开发服务器，**必须**运行在 `http://localhost:3001`
    - 配置文件：`vite.config.ts` 中 `server.port` 必须设置为 `3001`
    - 不允许使用其他端口（如 3000），避免与开发方案不一致
  - **后端**：FastAPI 应用，**必须**运行在 `http://localhost:8081`
    - 启动文件：`server_py/run.py` 中 `port=8081`
  - **数据库**：开发环境使用 SQLite（`./photostyle.db`），生产环境使用 MySQL
  - **代理**：ClashX (7890) 或 Clash Verge (7897) 代理地址 `http://127.0.0.1:7897`（用于访问 Gemini API）
  
- **CORS 跨域配置（强制要求）**
  - **开发环境**：
    - 后端 CORS 中间件必须明确指定允许的源：`["http://localhost:3001", "http://127.0.0.1:3001"]`
    - **禁止**使用 `allow_origins=["*"]`，因为当 `allow_credentials=True` 时，浏览器会拒绝 `["*"]` 配置
    - 这是浏览器的安全策略，无法绕过
  - **生产环境**：
    - 通过环境变量 `FRONTEND_ORIGINS` 配置允许的前端域名（多个用逗号分隔）
    - 例如：`FRONTEND_ORIGINS="https://example.com,https://www.example.com"`
    - 如果未配置，默认不允许任何跨域请求（安全）
  - **配置位置**：
    - 后端：`server_py/app/main.py` 中的 `CORSMiddleware` 配置
    - 前端：`src/lib/api.ts` 中的 `API_BASE_URL`（默认 `http://localhost:8081`）
  - **验证方法**：
    - 启动前后端后，在浏览器控制台检查是否有 CORS 错误
    - 如果出现 "No 'Access-Control-Allow-Origin' header" 错误，检查后端 CORS 配置

- **后端技术栈与代码目录**
  - 本轮迭代后端统一采用 **Python（FastAPI/Flask）+ `server_py/app/**` 这套实现**；
  - 任何 `server/src/**`、Node.js + Express 相关代码与示例仅作为"历史/废弃参考"，**不再扩展**；
  - 未来如需 Node 版本，将单独开新迭代与文档，本方案默认所有新接口与服务均落在 `server_py/app` 下。

- **Admin 模拟数据与调试开关**
  - 现有 Admin 前端中使用 LocalStorage 的 store（`subscriptionStore`、`subscriptionUsersStore`、`paymentStore` 等）仅作为 Figma 还原与开发期模拟；
  - **生产环境要求**：
    - 不再展示“恢复默认模拟数据 / 清空数据 / 显示调试 JSON”等按钮（方案 3：删除，仅保留真实数据视图）；
    - 如需调试工具，统一以受限的 Admin 接口实现（例如 `/api/admin/plans/reset-defaults`），并通过权限/环境控制访问；
  - Cursor/开发在对接真实后端时，需移除或注释掉所有依赖 LocalStorage 模拟数据的生产代码路径。

- **复刻可行性 Feasibility 计算主导方**
  - **当前迭代 Feasibility 完全由系统算法主导**，不再通过 Gemini 输出 L/C/S/P/D/T/Q/R 的 score：
    - 由后端 CV/图像分析模块 + 规则引擎计算各指标分值与 FeasibilityScore（第 26 节的权重与阈值）；
    - Gemini 仅参与 Part1/Part2/Part3 的 **视觉+文案分析与调色参数生成**，不参与“能不能仿色”的数值判定；
  - 这样可以避免：
    - Feasibility 与实际调色参数之间的语义冲突；
    - 由于 Feasibility 额外调用带来的时延与成本；
  - Feasibility Prompt（如需使用）只负责**解释 CV 算法的结果**，而非重新做数值判断。

- **直方图数据来源与精度要求**
  - 直方图分为两类：
    - **真实像素级直方图 bins**：由前端 Canvas 或后端图像处理库（如 Pillow/sharp）根据图片像素计算，为“权威数据”；
    - **模拟后目标直方图**：在风格模拟/仿色场景中，**希望 Gemini 能给出目标直方图的数值与摘要**，再由前端据此渲染：
      - Gemini 输出的直方图数值可以采用低分辨率区间（如按 shadows/midtones/highlights 划分的比例数组），以及形状描述（峰形/双峰/偏暗等）；
      - 前端根据这些区间数值绘制“模拟目标直方图”，与真实 bins 形成对比视图；
  - 本方案约定：
    - **基础直方图**（源图、用户原图、风格模拟结果图）仍由像素级算法计算；
    - **“理想仿色直方图”或“目标直方图形态”** 由 Gemini 按 Prompt 返回区间数值 + 摘要，落在 `histogram_overview` 等字段中，前端用于绘制“建议曲线/理想直方图”；
    - 开发时以“真实 bins 驱动核心分析，模型摘要驱动解释与辅助可视化”为准，不反向依赖模型猜测 bins。

- **Feasibility 的业务行为与强制继续策略**
  - 当 Feasibility 算法检测到致命不兼容（deal-breakers）或 FeasibilityScore 较低时：
    - 前端必须弹出可行性模态框，明确风险与建议（第 26 节定义）；
  - **但允许用户选择“强制继续”**：
    - 模态框提供主按钮“继续分析（我接受风险）”，仅在用户明确确认后才调用 `POST /api/analyze/part1`；
    - 后端在日志与 `analysis_tasks.feasibility_result` 中记录该任务是“在低可行性情况下强制继续”的标记（例如 `forced_continue: true`），便于后期分析；
  - 这意味着：Feasibility 作为“强提示 +流量/成本保护”，但不会绝对阻止用户继续实验。

- **用量与订阅额度约束（严格限流）**
  - 订阅与额度绑定规则见第 27 节，本节统一补充硬约束：
    - 每次任务完成 Part1+Part2 计入一次“分析任务”；每次 Part3 成功生成预览图计入一次“生成照片”；
    - 超出当前订阅的 `analysis_per_month` / `generations_per_month` 时：
      - 后端禁止再调用 Gemini 或 CV 模型，直接返回业务错误码：
        - `USAGE_ANALYSIS_LIMIT_EXCEEDED` 或 `USAGE_GENERATION_LIMIT_EXCEEDED`；
      - 前端应在按钮上展示升级或更换套餐提示，阻止进一步点击；
  - 不允许“超额后继续悄悄扣量或软性提醒”，限额是硬边界。

- **用户抽屉“编辑资料 / 安全设置”范围**
  - 本轮迭代内，用户抽屉中的 `ProfilePanel` 需实现**完整的资料编辑与基础安全设置**：
    - 可编辑：头像、昵称、邮箱（依据业务需求）、个性签名等基本文本字段；
    - 安全相关：修改密码（输入旧密码 + 新密码 + 确认）、退出所有设备（可选）、查看最近登录记录（可选）；
  - 对应接口包括但不限于：
    - `PUT /api/user/profile`（修改资料）；
    - `POST /api/user/change-password`（修改密码）；
    - `GET /api/user/security/logins`（最近登录记录，可选）；
  - 后续更高级安全功能（多因子登录等）可以在后续版本扩展。

- **“我的仿色”点击行为**
  - “我的仿色”列表（`ReportsPanel`）点击单条记录的首选行为为：**跳转到主站的结果页，复用现有 UI**：
    - 路由示例：`/results/:taskId`，由现有 `ResultsPage` / `App` 结果视图加载 `GET /api/analyze/:taskId`；
    - 在结果页中用户可再次查看所有卡片（点评/构图/光影/色彩/LR/PS/报告导出等），保证体验一致；
  - 仿色报告的 PDF/HTML 导出仍通过按钮触发 `GET /api/report/pdf?taskId=&downloadToken=`，不在“我的仿色”列表中单独维护新 UI。

- **可选/未来扩展内容的开发策略**
  - 文档中标记为“可选/后续扩展”的模块（如审计中心、CV 深度模型替换、复杂 Analytics 维度等）在架构上已留出接口与数据结构；
  - **允许 Cursor/开发在当前迭代中实现这些可选功能**，前提是：
    - 不改变本方案中已定的核心接口与数据结构；
    - 不引入与“统一 Python 后端”矛盾的新技术栈；
    - 所有新接口与模块需在文档中补充一行描述（保持设计与实现同步）。
  - 若需限制某次开发任务的范围，可在任务描述中另行约定；本《开发方案》默认“允许在不破坏主线的前提下实现可选扩展”。

### 1. 背景与目标
- 业务背景：
- 问题与机会：
- 目标与不做清单（Out of scope）：

### 2. 需求范围
- 功能需求：
  - 用户场景 1：
  - 用户场景 2：
- 非功能需求：性能、可用性、可靠性、安全、合规、可维护性、可观测性等

### 3. 系统架构
- 总体架构图（补图）：前端 Web、后端服务、模型服务、存储、CDN、监控告警
- 关键技术栈：
  - 前端：Vite、React、TypeScript、Tailwind 等
  - 后端：Python（FastAPI/Flask）、任务队列（Celery/RQ）、缓存（Redis）
  - 模型服务：本地/容器化部署，或第三方 API（如 Gemini/OpenAI）
  - 数据库与存储：SQLite/PostgreSQL、对象存储（本地/云）
  - 日志与监控：结构化日志、Prometheus/Grafana、Sentry

### 4. 模块设计
- 前端（`src/`）：
  - 路由与页面：Landing、用户中心、订阅页、管理后台、结果页
  - 组件：风格模拟、分析进度、相似度提醒等
  - 状态管理与数据流：`lib/*Store.ts`（订阅、支付、内容等）
- 后端（`server_py/`）：
  - API 网关与鉴权：JWT/Session、速率限制、CORS
  - 业务服务：上传/任务创建/状态查询/结果回调
  - 模型服务适配：以接口封装 `services/gemini.py` 等
  - 持久化：关系库（任务、用户、订阅）、对象存储（图片/结果产物）
  - 任务异步化：长时任务入队，前端轮询或 Webhook/WS 推送

### 5. 数据模型与存储
- 核心实体：User、Subscription、Task、Asset、Result、Payment
- 关系示意：User 1—N Task；Task 1—N Asset；Task 1—1 Result；User 1—1 Subscription
- 索引与容量预估：按任务创建时间、用户维度建立索引；对象存储做生命周期管理

#### 5.2 永久化存储方案（根据永久化存储方案.md）

**数据库迁移工具**：
- 开发环境：使用 `Base.metadata.create_all(bind=engine)` 自动创建表（仅用于快速开发）
- 生产环境：**必须使用 Alembic 进行数据库迁移管理**
  - 安装：`pip install alembic`
  - 初始化：`alembic init alembic`
  - 生成迁移：`alembic revision --autogenerate -m "Initial migration"`
  - 应用迁移：`alembic upgrade head`
  - 迁移文件存储在 `server_py/alembic/versions/` 目录
  - 详细实施步骤见永久化存储方案.md 第 5 节

**Redis 缓存层**（当前未实现，需补充）：
- 应用场景：
  1. 用户会话缓存（TTL 5 分钟）
  2. 任务结果缓存（TTL 24 小时）
  3. 验证码缓存（TTL 10 分钟）
  4. 用量统计缓存（TTL 1 小时）
  5. 订阅计划缓存（TTL 1 小时）
  6. API 限流缓存（TTL 60 秒）
- 配置环境变量：`REDIS_HOST`、`REDIS_PORT`、`REDIS_PASSWORD`、`REDIS_DB`
- 开发环境：使用 Docker 运行 Redis（`docker run -d -p 6379:6379 redis:alpine`）
- 生产环境：使用云 Redis 服务（阿里云 Redis、AWS ElastiCache）
- 详细设计见永久化存储方案.md 第 7 节

**对象存储方案**（当前使用 Base64 存储，需迁移）：
- 当前状态：图片以 Base64 格式存储在数据库 `Text` 字段中（`analysis_tasks.source_image_data`、`uploads.source_image_data`）
- 问题：数据库体积快速增长、查询性能下降、无法 CDN 加速
- 推荐方案：使用对象存储服务（OSS/S3），数据库仅存储 URL
  - 开发环境：本地文件系统或 MinIO（S3 兼容）
  - 生产环境：阿里云 OSS、AWS S3、腾讯云 COS
- 存储结构：`uploads/{user_id}/{task_id}/source.jpg`、`results/{task_id}/preview.jpg`、`avatars/{user_id}/avatar.jpg`
  - **注意**：实际实现中，文件名使用 UUID 生成，避免冲突（如 `uploads/{user_id}/{task_id}/source-{uuid}.jpg`）
  - 文件扩展名根据图片格式动态确定（.jpg、.png 等），支持多种图片格式
- 迁移计划：见永久化存储方案.md 第 8 节和第 12 节（第二阶段）
- 注意：`uploads` 表已预留 `source_image_url` 和 `target_image_url` 字段，但当前未使用
- **MinIO 初始化与回退机制**：
  - 如果 `OSS_STORAGE_TYPE=minio` 但 MinIO 服务未运行，初始化会设置 5 秒超时，快速失败
  - 初始化失败时，`self._client` 会被设置为 `None`，不会导致应用启动失败
  - 上传接口会检查 `storage_type` 和 `_client`，如果 `storage_type == "local"` 或 `_client` 为 `None`，直接使用 Base64 存储
  - `delete_image` 方法会检查对象存储客户端是否可用，如果不可用会记录警告但不抛出异常
  - 归档服务调用 `delete_image` 时，即使删除失败（如 MinIO 未运行）也不会影响数据库记录删除

**数据备份与恢复**：
- 开发环境：SQLite 文件每日备份，保留 7 天
- 生产环境：MySQL/PostgreSQL 每日全量备份，保留 30 天，每周归档到对象存储
- 灾难恢复：主从复制，RTO < 5 分钟，RPO < 1 分钟
- 详细策略见永久化存储方案.md 第 9 节

**数据归档与清理**：
- 分析任务数据：保留 1 年，超过 1 年归档到冷存储
- 上传记录：保留 6 个月
- 认证令牌：过期后保留 30 天用于审计
- 支付记录：永久保留
- 用户数据：永久保留（注销时标记 `status=disabled`）
- 详细策略见永久化存储方案.md 第 10 节

#### 5.1 SQLAlchemy 模型设计规范（强制要求）

**SQLAlchemy 保留字段名列表（禁止使用）**：
- `metadata`：用于存储表的元数据，不能作为列名
- `query`：用于查询接口，不能作为列名
- `registry`：用于注册表，不能作为列名
- `__table__`：内部表对象，不能作为列名
- `__mapper__`：内部映射器，不能作为列名

**替代方案**：
- 如需存储元数据，使用 `extra_data`、`meta_data`、`custom_metadata` 等名称
- 示例：
  ```python
  # ❌ 错误：使用保留字段名
  class Subscription(Base):
      metadata = Column(JSON, nullable=True)  # 会报错
  
  # ✅ 正确：使用替代名称
  class Subscription(Base):
      extra_data = Column(JSON, nullable=True)  # 正确
  ```

**检查方法**：
- 在定义模型后，尝试导入应用：`python3 -c "from app.models import *; from app.main import create_app; app = create_app()"`
- 如果出现 `InvalidRequestError: Attribute name 'xxx' is reserved`，说明使用了保留字段名

### 6. 接口定义（示例）
- POST `/api/tasks`：创建任务（含参考图/目标图）→ 返回 `taskId`
- GET `/api/tasks/{taskId}`：查询任务状态与结果
- POST `/api/analysis/similarity`：相似度计算
- GET `/api/subscription/me`：查询订阅状态
- 统一响应：`{ code, message, data }`；错误码与重试策略定义

### 7. 安全与合规
- 鉴权与授权：JWT 短期、Refresh Token、角色权限（用户/管理员）
- 输入校验与速率限制：防注入、防刷、防爆破
- 数据合规：个人数据最小化留存、脱敏/加密、日志留存策略

### 8. 部署与环境
- 环境：Dev / Staging / Prod，配置隔离（.env.*）
- 构建与发布：CI/CD（测试→构建→镜像→部署），前后端分离部署
- 运行时：容器编排（Docker Compose/K8s），滚动发布，健康检查与熔断

### 9. 监控与日志
- 指标：请求成功率、P95 延迟、任务成功率、模型调用失败率、资源使用
- 日志：结构化，关联 `requestId`/`taskId`
- 告警：阈值与抖动控制，按模块路由

### 10. 测试计划
- 单元测试：前端组件/Store，后端服务/适配层
- 集成测试：API 契约、任务全链路
- 端到端：关键用户路径（上传→下单/任务→结果）
- 回归与性能：基准与压力测试（QPS、并发、资源曲线）

### 11. 里程碑与排期（示例）
- M1：最小可用链路（创建任务→轮询结果）
- M2：订阅与支付对接、鉴权完善
- M3：监控日志完善、告警接入、性能优化
- M4：灰度与稳定性验收，准备发布

### 12. 风险与应对
- 第三方模型不稳定：超时与降级、本地备份模型/缓存结果
- 任务积压：限流、队列扩容、优先级与丢弃策略
- 成本不可控：缓存与复用、CDN、批处理

### 13. 附录

#### 13.1 依赖管理清单

**Python 后端依赖（`server_py/requirements.txt`）**：
- `fastapi>=0.104.0`：Web 框架
- `uvicorn[standard]>=0.24.0`：ASGI 服务器
- `sqlalchemy>=2.0.0`：ORM
- `pydantic>=2.0.0`：数据验证
- `pydantic-settings>=2.0.0`：配置管理（必需，用于 `BaseSettings`）
- `python-jose[cryptography]>=3.3.0`：JWT 认证（必需，用于 `from jose import jwt`）
- `passlib[bcrypt]>=1.7.4`：密码加密
- `python-multipart>=0.0.6`：文件上传支持
- `pillow>=10.0.0`：图像处理
- `opencv-python>=4.8.0`：计算机视觉（可行性评估）
- `numpy>=1.24.0`：数值计算
- `loguru>=0.7.0`：日志
- `google-genai>=0.2.0`：Gemini API 客户端
- `reportlab>=4.0.0`：PDF 生成（可选）
- `email-validator>=2.0.0`：邮箱验证（必需，用于 `EmailStr`）

**安装命令**：
```bash
# 标准安装
pip install -r requirements.txt

# 如果使用代理，需要添加 trusted-host
pip install --trusted-host pypi.org --trusted-host pypi.python.org --trusted-host files.pythonhosted.org -r requirements.txt
```

**依赖验证**：
```bash
# 检查关键依赖
python3 -c "from jose import jwt; from email_validator import validate_email; from pydantic_settings import BaseSettings; print('✅ 所有关键依赖已安装')"
```

#### 13.2 错误码表（补充）

**邮件验证码相关错误码**（根据注册登录与权限设计方案第 8.1 节）：
- `EMAIL_ALREADY_REGISTERED` (400) - 邮箱已注册（注册时）
- `EMAIL_NOT_REGISTERED` (400) - 邮箱未注册（登录时）
- `INVALID_VERIFICATION_CODE` (400) - 验证码错误或已过期
- `SEND_CODE_TOO_FREQUENT` (429) - 发送验证码过于频繁（60秒内）
- `EMAIL_SEND_FAILED` (500) - 邮件发送失败

**路由与启动相关错误码**：
- `ROUTE_NOT_FOUND`：路由未注册（通常表示应用启动失败）
- `MODULE_NOT_FOUND`：依赖缺失（如 `ModuleNotFoundError: No module named 'jose'`）
- `CONFIG_VALIDATION_ERROR`：配置验证失败（如 Pydantic 验证错误）
- `MODEL_DEFINITION_ERROR`：模型定义错误（如 SQLAlchemy 保留字段冲突）

**常见错误与解决方案**（见第 0.0 节）

#### 13.3 术语表、接口示例、数据字典、部署清单

### 14. 前端“去模拟化”与接口对照表

- **目标**：前端所有按钮/交互均调用真实后端接口，不再依赖本地模拟状态或随机数。
- **主站关键交互与后端映射**：
  - 上传图片（源图/目标图）：
    - 组件：`PhotoUploadZone`、`App` 上传区。
    - 接口：`POST /api/photos/upload`（multipart/form-data）。
    - 返回字段（示例）：`{ uploadId, source_image_url, target_image_url, thumbnails: { source, target }, exifDigest }`。
    - **前端实现注意事项**：
      - 使用 `AbortController` 管理上传请求的取消，防止重复上传
      - **重要**：`useEffect` 清理函数不应该依赖 `AbortController` 状态，否则会导致新创建的请求被立即取消
      - 正确的做法：
        1. 使用 `useRef` 存储最新的 `AbortController` 引用
        2. 使用 `useEffect` 同步 `ref` 和 `state`，确保 `ref` 始终是最新的值
        3. `useEffect` 清理函数只在组件卸载时执行，依赖数组为空 `[]`
        4. 在设置 `controller` 时立即更新 `ref`，避免异步更新延迟
        5. 在清除 `controller` 时同步清除 `ref`
      - 手动取消逻辑应该在各个上传函数中实现（如 `onImageUpload`），而不是依赖 `useEffect`
      - 错误处理：请求取消（499）不显示错误提示，其他错误（如 401）需要友好提示
      - **调用顺序**：先设置 `controller` 到 `ref`（同步），再设置到 `state`（异步），然后设置预览图片，最后调用上传 API
      - **重要：使用 ref 而不是 state 检查正在进行的上传**：在 `onImageUpload` 中，必须使用 `uploadAbortControllerRef.current` 而不是 `uploadAbortController`（state）来检查正在进行的上传。原因：React 的 state 更新是异步的，如果两个 `onImageUpload` 几乎同时执行，使用 state 检查可能会导致两个函数都认为没有正在进行的上传，从而同时开始上传。使用 ref 可以确保检查的是最新的、同步的值。
      - **删除操作**：`onRemove` 回调应该先检查是否有正在进行的上传请求（使用 `uploadAbortControllerRef.current`），如果有则先取消上传请求，再清除图片状态，避免上传完成后更新已删除的图片状态，导致状态不一致
      - **FileReader 竞态条件防护**：在 `PhotoUploadZone` 组件中，使用 `useRef` 存储当前的 `FileReader` 实例和图片时间戳，防止用户快速连续上传多张图片时，多个 `FileReader` 实例同时读取文件导致竞态条件。在 `reader.onload` 回调中，检查当前的 `reader` 和时间戳是否仍然是最新的，如果不是则忽略该结果
      - **图片有效性检查**：在 `App.tsx` 的 `onImageUpload` 函数中，在创建 `AbortController` 之前，先检查当前图片是否仍然是最新的（通过比较时间戳）。如果当前图片的时间戳小于已保存图片的时间戳，说明用户已经上传了新的图片，应该直接返回，不执行上传请求。这样可以防止旧的 `FileReader` 触发无效的上传请求，避免"请求已取消"错误
  - 开始 AI 分析（Part1）：
    - 触发点：主按钮“开始 AI 分析”/“开始分析”。
    - 接口：`POST /api/analyze/part1`，请求体 `{ uploadId, optional_style? }`。
    - 返回：`{ taskId, stage: 'part1', status: 'part1_completed' | 'processing', structuredAnalysis, naturalLanguage, protocolVersion, meta }`。
  - 查看详细方案（触发 Part2+Part3）：
    - 触发点：结果页"查看详细方案"按钮或 Stage2 卡片点击。
    - 接口：`POST /api/analyze/part2`，请求体 `{ taskId }`。
    - **taskId 传递规范**：
      - `taskId` 必须通过 props 传递给 `ThemeCardsGrid` 组件（从 Part1 返回的 `taskId`）
      - 组件内部**禁止声明同名 state**，应使用计算值：`const currentTaskId = propTaskId || results?.meta?.taskId || null`
      - 如果 props 中没有 `taskId`，可以从 `results.meta.taskId` 获取
    - 行为：接口快速返回 `{ status: 'processing' }`，前端开始轮询。
    - **当前实现状态**：⚠️ 当前为同步等待（不符合规范），需要后续优化为轮询机制（见第 16 节）。
  - 任务结果轮询：
    - 触发点：Part2 触发后，或从历史记录/用户中心进入结果页。
    - 接口：`GET /api/analyze/{taskId}`。
    - 返回：`{ status, stage, structured_result, natural_language_part1, natural_language_part2, meta }`。
  - 风格模拟（仿色示意图）：
    - 触发点：`StyleSimulation` 按钮/卡片。
    - 接口：推荐与 Part2 Job 串联，由 Part2 后端在 `runPart2And3Job` 内完成风格模拟，将 `preview_image_url` 合并入 `structured_result`；如需单独接口则为 `POST /api/simulate/style` + 轮询。
  - 导出（XMP/JSX/PDF/JSON）：
    - 触发点：结果页导出按钮。
    - 接口：
      - `GET /api/export/xmp?taskId=&token=`、
      - `GET /api/export/jsx?taskId=&token=`、
      - `GET /api/report/pdf?taskId=&token=`、
      - `GET /api/export/json?taskId=&token=`。
    - 行为：前端使用 `window.open()` 直接触发下载；鉴权通过 Query Token 或签名 URL。
  - 历史记录：
    - 触发点：用户中心“我的历史”页面。
    - 接口：`GET /api/analyze/history?limit=20&page=1`。
  - 相似度提示：
    - 推荐从后端 `uploads.similarity_score` 或分析结果中的 `similarity_check` 返回，不再前端随机生成。

- **前后端接口一致性检查清单（强制要求）**：
  - 所有前端 API 调用必须通过 `src/lib/api.ts` 统一封装，**禁止**直接使用 `fetch` 或 `axios`
  - 所有后端路由必须统一返回 `{code, message, data}` 格式
  - 所有接口路径必须与开发方案第 14 节对照表一致
  - 新增接口时，必须同时更新前端 `api.ts` 和后端路由，并在开发方案中记录
  - 所有接口的错误处理必须统一使用 `ApiError`（前端）和 `HTTPException`（后端）
  - 前端 API 客户端必须完善错误处理：先检查 HTTP 状态码，再解析 JSON，避免非 JSON 响应时崩溃

- **用户与订阅/支付相关交互**：
  - 注册：
    - `RegisterDialog.tsx` 中的注册逻辑：
      - `POST /api/auth/send-verification-code`（`type="register"`）：发送注册验证码
      - `POST /api/auth/register`：提交注册（邮箱+验证码+密码）
    - 成功后保存 JWT（`accessToken`）与必要的用户资料到 `localStorage`，自动登录
  - 登录：
    - `LoginDialog.tsx` 中的登录逻辑：
      - **密码登录**：`POST /api/auth/login`（邮箱+密码）
      - **验证码登录**：
        - `POST /api/auth/send-verification-code`（`type="login"`）：发送登录验证码
        - `POST /api/auth/login-with-code`：提交登录（邮箱+验证码）
      - `GET /api/auth/me`：获取当前用户信息
    - 成功后保存 JWT（`accessToken`）与必要的用户资料到 `localStorage`
  - 管理员登录：
    - `AdminLoginDialog.tsx` 中的两步验证登录：
      - `POST /api/admin/auth/login`：第一步（邮箱+密码），返回 `mfaToken`
      - `POST /api/admin/auth/verify-mfa`：第二步（`mfaToken`+验证码），返回 `adminAuthToken`
    - 成功后保存 `adminAuthToken` 到 `localStorage`（与普通用户 Token 分开存储）
  - 订阅与套餐：
    - `SubscriptionPage`、`UserCenter` 订阅模块：
      - `GET /api/subscription/plans`：获取套餐列表。
      - `GET /api/subscription/me`：获取当前订阅状态。
  - 支付与订单：
    - 结算页（Checkout）：
      - `POST /api/payments/create`：创建订单，返回 `paymentId`、收银台参数。
      - 第三方支付回调：`POST /api/payments/webhook/:channel`（后端与支付渠道对接）。
      - 前端轮询：`GET /api/payments/{paymentId}` 查看订单状态（`pending/succeeded/failed`）。

- **管理后台 Admin 交互与接口映射**：
  - 管理员登录（两步验证）：
    - 第一步：`POST /api/admin/auth/login`（邮箱+密码），返回 `mfaToken`
    - 第二步：`POST /api/admin/auth/verify-mfa`（`mfaToken`+验证码），返回 `adminAuthToken`（`admin_session` JWT）
  - 后台页面：
    - Dashboard：`GET /api/admin/dashboard/metrics`。
    - 用户管理：`GET /api/admin/users`。
    - 订阅管理：`GET /api/admin/plans`、`GET /api/admin/subscriptions`。
    - 支付管理：`GET /api/admin/payments`。
    - 任务管理：`GET /api/admin/tasks`、`GET /api/admin/tasks/{taskId}`。
    - 内容管理：`GET/POST /api/admin/content`。
    - 分析模块：`GET /api/admin/analytics/*`。

### 15. 前端 API 客户端与统一通信规范

- **API 客户端设计**：
  - 在前端新增 `src/lib/api.ts`：
    - 基于 `fetch` 或 `axios` 封装：
      - 基础配置：`baseURL`、超时、`Content-Type`。
      - 请求拦截器：自动附加 `Authorization: Bearer <accessToken>`。
      - 响应拦截器：统一处理 `{ code, message, data }`，对 `code != 0` 抛出带业务码的错误。
      - 错误分类：网络错误/超时/业务错误/鉴权错误，对应 UI 提示策略。
  - 常用方法：
    - `uploadPhotos(formData)` → `POST /api/photos/upload`。
    - `analyzePart1(uploadId, options?)` → `POST /api/analyze/part1`。
    - `analyzePart2(taskId)` → `POST /api/analyze/part2`。
    - `getAnalysis(taskId)` → `GET /api/analyze/{taskId}`。
    - `getHistory(params)` → `GET /api/analyze/history`。
    - `simulateStyle(taskId)` → `POST /api/simulate/style`（如单独实现）。
    - `exportXmp/Jsx/Json/Pdf(taskId)` → 对应导出接口。

- **通信协议与响应规范**：
  - 统一响应结构：
    - 成功：`{ code: 0, message: 'ok', data: {...} }`。
    - 业务错误：`{ code: <业务码>, message: <可展示文案>, data?: {...} }`。
  - HTTP 状态码建议：
    - 2xx：成功（含部分业务警告，可通过 `data.meta.warnings` 暴露）。
    - 4xx：参数错误/鉴权失败/资源不存在：
      - 400：参数错误（`code=INVALID_PARAMS`）。
      - 401：未登录或 Token 失效（`code=UNAUTHORIZED`）。
      - 403：无权限（`code=FORBIDDEN`）。
      - 404：资源不存在（`code=NOT_FOUND`）。
    - 5xx：服务端错误或第三方模型错误：
      - 500：内部错误（`code=INTERNAL_ERROR`）。
      - 502/504：上游模型/网络超时（`code=UPSTREAM_TIMEOUT`）。
  - 版本控制：
    - 接口版本：通过 URL 前缀预留 `/api/v1/...`。
    - 协议版本：分析结果中必须包含 `protocolVersion: '2025-02'`，前端根据版本走不同适配路径。

### 16. 任务状态机与轮询策略

#### 16.1 Part2 轮询逻辑修复（重要）

**问题**：点击"查看详细方案"后，Stage2 界面在 1-2 秒左右就弹出，但 Gemini 还没有返回结果。

**根本原因**：
1. 前端轮询逻辑检查了 `status === 'part2_completed'`，但这个状态可能不存在或过早返回
2. 前端没有验证 `structuredResult.sections` 中是否有 Part2 数据（color、lightroom、photoshop），导致在数据未准备好时就切换到 Stage2

**修复方案**：
1. **前端修复**（`ThemeCardsGrid.tsx`）：
   - 只检查 `status === 'completed'`，移除 `'part2_completed'` 检查
   - 在切换到 Stage2 之前，必须验证 `structuredResult.sections` 中存在 Part2 数据（至少要有 color、lightroom、photoshop 中的一个）
   - 如果 `structuredResult` 为空或没有 `sections`，继续轮询，不切换到 Stage2
   - 添加详细的日志记录，追踪数据合并过程

2. **后端修复**（`analysis_formatter.py`）：
   - 确保 `_format_lightroom` 方法始终返回非空的 `panels` 数组
   - 即使 `basic_params`、`presence_params`、`color_params` 为空，也创建对应的面板（使用默认值 "+0"）
   - 添加日志记录，追踪 panels 构建过程

**影响分析**：
- **不会影响前端接收数据**：修复后，前端只有在数据真正准备好时才会切换到 Stage2，确保数据完整性
- **用户体验改善**：用户不会看到空的 Stage2 界面，而是会看到加载状态，直到数据准备好

#### 16.2 Lightroom 数据缺失问题修复（第四次修复）

**问题**：Lightroom 数据显示不完整，按照设计应该有 6 个面板（基本面板、细节与质感、色彩调整、HSL/颜色、色调分离、色调曲线），但目前只显示了 3 个面板（基础调整、存在感、颜色设置）。

**根本原因**：
1. **后端 `_format_lightroom` 方法只创建了 3 个面板**：
   - 基础调整（basic_panel）
   - 存在感（presence）
   - 颜色设置（color_settings）
2. **缺失的面板**：
   - HSL/颜色：虽然 `_format_color_part2` 处理了 HSL 数据，但存储在 `color` section 中，而不是 `lightroom` section
   - 色调分离：虽然处理了 `split_toning_detail` 数据，但只存储到了 `colorGrading` 字段中，没有创建对应的面板
   - 色调曲线：虽然处理了 `tone_curve` 数据，但只存储到了 `toneCurve` 和 `rgbCurves` 字段中，没有创建对应的面板
3. **面板标题不符合设计规范**：
   - "基础调整" 应该是 "基本面板"
   - "存在感" 应该是 "细节与质感"
   - "颜色设置" 应该是 "色彩调整"

**修复方案**：
1. **后端修复**（`analysis_formatter.py` - `_format_lightroom` 方法）：
   - **【新增】** 添加 HSL/颜色面板：
     - 从 `color_science_scheme.hsl_detailed_12_colors`（新结构）或 `lightroom.HSL`（旧结构）中提取 HSL 数据
     - 将 12 色映射到前端需要的 8 色（红、橙、黄、绿、青、蓝、紫、洋红）
     - 为每种颜色创建色相、饱和度、明度参数
     - 只有当至少有一个值不为 0 时才添加参数
   - **【新增】** 添加色调分离面板：
     - 从 `split_toning_detail`（新结构）或 `lightroom.color_grading`（旧结构）中提取数据
     - 创建高光色相、高光饱和度、阴影色相、阴影饱和度、平衡参数
   - **【新增】** 添加色调曲线面板：
     - 从 `tone_curve`（新结构）或 `lightroom.tone_curve`（旧结构）中提取数据
     - 创建 RGB 曲线和单通道曲线（红、绿、蓝）参数
     - 将曲线点转换为字符串格式（如 "(0, 0), (64, 64), (128, 128)"）
   - **【修复】** 修正面板标题：
     - "基础调整" -> "基本面板"
     - "存在感" -> "细节与质感"
     - "颜色设置" -> "色彩调整"
   - **【新增】** 旧结构兼容：
     - 确保旧结构（`lightroom` 和 `lightroom_panels`）也创建 6 个面板
     - 从 `lightroom.HSL`、`lightroom.color_grading`、`lightroom.tone_curve` 中提取数据
   - **【新增】** 添加详细的日志记录：
     - 记录每个面板的创建过程
     - 记录面板标题列表
     - 记录参数数量

**实现位置**：
- `server_py/app/services/analysis_formatter.py`：`_format_lightroom` 方法（第 1153-1738 行）

**注意事项**：
- 根据设计规范，Lightroom 必须显示 6 个面板，不能缺少任何一个
- 即使某个面板没有数据，也要创建空面板（`params: []`），确保前端能显示面板结构
- 面板标题必须符合设计规范，不能使用旧的标题
- HSL 数据需要从 12 色映射到 8 色，确保前端能正确显示
- 色调曲线数据需要转换为字符串格式，便于前端显示
- 旧结构和新结构都要支持，确保向后兼容

#### 16.3 Lightroom 数据缺失问题修复（第三次修复）

**问题**：色彩方案和 Photoshop 有数据，但 Lightroom 没有数据。数据传递正确，但前端渲染时显示为空。

**根本原因**：
1. `_format_lightroom` 方法在构建 `panels` 数组时，如果 `basic_params`、`presence_params`、`color_params` 都为空，`panels` 会是空数组
2. 前端在合并数据时，如果 `panels` 为空数组，会导致前端显示无数据
3. **【新增原因】** `LightroomSection` 组件的数据验证逻辑过于严格，如果 `data` 不是数组，会直接返回 `null`，不显示任何内容
4. **【新增原因】** 前端数据合并时，如果 `panels` 为 `undefined` 或 `null`，会导致 `data` 不是数组，组件无法显示
5. **【关键原因 - 第三次修复】** `LightroomSection` 组件的过滤逻辑错误：
   - 原代码：`const regularPanels = panels.filter((s: any) => !s.masks);`
   - 问题：后端返回的每个 panel 都有 `masks: Array(0)`（空数组），而不是 `masks: undefined`
   - 在 JavaScript 中，空数组 `[]` 是 truthy 值，所以 `![]` 返回 `false`
   - 导致所有 panel 被过滤掉，`regularPanels` 数量为 0，前端无法渲染任何内容
   - **日志证据**：`[LightroomSection] ✅ 最终使用的 panels 数量: 3`，但 `[LightroomSection] regularPanels 数量: 0`

**修复方案**：
1. **后端修复**（`analysis_formatter.py`）：
   - 即使参数为空，也创建对应的面板（使用默认值 "+0"）
   - 确保 `panels` 数组始终包含至少 3 个面板（基础调整、存在感、颜色设置）
   - 添加日志记录，追踪 panels 构建过程
   - **【新增】** 修复 Pydantic Schema 验证：使用 `model_dump(mode='json')` 替代 `exclude_none=True`，避免过滤有效数据
   - **【新增】** 添加参数名称映射：将英文参数名（如 `exposure`）转换为中文（如"曝光"）
   - **【新增】** 添加范围值提取：从范围字符串（如 `"+0.80 ~ +1.20"`）中提取第一个值（如 `"+0.80"`）

2. **前端修复**（`ThemeCardsGrid.tsx`）：
   - 添加详细的日志记录，追踪 lightroom 数据合并过程
   - 检查 `panels` 是否存在且不为空，如果为空则记录警告日志
   - **【新增】** 确保 `panels` 始终是数组类型，即使为空也设置为空数组 `[]`，避免 `undefined` 或 `null` 导致组件无法显示
   - **【新增】** 添加类型检查，如果 `panels` 不是数组，记录错误日志并设置默认值
   - **【新增】** 使用深拷贝更新 state：`JSON.parse(JSON.stringify(updatedResults))`，避免引用问题导致数据丢失

3. **前端修复**（`ThemeDetailModal.tsx`）：
   - **【新增】** 使用深拷贝传递数据：`JSON.parse(JSON.stringify(results.lightroom))`，避免引用问题导致数据丢失
   - **【新增】** 添加详细的调试日志，记录传递给 `LightroomSection` 的数据

4. **前端修复**（`LightroomSection.tsx`）：
   - **【新增】** 改进数据验证逻辑，支持多种数据格式（数组、对象、对象中的 panels 等）
   - **【新增】** 添加详细的调试日志，记录接收到的数据结构和类型
   - **【新增】** 如果数据格式不正确，显示友好的错误提示，而不是直接返回 `null`
   - **【新增】** 支持向后兼容：如果 `data` 是对象，尝试从 `data.panels` 或 `data.structured.panels` 中提取
   - **【新增】** 如果 `panels` 为空数组，显示提示信息，而不是直接返回 `null`
   - **【关键修复 - 第三次修复】** 修复过滤逻辑：
     ```typescript
     // 原代码（错误）：
     const regularPanels = panels.filter((s: any) => !s.masks);
     
     // 修复后（正确）：
     const regularPanels = panels.filter((s: any) => {
       // 如果没有 masks 属性，或者 masks 为空数组，则认为是常规面板
       return !s.masks || (Array.isArray(s.masks) && s.masks.length === 0);
     });
     const maskPanels = panels.filter((s: any) => {
       // 如果有 masks 属性且不为空数组，则认为是蒙版面板
       return s.masks && Array.isArray(s.masks) && s.masks.length > 0;
     });
     ```
   - **【新增】** 添加过滤结果的调试日志，追踪 `regularPanels` 和 `maskPanels` 的数量

**实现位置**：
- `src/components/ThemeCardsGrid.tsx`：数据合并逻辑（第 280-410 行）
- `src/components/ThemeDetailModal.tsx`：数据传递逻辑（第 111-145 行）
- `src/components/sections/LightroomSection.tsx`：数据验证、过滤和显示逻辑（第 357-520 行）
- `server_py/app/services/analysis_formatter.py`：数据格式化逻辑（第 1125-1402 行）
- `server_py/app/schemas/analysis_schemas.py`：Pydantic Schema 验证逻辑（第 222-275 行）

**注意事项**：
- 根据开发方案第 24 节，`lightroom` 应该是一个数组（panels），而不是对象
- 前端 `LightroomSection` 组件期望接收一个数组，因此需要将 `panels` 直接赋值给 `lightroom`
- 其他数据（toneCurve、rgbCurves、colorGrading 等）应存储到 `lightroom_extra` 中
- 添加详细的调试日志，便于排查数据传递问题
- **【重要】** 后端返回的参数名称必须是中文（如"曝光"、"对比度"），而不是英文（如"exposure"、"contrast"），确保前端显示中文名称
- **【重要】** 后端返回的参数对象应同时包含 `purpose` 和 `reason` 字段，确保前端能正确显示调整依据
- **【重要】** 前端在 `processing` 状态下也会尝试合并数据（如果数据已可用），但不会切换到 Stage2，直到状态变为 `completed`
- **【重要】** Pydantic Schema 验证时，`LightroomPanelSchema` 必须设置 `model_config = {"extra": "allow"}`，允许保留额外字段（如 `purpose`），避免验证时丢弃数据
- **【重要】** `validate_part2_response` 函数使用 `model_dump(mode='json')` 而不是 `model_dump(exclude_none=True)`，确保空数组和空字符串等有效数据不被过滤
- **【关键】** JavaScript 中空数组 `[]` 是 truthy 值，所以 `![]` 返回 `false`。在过滤逻辑中，必须检查 `masks` 是否为 `undefined/null` 或者为空数组，而不能简单地使用 `!s.masks`
- **【关键】** 后端返回的 panel 对象中，`masks` 字段可能是 `undefined`、`null` 或空数组 `[]`，过滤逻辑必须正确处理这三种情况

#### 16.3 色调曲线显示问题修复（Lightroom & Photoshop）

**问题**：
1. **Lightroom 曲线问题**：
   - 只有红通道、绿通道、蓝通道曲线，缺少RGB曲线
   - Gemini输出了曲线对应的点，但没有根据点描绘成曲线（显示为折线或未显示）
2. **Photoshop 曲线问题**：
   - 曲线没有根据实际的点进行描绘（使用硬编码的 `CurveChart` 组件）
   - 曲线显示为折线，不是平滑曲线

**根本原因**：
1. **缺少RGB曲线**：
   - 后端发送的参数名是 `"RGB 曲线"`，但前端 `parseCurveParams` 只检查 `name.includes('luma') || name.includes('色调曲线')`
   - 没有检查 `name.includes('rgb')`，导致RGB曲线参数没有被解析到 `luma` 数组中
2. **曲线没有根据点绘制**：
   - 后端发送的格式是字符串：`"(0, 0), (128, 125), (255, 255)"`（多个点）
   - 前端 `parseCurveParams` 期望的格式是单个点，如 `"x≈0 → y≈10"` 或 `"输入 0 → 输出 10"`
   - 前端没有解析点坐标字符串格式，导致无法提取多个点
3. **曲线绘制算法问题**：
   - `CurveVisualizationLR` 组件使用直线连接（`L`），导致曲线显示为折线
   - 没有使用平滑曲线算法（如 Catmull-Rom 样条曲线或贝塞尔曲线）
4. **Photoshop 曲线问题**：
   - `PhotoshopSection.tsx` 使用硬编码的 `CurveChart` 组件，没有使用实际的曲线点数据
   - 后端 `_format_photoshop` 中 `ps_curves_adjustment` 的 `params` 是空数组，没有提取曲线点数据
   - Prompt 模板中 `ps_curves_adjustment` 只有文本描述，没有要求 Gemini 返回曲线点数据

**修复方案**：
1. **前端修复**（`src/components/sections/LightroomSection.tsx` - `parseCurveParams` 函数）：
   - **【修复1】** 识别RGB曲线：添加 `name.includes('rgb')` 检查，确保能识别 `"RGB 曲线"` 参数名
   - **【修复2】** 解析点坐标字符串：支持 `"(x, y), (x, y), ..."` 格式的字符串
     - 使用正则表达式 `value.match(/\((\d+),\s*(\d+)\)/g)` 匹配所有点坐标
     - 将每个点坐标拆分成独立的点对象，添加到 `luma` 数组
   - **【修复2】** 创建 `extractCurvePoints` 函数：支持多种格式
     - 格式1：点坐标字符串 `"(0, 0), (128, 125), (255, 255)"` - 返回多个点
     - 格式2：旧格式 `"x≈0 → y≈10"` - 返回单个点
     - 格式3：旧格式 `"输入 0 → 输出 10"` - 返回单个点
   - **【修复2】** 更新红色、绿色、蓝色通道曲线的解析逻辑，使用 `extractCurvePoints` 函数

2. **前端修复**（`src/components/CurveVisualizationLR.tsx` - `createPath` 函数）：
   - **【修复2】** 改进曲线绘制算法：使用 Catmull-Rom 样条曲线（三次贝塞尔曲线）绘制平滑曲线
     - 2个点：使用直线连接
     - 3个点：使用二次贝塞尔曲线（Q）
     - 4个或更多点：使用三次贝塞尔曲线（C）近似 Catmull-Rom 样条曲线
     - 确保曲线通过所有控制点，且曲线平滑
   - **【新增】** 添加详细的调试日志，记录接收到的 points 数据、解析后的点、最终的点

3. **前端修复**（`src/components/sections/LightroomSection.tsx` - 渲染逻辑）：
   - **【修复1】** 更新标题：将"色调曲线（Luma）"改为"色调曲线（RGB）"
   - **【修复1】** 更新参数过滤逻辑：检查名称是否包含 `"RGB"`、`"rgb"`、`"luma"` 或 `"色调曲线"`

4. **前端修复**（`src/components/sections/PhotoshopSection.tsx`）：
   - **【修复3】** 替换 `CurveChart` 组件：使用 `CurveVisualizationLR` 组件，传入实际的曲线点数据
   - **【修复3】** 添加 `parseCurveParams` 函数：从 `LightroomSection.tsx` 导入，解析曲线参数
   - **【修复3】** 添加 `extractCurvePoints` 函数：从 `LightroomSection.tsx` 导入，提取曲线点
   - **【修复3】** 更新渲染逻辑：显示 RGB 整体曲线和 RGB 各通道微调曲线，类似 Lightroom

5. **后端修复**（`server_py/app/services/analysis_formatter.py` - `_format_lightroom` 方法）：
   - **【新增】** 添加详细的日志记录，追踪RGB曲线数据的创建过程
   - **【重要】** 确保RGB曲线参数名称包含 `"RGB"` 或 `"rgb"`，便于前端识别

6. **后端修复**（`server_py/app/services/analysis_formatter.py` - `_format_photoshop` 方法）：
   - **【修复3】** 提取曲线点数据：从 `ps_curves_adjustment` 中提取 `rgb_points`、`red_channel`、`green_channel`、`blue_channel` 曲线点
   - **【修复3】** 格式化曲线点：将曲线点转换为参数描述，格式：`"(x, y), (x, y), ..."`
   - **【修复3】** 添加参数：将解析后的曲线参数添加到 `params` 数组，而不是空数组
   - **【新增】** 添加详细的日志记录，追踪PS曲线数据的提取和创建过程

7. **Prompt 模板修复**（`server_py/app/services/prompt_template.py`）：
   - **【修复3】** 更新 `ps_curves_adjustment` 字段：要求 Gemini 返回曲线点数据
     - 添加 `rgb_points`：RGB 曲线坐标点数组
     - 添加 `red_channel`：红色通道曲线坐标点数组
     - 添加 `green_channel`：绿色通道曲线坐标点数组
     - 添加 `blue_channel`：蓝色通道曲线坐标点数组

**实现位置**：
- `src/components/sections/LightroomSection.tsx`：`parseCurveParams` 函数、`extractCurvePoints` 函数、渲染逻辑
- `src/components/sections/PhotoshopSection.tsx`：导入 `CurveVisualizationLR`、`parseCurveParams`、`extractCurvePoints`，更新渲染逻辑
- `src/components/CurveVisualizationLR.tsx`：`createPath` 函数（使用 Catmull-Rom 样条曲线算法）、调试日志
- `server_py/app/services/analysis_formatter.py`：`_format_lightroom` 方法（第 1604-1665 行）、`_format_photoshop` 方法（第 1940-2000 行）
- `server_py/app/services/prompt_template.py`：`ps_curves_adjustment` 字段定义（第 395-402 行）

**注意事项**：
- RGB曲线数据存储在 `curveData.luma` 数组中，前端使用 `CurveVisualizationLR` 组件渲染
- 曲线点坐标格式：后端发送 `"(0, 0), (128, 125), (255, 255)"`，前端解析为多个点对象
- 曲线绘制算法：使用 Catmull-Rom 样条曲线（三次贝塞尔曲线），确保曲线通过所有控制点且平滑
- 如果点数量少于2个，不绘制曲线；如果点数量为2个，使用直线连接；如果点数量为3个或更多，使用平滑曲线
- 调试日志会记录每个通道的 points 数量、解析后的点、最终的点，便于排查问题
- **一致性检查**：Lightroom 和 Photoshop 使用相同的曲线解析和绘制逻辑，确保用户体验一致
- **向后兼容**：后端支持多种可能的字段名（`rgb_points`、`points_rgb`、`rgb_curve_points` 等），确保兼容性
- **【重要】Python 字符串格式化错误修复**：
  - **问题**：在日志语句中使用普通字符串（非 f-string）但包含 `{variable}` 时，Python 会将其解析为格式化占位符
  - **错误示例**：`logger.warning("tone_curve_points = {tone_curve_points}")` - 当 `tone_curve_points` 包含 JSON 格式数据（如 `[{"x": 0, "y": 0}]`）时，会导致 `Invalid format specifier '0, "y": 0'` 错误
  - **修复方法**：
    1. 使用 f-string：`logger.warning(f"tone_curve_points = {tone_curve_points}")`
    2. 使用 `repr()` 安全输出：`logger.warning(f"tone_curve_points = {repr(tone_curve_points)}")`
    3. 使用双花括号转义：`logger.warning("tone_curve_points = {{tone_curve_points}}".format(tone_curve_points=tone_curve_points))`
  - **规范**：所有日志语句必须使用 f-string 或正确转义花括号，避免字符串格式化错误
- **【重要】曲线点数据格式兼容性修复**：
  - **问题**：`_format_lightroom` 方法在处理 `tone_curve_points` 时，假设数据是数组格式 `[[x, y], ...]`，但 Gemini 可能返回对象格式 `[{"x": 0, "y": 0}, ...]`
  - **错误位置**：`server_py/app/services/analysis_formatter.py` 第 2786 行和第 3109 行
  - **错误示例**：`points_str = ", ".join([f"({p[0]}, {p[1]})" for p in tone_curve_points[:5]])` - 当 `p` 是字典格式 `{"x": 0, "y": 0}` 时，访问 `p[0]` 会出错
  - **修复方法**：
    1. 在提取 `rgb_points` 时，检查第一个点的格式，如果是对象格式则转换为数组格式
    2. 同样处理单通道曲线（red_channel, green_channel, blue_channel）
    3. 统一转换为数组格式后，后续代码可以直接访问 `p[0]` 和 `p[1]`
  - **修复位置**：
    - `server_py/app/services/analysis_formatter.py` 第 2785-2819 行：添加 `normalize_channel_points` 函数，统一转换曲线点格式
    - `server_py/app/services/analysis_formatter.py` 第 3106-3122 行：简化代码，直接访问 `p[0]` 和 `p[1]`（因为已经统一转换为数组格式）
  - **规范**：所有处理曲线点数据的代码必须兼容数组格式 `[x, y]` 和对象格式 `{"x": 0, "y": 0}`，并在处理前统一转换为数组格式
- **【重要】f-string 包含 JSON 模板格式化错误修复**：
  - **问题**：在 `prompt_template.py` 的 `get_part1_prompt`、`get_part2_prompt`、`get_diagnosis_prompt` 方法中，使用 f-string 但包含 JSON 模板（如 `{PART1_TEMPLATE}`）时，Python 会解析模板中的 JSON 格式数据（如 `{"x": 0, "y": 0}`）作为格式化占位符，导致 `Invalid format specifier '0, "y": 0'` 错误
  - **错误位置**：`server_py/app/services/prompt_template.py` 第 723 行、第 819 行、第 924 行，以及第 476-520 行的 JSON 示例
  - **错误示例**：
    1. `prompt = f"""... {PART1_TEMPLATE} ..."""` - 当 `PART1_TEMPLATE` 包含 `{"x": 0, "y": 0}` 时，Python 会尝试解析 `"x": 0, "y": 0` 作为格式化占位符
    2. `{"x": 0, "y": 0}` - 在 f-string 中，这会被解析为格式化占位符，导致错误
  - **修复方法**：
    1. **模板插入修复**：将 `{PART1_TEMPLATE}` 改为字符串拼接 `""" + PART1_TEMPLATE + """`，避免 f-string 解析
    2. **JSON 示例转义修复**：将 prompt 字符串中的 JSON 示例（如 `{"x": 0, "y": 0}`）改为双花括号转义（如 `{{"x": 0, "y": 0}}`）
  - **修复位置**：
    - `server_py/app/services/prompt_template.py` 第 406-765 行：`get_part1_prompt` 方法
      - 第 723 行：将 `{PART1_TEMPLATE}` 改为 `""" + PART1_TEMPLATE + """`
      - 第 476-520 行：将所有 JSON 示例中的单花括号改为双花括号转义
    - `server_py/app/services/prompt_template.py` 第 790-822 行：`get_part2_prompt` 方法
      - 第 819 行：将 `{PART2_TEMPLATE}` 改为 `""" + PART2_TEMPLATE + """`
    - `server_py/app/services/prompt_template.py` 第 912-927 行：`get_diagnosis_prompt` 方法
      - 第 924 行：将 `{DIAGNOSIS_TEMPLATE}` 改为 `""" + DIAGNOSIS_TEMPLATE + """`
  - **规范**：
    1. 在 f-string 中插入包含 JSON 格式数据的模板时，必须使用字符串拼接而不是变量插值
    2. 在 f-string 中包含 JSON 格式示例时，必须使用双花括号 `{{}}` 转义
    3. 所有日志语句必须使用 f-string 或正确转义花括号，避免字符串格式化错误
- **【重要】立即执行函数（IIFE）语法规范**：
  - 在 JSX 中使用立即执行函数时，必须正确闭合，格式为：`{(() => { ... return (...); })()}`
  - 如果缺少闭合括号 `})()`，会导致"Unterminated regexp literal"语法错误
  - 错误示例：`{(() => { ... return (...) )}`（缺少 `})()`）
  - 正确示例：`{(() => { ... return (...); })()}`
  - 在 `PhotoshopSection.tsx` 中已修复此问题，其他文件（`LightroomSection.tsx`、`ReviewSection.tsx`、`PDFPreview.tsx`）已确认正确

#### 16.4 第三阶段风格模拟功能开发（Part3）

**需求**：用户点击"风格模拟"进入第三阶段，将两张图（参考图和用户图）+ 阶段一与阶段二的输出（照片点评尤其是 style_summary、色彩方案、Lightroom、Photoshop）递交给 Gemini 3 Pro 图片生成模型，输出对应的完成调色的图片（4K）。

**实现方案**：

1. **数据提取**（`StyleSimulationService.extract_color_grading_schema`）：
   - 从 `structured_result` 中提取完整的 Part1/Part2 数据
   - **照片点评完整数据**：从 `sections.photoReview.structured` 提取，包括：
     - `style_summary`：**风格克隆战略指导（最重要的字段）**，包含内容策略、影调重塑、色彩映射
     - `overviewSummary`：整体概览
     - `dimensions`：各维度分析（视觉引导、焦点曝光、色彩景深等）
     - `comparisonTable`：参数对比表
     - `feasibility`：可行性评估
   - **Lightroom 完整数据**：从 `sections.lightroom.structured` 提取（panels、toneCurve、rgbCurves、colorGrading）
   - **Photoshop 完整数据**：从 `sections.photoshop.structured` 提取（steps）
   - **色彩方案完整数据**：从 `sections.color.structured` 提取（whiteBalance、grading、hsl）

   **【重要】变量命名规范**（修复 `photo_review_data` 未定义错误）：
   - **问题**：在 `extract_color_grading_schema` 方法中，`photo_review_data` 变量在使用前未正确定义，导致 `name 'photo_review_data' is not defined` 错误。
   - **根本原因**：变量在使用前未初始化，导致在构建 `color_grading_schema` 字典时引用未定义的变量。
   - **修复方案**：
     1. **正确定义变量**：在方法开始处初始化 `photo_review_data = {}`（空字典）
     2. **提取数据**：从 `sections.get("photoReview", {})` 中提取 `structured` 数据
     3. **构建字典**：在 `if photo_review:` 条件块内构建完整的 `photo_review_data` 字典
     4. **使用变量**：在构建 `color_grading_schema` 时使用已定义的 `photo_review_data` 变量
   - **修复位置**：`server_py/app/services/style_simulation_service.py` 第 175-203 行
   - **注意事项**：
     - 必须在使用变量前正确定义和初始化
     - 即使 `photoReview` 数据不存在，也要使用空字典，避免后续代码报错
     - 添加详细的中文注释和日志记录，便于调试和排查问题

2. **Prompt 模板更新**（`PromptTemplateService.get_part3_flash_prompt`）：
   - 使用新的 Prompt 模板，包含详细的角色设定、处理指令和约束
   - **输入数据包括**（根据用户需求）：
     - 用户原图、参考图（两张图片）
     - 照片点评（尤其是 `style_summary` 字段的详细说明）
     - 色彩方案、Lightroom、Photoshop 的完整 JSON 数据
   - 处理指令分为三个步骤：基础影调重塑、色彩分级、质感与氛围
   - 负向约束明确禁止改变构图、人物特征、添加新物体等
   - 输出要求：4K 分辨率（3840x2160 或更高），保持原始宽高比，JPEG 高质量格式

3. **图片传递**（`StyleSimulationService.simulate_style`）：
   - 接收两张图片：参考图（`reference_image_data`）和用户原图（`user_image_data`）
   - 构建 `contents` 数组，顺序为：参考图、用户图、Prompt 文本
   - Gemini API 支持多张图片输入，可以同时传递参考图和用户图

4. **模型选择策略**（`GeminiService.generate_image`）：
   - **优先使用 Gemini 3 Pro 图片生成模型（gemini-3-pro-image-preview）**：
     - **确认**：根据 [Google Gemini API 文档](https://ai.google.dev/gemini-api/docs/image-generation?hl=zh-cn&batch=file)，Gemini 3 Pro 图片预览版支持图片生成，可生成分辨率高达 4K 的图像
     - 优点：更强的理解能力，能更好地理解复杂的色彩方案和风格分析；支持 4K 输出；使用 Google 搜索进行现实世界知识的接地；默认的"思考"过程（在生成之前优化构图）
     - 缺点：延迟时间相对较高（高级功能需要更多计算资源）
   - **回退到 Gemini 2.5 Flash Image（gemini-2.5-flash-image）**：
     - 如果 Gemini 3 Pro 图片生成模型调用失败，自动回退到 `gemini-2.5-flash-image`
     - 优点：明确支持图片生成，速度快，成本低；针对大批量、低延迟任务优化
     - 缺点：分辨率较低（1024 像素），理解能力相对较弱
   - **实现方式**：通过 `use_gemini3_pro` 参数控制，失败时自动回退
   - **配置**：在 `config.py` 中新增 `GEMINI_IMAGE_MODEL` 环境变量，默认值为 `"gemini-3-pro-image-preview"`

5. **接口更新**（`POST /api/simulate/style`）：
   - 检查参考图和用户图数据是否存在
   - 调用 `extract_color_grading_schema` 提取完整的色彩方案数据（包括照片点评、Lightroom、Photoshop、色彩方案）
   - 传递两张图片和完整的色彩方案数据给 `simulate_style` 方法

**实现位置**：
- `server_py/app/services/prompt_template.py`：`get_part3_flash_prompt` 方法（第 468-637 行）
- `server_py/app/services/style_simulation_service.py`：`extract_color_grading_schema` 方法（第 132-234 行）、`simulate_style` 方法（第 28-130 行）
- `server_py/app/services/gemini_service.py`：`generate_image` 方法（第 192-327 行）、`get_gemini_service` 函数（第 364-375 行）
- `server_py/app/routes/simulate.py`：`simulate_style` 接口（第 28-105 行）
- `server_py/app/config.py`：新增 `GEMINI_IMAGE_MODEL` 配置项（第 50 行）

**注意事项**：
- **Gemini 3 Pro 图片生成模型确认**：根据 Google 官方文档，`gemini-3-pro-image-preview` 支持图片生成，可生成分辨率高达 4K 的图像
- **输入数据完整性**：必须包含照片点评（尤其是 `style_summary`）、色彩方案、Lightroom、Photoshop 的完整数据
- **输出分辨率**：要求 4K（3840x2160 或更高），但需要根据实际 API 文档确认是否支持直接指定分辨率
- **两张图片的传递顺序**：参考图在前，用户图在后，Prompt 文本在最后
- **完整的色彩方案数据以 JSON 格式嵌入 Prompt 中**，确保 Gemini 能理解所有调整参数
- **模型回退机制**：如果 Gemini 3 Pro 图片生成模型调用失败，会自动回退到 Flash 模型，确保功能可用性
- **【重要】类型转换规范**（修复 `startswith` 类型错误）：
  - **问题**：`generate_image` 方法可能返回 bytes 类型的数据，而不是字符串，导致在 `style_simulation_service.py` 中调用 `startswith("data:image")` 时出现 `startswith first arg must be bytes or a tuple of bytes, not str` 错误
  - **根本原因**：Google Gemini API 的 `inline_data.data` 字段可能返回 bytes 或字符串，取决于 SDK 版本和响应格式
  - **修复方案**：
    1. **在 `generate_image` 方法中添加类型检查和转换**：
       - 检查 `inline_data.data` 的类型（bytes 或字符串）
       - 如果是 bytes，使用 `decode('utf-8')` 转换为字符串
       - 如果 UTF-8 解码失败，使用 `base64.b64encode().decode('utf-8')` 进行二次编码转换
       - 确保所有返回路径都返回字符串类型
    2. **在 `style_simulation_service.py` 中添加类型检查**：
       - 在调用 `startswith` 之前，检查 `processed_image_base64` 的类型
       - 如果是 bytes，先转换为字符串
    3. **在 `save_image_to_local` 函数中添加类型检查**：
       - 确保接收的参数是字符串类型，如果是 bytes 则先转换
       - 因为 `base64.b64decode` 期望接收字符串类型
  - **修复位置**：
    - `server_py/app/services/gemini_service.py`：`generate_image` 方法（第 372-409 行）、`save_image_to_local` 函数（第 310-338 行）
    - `server_py/app/services/style_simulation_service.py`：`simulate_style` 方法（第 118-137 行）
  - **注意事项**：
    - 所有 Base64 数据必须统一为字符串类型，便于后续处理和传输
    - 添加详细的类型检查和日志记录，便于排查问题
    - 确保类型转换不会导致数据丢失或损坏

#### 16.5 Part3 图片顺序混淆问题修复（第三次修复）

**问题**：Gemini 仿色搞反了，用户反馈"右边是用户图，没有做任何变更，但是左边是参考图，却加深了效果"。这说明 Gemini 可能处理了错误的图片（处理了参考图而不是用户原图），或者返回了错误的图片。

**根本原因**：
1. **Prompt 中图片标记不够明确**：虽然代码传递顺序正确（第一张=参考图，第二张=用户原图），但 Prompt 文本中的标记可能不够醒目，Gemini 在多模态输入时可能无法正确识别图片顺序
2. **图片与文本分离**：Gemini API 的 `contents` 中，图片和文本是分开的 parts，Gemini 可能无法准确关联图片和文本描述
3. **缺少图片级别的标记**：在图片数据本身没有明确的文本标记，只能依靠 Prompt 文本中的描述，但文本描述可能不够醒目
4. **【新增原因】处理步骤中未明确说明处理对象**：虽然 Prompt 开头和结尾都强调了图片顺序，但在具体的处理步骤（Step 1、Step 2、Step 3）中，没有明确说明"对第二张图片（用户原图）进行以下调整"，导致 Gemini 在处理时可能混淆了处理对象

**修复方案**：
1. **在 contents 中添加图片级别的文本标记**（`server_py/app/services/style_simulation_service.py` - `simulate_style` 方法）：
   - **第一张图片前添加文本标记**：`{"text": "【第一张图片 = 参考图 (Reference Image)】这是目标风格图，仅用于参考，不直接处理。\n"}`
   - **第二张图片前添加文本标记**：`{"text": "\n【第二张图片 = 用户原图 (User Image / Source Image)】这是需要处理的图片，必须按照参考图的风格进行调色。\n"}`
   - **确保图片与标记紧密关联**：文本标记紧贴在图片数据之前，确保 Gemini 能正确识别每张图片的作用

2. **强化 Prompt 模板开头的图片顺序说明**（`server_py/app/services/prompt_template.py` - `get_part3_flash_prompt` 方法）：
   - **在 Prompt 开头用最醒目的方式标注**：使用 `⚠️⚠️⚠️` 标记和加粗文本，确保 Gemini 首先看到图片顺序说明
   - **多重确认机制**：在 Role、Input Data、Processing Instructions、Output Goal 等多个位置重复强调图片顺序
   - **最后确认环节**：在 Output Goal 部分添加"【最后确认】图片处理对象"，再次明确处理哪张图片

3. **【新增】在每个处理步骤中明确说明处理对象**（`server_py/app/services/prompt_template.py` - `get_part3_flash_prompt` 方法）：
   - **Step 1 标题**：添加"对第二张图片（用户原图）进行调整"
   - **Step 1 内容**：每个调整项都明确说明"对第二张图片（用户原图）进行..."
   - **Step 2 标题**：添加"对第二张图片（用户原图）进行调整"
   - **Step 2 内容**：每个调整项都明确说明"对第二张图片（用户原图）进行..."
   - **Step 3 标题**：添加"对第二张图片（用户原图）进行调整"
   - **Step 3 内容**：每个调整项都明确说明"对第二张图片（用户原图）进行..."
   - **确保每个步骤都明确说明处理对象**，避免 Gemini 在处理时混淆

4. **添加详细的日志记录**（`server_py/app/services/style_simulation_service.py`）：
   - **记录图片顺序确认**：`logger.info(f"【Part3 风格模拟】✅ 图片顺序确认：第一张 = 参考图，第二张 = 用户原图")`
   - **记录图片 Base64 前缀**：记录参考图和用户原图的 Base64 前缀（前 50 个字符），用于识别图片
   - **记录 contents 结构**：记录每个 part 的类型（图片或文本）和位置，确保图片顺序正确
   - **检查 Prompt 内容**：检查 Prompt 中是否包含"对第二张图片"的关键词，如果没有则记录警告
   - **图片大小对比**：对比返回的图片和输入的图片大小，如果大小相似（差异 < 10%），记录警告
   - **图片前缀对比**：对比处理后图片和用户原图的 Base64 前缀，如果相同则记录警告，可能 Gemini 没有处理或返回了错误的图片

5. **前端添加调试日志**（`src/components/StyleSimulation.tsx` - `handleSimulate` 函数）：
   - **记录接收到的结果**：包括 `originalImage` 和 `processedImage` 的长度
   - **验证处理结果**：检查 `processedImage` 是否与 `originalImage` 相同，如果相同则记录警告

**实现位置**：
- `server_py/app/services/style_simulation_service.py`：`simulate_style` 方法（第 108-147 行）
- `server_py/app/services/prompt_template.py`：`get_part3_flash_prompt` 方法（第 694-728 行）
- `src/components/StyleSimulation.tsx`：`handleSimulate` 函数（第 27-46 行）

**注意事项**：
- **图片顺序必须在 Prompt 的多个位置明确标记**，避免 Gemini 混淆
- **代码传递顺序与 Prompt 描述必须一致**：第一张=参考图，第二张=用户原图
- **在 contents 中添加图片级别的文本标记**，确保 Gemini 能正确识别每张图片的作用
- **【重要】在每个处理步骤中明确说明处理对象**，确保 Gemini 知道要对哪张图片进行调整
- **添加详细的日志记录**，包括图片前缀、Prompt 检查、大小对比等，便于排查问题
- **前端添加调试日志**，验证处理结果是否正确

#### 16.6 Part2 任务失败原因显示问题修复

**问题**：用户点击"查看详细方案"后，Part2 任务失败，前端显示"未知原因"，无法获取具体的失败信息。

**根本原因**：
1. **AnalysisTask 模型缺少 `status_reason` 字段**：虽然代码中尝试使用 `status_reason` 记录失败原因，但数据库模型中没有这个字段，导致失败原因无法保存到数据库。
2. **update_task_status 方法未保存 status_reason**：虽然方法接收了 `status_reason` 参数，但代码中注释说"当前 AnalysisTask 模型中没有 status_reason 字段"，所以没有实际保存。
3. **前端显示"未知原因"**：前端在获取任务状态时，如果 `status_reason` 为空或不存在，就会显示"未知原因"或"未知错误"。
4. **错误日志可能不完整**：某些错误可能没有被正确捕获或记录，导致无法追踪失败原因。

**修复方案**：
1. **在 AnalysisTask 模型中添加 `status_reason` 字段**（`server_py/app/models.py`）：
   - 添加 `status_reason = Column(Text, nullable=True)` 字段
   - 用于记录任务失败原因（可选，通常用于失败时记录错误信息）

2. **修复 `update_task_status` 方法**（`server_py/app/services/task_service.py`）：
   - 移除注释，实际保存 `status_reason` 到数据库
   - 如果状态是 `failed` 但没有提供原因，设置默认原因："任务执行失败，具体原因请查看日志"
   - 如果状态不是 `failed`，清空 `status_reason`（避免显示旧的失败原因）

3. **增强 Part2 后台任务的错误处理**（`server_py/app/routes/analyze.py` - `_run_part2_analysis_job` 方法）：
   - 记录详细的错误信息，包括错误类型、错误消息、堆栈跟踪
   - 构建详细的失败原因：`f"Part2 后台分析失败: {error_type}: {error_message}"`
   - 如果错误消息过长，截取前 500 个字符（避免数据库字段过长）
   - 确保任务状态被更新为失败，并记录详细的失败原因

4. **增强日志记录**（`server_py/app/routes/analyze.py`）：
   - 在任务开始时记录任务基本信息（taskId、userId、当前状态、是否有源图/目标图）
   - 如果任务不存在，尝试更新任务状态为失败（虽然任务不存在，但为了前端能获取到错误信息）
   - 在 `get_task` 接口中，如果任务失败，记录警告日志

5. **前端错误处理**（`src/components/ThemeCardsGrid.tsx`）：
   - 前端已经正确显示 `status_reason`，如果为空则显示"未知错误"
   - 无需修改前端代码，只需确保后端正确返回 `status_reason` 字段

**实现位置**：
- `server_py/app/models.py`：`AnalysisTask` 模型（第 89 行）
- `server_py/app/services/task_service.py`：`update_task_status` 方法（第 235-260 行）
- `server_py/app/routes/analyze.py`：`_run_part2_analysis_job` 方法（第 498-795 行）、`get_task` 接口（第 798-845 行）

**注意事项**：
- **数据库迁移**：由于添加了新字段，如果使用 SQLite，字段会自动添加；如果使用 MySQL，可能需要手动添加字段或使用 Alembic 迁移。
- **向后兼容**：如果数据库中已有任务记录，`status_reason` 字段将为 `NULL`，不影响现有功能。
- **错误消息长度限制**：`status_reason` 字段使用 `Text` 类型，理论上可以存储很长的文本，但为了前端显示友好，建议限制在 500 字符以内。
- **错误日志完整性**：所有错误都应该被正确捕获和记录，包括任务不存在、数据库更新失败、Gemini API 调用失败等。

#### 16.7 Part3 风格模拟 sqlite3.OperationError 修复

**问题**：Part3 风格模拟接口返回 `sqlite3.OperationError`，错误信息为 `"风格模拟失败: (sqlite3.Operati"`（消息被截断）。

**根本原因**：
1. **`update_preview_image` 方法未使用 `flag_modified`**：在修改 `structured_result` JSON 字段时，直接修改嵌套字典（`task.structured_result["sections"]["preview_image_url"]`），但没有使用 `flag_modified` 标记字段已修改。
2. **SQLAlchemy JSON 字段特性**：SQLAlchemy 的 JSON 字段在直接修改嵌套字典时，可能无法自动检测到变更，导致在 `db.commit()` 时出现 `sqlite3.OperationError`。
3. **`archive_service.py` 中也有类似问题**：`archive_old_tasks` 方法中直接修改 `structured_result` 时也没有使用 `flag_modified`。

**修复方案**：
1. **修复 `update_preview_image` 方法**（`server_py/app/services/task_service.py`）：
   - 使用深拷贝（`copy.deepcopy`）修改嵌套字典，然后重新赋值给 `task.structured_result`
   - 使用 `flag_modified(task, "structured_result")` 标记 JSON 字段已修改
   - 添加详细的中文注释，说明为什么需要使用 `flag_modified`
   - 添加日志记录，记录预览图 URL 更新成功

2. **修复 `archive_service.py`**（`server_py/app/services/archive_service.py`）：
   - 在文件顶部导入 `copy` 和 `flag_modified`
   - 修复 `archive_old_tasks` 方法中修改 `structured_result` 的逻辑，使用深拷贝和 `flag_modified`
   - 添加详细的中文注释

3. **增强 `simulate_style` 接口的错误处理**（`server_py/app/routes/simulate.py`）：
   - 在调用 `update_preview_image` 时添加 try-except 块
   - 如果数据库更新失败，记录详细错误信息，但不影响接口返回（因为图片已生成成功）
   - 增强异常处理，记录错误类型和错误消息

**实现位置**：
- `server_py/app/services/task_service.py`：`update_preview_image` 方法（第 222-253 行）
- `server_py/app/services/archive_service.py`：`archive_old_tasks` 方法（第 70-85 行）
- `server_py/app/routes/simulate.py`：`simulate_style` 接口（第 118-126 行）

**注意事项**：
- **SQLAlchemy JSON 字段修改规范**：修改 JSON 字段的嵌套字典时，必须使用 `flag_modified` 标记，确保 SQLAlchemy 能检测到变更
- **深拷贝的重要性**：使用 `copy.deepcopy` 创建新的字典对象，然后重新赋值，避免直接修改原字典导致 SQLAlchemy 无法检测变更
- **错误处理策略**：如果数据库更新失败但图片已生成成功，不抛出异常，允许接口正常返回结果（前端可以正常显示图片）
- **一致性检查**：所有修改 JSON 字段的地方都必须使用 `flag_modified`，包括：
  - `update_task_part1`：已正确使用
  - `update_task_part2`：已正确使用
  - `update_preview_image`：已修复
  - `archive_old_tasks`：已修复

#### 16.8 数据库表结构迁移问题修复（status_reason 字段缺失）

**问题**：Part1 分析接口返回 `sqlite3.OperationalError`，错误信息为 `table analysis_tasks has no column named status_reason`。

**根本原因**：
1. **数据库表结构未更新**：虽然 `AnalysisTask` 模型（`server_py/app/models.py`）中已经定义了 `status_reason` 字段，但实际的数据库表（`analysis_tasks`）中还没有这个字段。
2. **`Base.metadata.create_all()` 的限制**：`Base.metadata.create_all(bind=engine)` 只会创建**不存在的表**，不会修改已存在的表结构（不会添加新字段）。
3. **缺少数据库迁移机制**：开发环境没有使用 Alembic 迁移工具，导致模型变更后数据库表结构没有同步更新。

**修复方案**：
1. **创建数据库迁移服务**（`server_py/app/services/db_migration.py`）：
   - 实现 `check_and_add_column` 函数：检查表是否存在指定列，如果不存在则添加
   - 支持 SQLite 和 MySQL 数据库（使用不同的 `ALTER TABLE` 语法）
   - 实现 `migrate_database` 函数：在应用启动时自动检查并添加缺失的字段
   - 当前迁移内容：检查并添加 `analysis_tasks.status_reason` 字段（`TEXT` 类型，允许 `NULL`）

2. **在应用启动时调用迁移**（`server_py/app/main.py`）：
   - 在 `create_app` 函数中，在 `Base.metadata.create_all(bind=engine)` 之后调用 `migrate_database()`
   - 使用 try-except 块包裹，确保迁移失败不会中断应用启动
   - 添加详细的中文注释，说明这是开发环境的临时方案，生产环境应使用 Alembic

3. **增强日志记录**：
   - 迁移过程中记录详细的日志，包括检查结果、添加结果、错误信息
   - 使用 `logger.info` 记录成功操作，使用 `logger.error` 记录失败操作

**实现位置**：
- `server_py/app/services/db_migration.py`：数据库迁移服务（新建文件）
- `server_py/app/main.py`：`create_app` 函数（第 32 行之后）

**注意事项**：
- **开发环境方案**：此迁移服务仅用于开发环境，生产环境必须使用 Alembic 进行数据库迁移管理
- **向后兼容**：如果字段已存在，会跳过添加，不会报错
- **错误处理**：迁移失败不会中断应用启动，只记录错误日志
- **数据库类型支持**：当前支持 SQLite 和 MySQL，其他数据库类型需要扩展 `check_and_add_column` 函数
- **字段类型映射**：SQLite 的 `TEXT` 类型对应 MySQL 的 `TEXT` 类型，其他类型需要根据数据库类型调整
- **生产环境迁移**：生产环境必须使用 Alembic 生成迁移脚本（`alembic revision --autogenerate -m "Add status_reason field"`），然后应用迁移（`alembic upgrade head`）

#### 16.9 Part3 图片生成日志缺失问题修复

**问题**：用户反馈 Part3 风格模拟功能似乎没有生成图片，日志中没有找到任何 Part3 相关的日志，`part3_generated_images` 目录为空。

**根本原因**：
1. **日志记录不够详细**：虽然代码中有日志记录，但可能因为日志级别或日志文件被清空，导致无法追踪到 Part3 的调用过程
2. **`save_image_to_local` 调用缺少错误处理**：如果保存图片失败，可能没有记录错误日志，导致无法排查问题
3. **接口入口缺少日志**：`/api/simulate/style` 接口入口没有明显的日志标记，难以在日志中定位

**修复方案**：
1. **增强接口入口日志**（`server_py/app/routes/simulate.py`）：
   - 在接口入口添加醒目的分隔线和时间戳
   - 记录任务 ID、用户 ID、请求时间等关键信息
   - 确保日志级别为 `INFO`，不会被过滤

2. **增强风格模拟服务日志**（`server_py/app/services/style_simulation_service.py`）：
   - 在调用 Gemini API 前后添加详细日志
   - 记录 Contents 结构和 parts 数量
   - 添加 try-except 块，确保 Gemini API 调用失败时记录详细错误信息

3. **增强 Gemini 服务日志**（`server_py/app/services/gemini_service.py`）：
   - 在 `generate_image` 方法入口添加醒目的分隔线和时间戳
   - 在调用 Gemini API 前后记录详细信息（模型名称、Contents 结构、parts 数量）
   - 在 `save_image_to_local` 调用前后添加日志，记录保存成功或失败
   - 为所有 `save_image_to_local` 调用添加 try-except 块，确保保存失败不影响功能，但会记录错误日志

**实现位置**：
- `server_py/app/routes/simulate.py`：`simulate_style` 接口（第 86-88 行）
- `server_py/app/services/style_simulation_service.py`：`simulate_style` 方法（第 135-140 行）
- `server_py/app/services/gemini_service.py`：`generate_image` 方法（第 250-251 行、第 420-425 行、第 450-453 行、第 473-476 行）

**注意事项**：
- **日志级别**：所有关键日志都使用 `logger.info`，确保不会被过滤
- **日志格式**：使用醒目的分隔线（`=========================================`）和时间戳，便于在日志中定位
- **错误处理**：`save_image_to_local` 调用失败不会影响功能，但会记录警告日志
- **日志文件位置**：所有日志都会写入 `/tmp/backend_8081.log`（根据 `run.py` 的配置）
- **查看日志方法**：
  - 实时查看：`tail -f /tmp/backend_8081.log | grep "Part3"`
  - 查看图片保存日志：`grep "图片已保存到本地文件" /tmp/backend_8081.log`
  - 查看完整 Part3 流程：`grep -A 5 "Part3" /tmp/backend_8081.log`

#### 16.10 直方图数据来源说明

**问题**：LR 和 PS 中有一个直方图，想知道目前前端展示的直方图是硬编码还是通过 Gemini 输出的数据渲染生成的。

**答案**：
- **直方图是前端通过 Canvas API 实时计算生成的，不是硬编码，也不是 Gemini 输出的数据**
- **实现方式**（`Histogram.tsx`）：
  1. 加载图片到 Canvas
  2. 使用 `getImageData` 获取像素数据
  3. 遍历像素计算 RGB 分布（R、G、B 三个通道的直方图）
  4. 使用 Canvas API 绘制直方图
- **数据来源**：基于实际图片像素计算，不是 Gemini 输出的数据
- **根据开发方案第 18 节**：所有直方图（参考图、用户图、仿色后示意图）必须由前端通过 Canvas 计算，后端/Prompt 不负责输出 256 维 bins 等高精度直方图数据

- **后端任务状态机**（`analysis_tasks.status`）：
  - `pending`：任务刚创建，未开始分析。
  - `part1_completed`：第一阶段分析完成，结构化结果已可用。
  - `processing`：第二阶段/风格模拟等长任务进行中。
  - `completed`：全部阶段（Part1+Part2+Part3）完成。
  - `failed`：任务失败，`status_reason` 字段给出简要失败原因。
- **前端状态与轮询**：
  - Stage1：
    - 点击“开始分析”→ 调用 `analyzePart1()` → 进入全屏 Loading。
    - 控制台/组件状态：`analysisStage = 'loading_part1'`，完成后设为 `'stage1'`。
  - Stage2：
    - 点击"查看详细方案"等按钮→ 调用 `analyzePart2(taskId)`。
    - **服务立即返回 `{ status: 'processing' }`**（根据开发方案第 16 节，Part2 接口应立即返回，不等待 Gemini API 调用完成）。
    - 前端收到 `{ status: 'processing' }` 后立刻开始轮询 `getAnalysis(taskId)`：
      - 轮询间隔：3 秒。
      - 最大轮询时长：建议 2 分钟（前端维护超时计时器）。
      - 接收到 `status === 'completed'` 后停止轮询，展示 Stage2 内容。
      - 若超过最大时长仍未完成：显示"分析时间过长，请稍后在历史中查看"提示，并停止轮询。
    - **后端实现**：
      - `POST /api/analyze/part2` 接口立即返回 `{ status: 'processing' }`，不等待 Gemini API 调用
      - 实际的 Gemini 调用、数据格式化、数据库更新在后台异步执行（`_run_part2_analysis_job` 函数）
      - 后台任务开始时将任务状态设置为 `processing`，完成时设置为 `completed`，失败时设置为 `failed`
      - 前端通过轮询 `GET /api/analyze/{taskId}` 获取最终结果
      - **日志记录**：
        - 接口入口记录请求接收时间、用户验证耗时、响应时间
        - 后台任务记录每个关键步骤的耗时（获取任务、设置状态、调用 Gemini、格式化、更新数据库）
        - 记录任务完成时间或失败时间，以及详细的错误信息
        - 前端在 Console 中记录 Part2 接口调用、轮询状态、任务完成/失败信息
      - **错误处理**：
        - 如果后台任务失败，任务状态会被设置为 `failed`，并记录失败原因到 `status_reason` 字段
        - `GET /api/analyze/{taskId}` 接口返回 `status_reason` 字段（如果任务失败）
        - 前端轮询时检测到 `status === 'failed'`，会显示错误提示并停止轮询
  - 风格模拟：
    - 若与 Part2 串行：不单独轮询，由 `status === 'completed'` 时一并返回 `preview_image_url`。
    - 若单独接口：`simulateStyle(taskId)` → `status: 'processing'` → 前端轮询直到返回结果或超时。
  - **超时与防多次点击**：
    - **前端超时设置**：
      - Part1 分析接口前端超时设置为 200 秒（3分20秒），确保覆盖后端 180 秒超时，并留出网络延迟缓冲。
      - 如果 Gemini API 响应时间较长（如 Part1 可能达到 60-70 秒），前端超时时间足够。
      - 如果超时，前端会显示友好的错误提示："Part1 分析请求超时（超过 3 分20秒），请稍后重试"。
      - AI 诊断接口前端超时设置为 180 秒（3 分钟），与后端超时保持一致。
    - **后端超时设置**：
      - Gemini API 调用超时时间从 `GEMINI_TIMEOUT_MS` 配置读取，默认 180 秒（3 分钟）。
      - 使用 `ThreadPoolExecutor` 实现超时控制，如果超时会抛出 `TimeoutError`。
      - 超时信息会记录在日志中，便于排查问题。
      - 【重要】根据实际测试，Part1 分析可能需要 60-70 秒，AI 诊断可能需要 70+ 秒，考虑到网络延迟和 Gemini API 响应时间波动，设置为 180 秒以确保稳定性。
    - **防多次点击机制**：
      - 前端使用 `isAnalyzing` 状态标记是否正在分析。
      - 在 `handleAnalyze` 和 `handleFeasibilityContinue` 函数开始时检查 `isAnalyzing`，如果正在分析则直接返回。
      - 按钮设置 `disabled={!canAnalyze}`，其中 `canAnalyze = sourceImage && targetImage && !isAnalyzing`。
      - 在请求开始时设置 `setIsAnalyzing(true)`，在请求完成或失败时设置 `setIsAnalyzing(false)`。
      - **重要**：可行性评估完成后，必须清除 `isAnalyzing` 状态，让 `FeasibilityDialog` 显示出来（因为 `AnalysisLoading` 的 z-index 是 9999，会遮挡对话框）。
      - 在可行性评估对话框关闭时也会清除 `isAnalyzing` 状态，允许用户重新开始。
    - **模态框层级（z-index）管理**：
      - **普通页面内容**：`z-index < 100`（页面基础内容）
      - **Toast 消息**：`z-index = 9998`（低于所有模态框，避免遮挡用户交互）
        - **原因**：sonner toast 默认使用非常高的 z-index（2147483647），需要通过 CSS 和 `toastOptions` 配置覆盖
        - **实现**：在 `src/components/ui/sonner.tsx` 中设置 `toastOptions.style.zIndex = 9998`，并在 `src/index.css` 中添加 CSS 覆盖规则
      - `AnalysisLoading`：`z-[9999]`（加载动画）
      - `FeasibilityDialog`：`z-[10000]`（可行性评估对话框，在加载动画之上）
      - `SimilarityWarningDialog`：`z-[10000]`（相似度警告对话框，在加载动画之上）
      - `LoginDialog`：`z-[10001]`（登录对话框 backdrop）和 `z-[10002]`（登录对话框内容，最高优先级）
      - `RegisterDialog`：`z-[10001]`（注册对话框 backdrop）和 `z-[10002]`（注册对话框内容，与 LoginDialog 一致）
        - **子对话框**（条款和隐私政策）：`z-[10003]`（backdrop）和 `z-[10004]`（内容），确保在 RegisterDialog 之上显示
      - `AdminLoginDialog`：使用 `Dialog` 组件，默认 z-index 为 `z-50`（低于 LoginDialog，因为管理员登录优先级较低）
      - **原因**：确保用户交互对话框（如可行性评估、登录）能够显示在加载动画和 toast 消息之上，避免被遮挡。
      - **【重要】页面内容在对话框显示时的 z-index 调整**：
        - **问题**：`ScrollableHero` 的 Hero Section 和 Upload Section 使用 `fixed` 定位，z-index 分别是 `z-10` 和 `z-20`
        - **问题表现**：当登录对话框显示时，这些元素可能会透过 backdrop（`z-[10001]`）显示，导致文字和效果叠加在模态框上
        - **解决方案**：
          1. **ScrollableHero 内部对话框**：当 `showLoginDialog` 或 `showRegisterDialog` 为 `true` 时，将背景、Hero Section 和 Upload Section 的 z-index 降低为 `z-[-1]`、`z-0`、`z-0`
          2. **外部对话框（App.tsx）**：通过 `externalLoginDialogOpen` prop 传递外部登录对话框状态，`ScrollableHero` 根据此状态动态调整 z-index
          3. **renderUploadPage 背景**：当 `showLoginDialog` 为 `true` 时，将背景和内容区域的 z-index 降低为 `z-[-1]` 和 `z-0`
        - **实现位置**：
          - `src/components/ScrollableHero.tsx`：背景、Hero Section、Upload Section 的 z-index 动态调整
          - `src/App.tsx`：`renderUploadPage` 中的背景和内容区域 z-index 动态调整，以及 `ScrollableHero` 的 `externalLoginDialogOpen` prop 传递
    - **登录对话框状态重置**：
      - 当 `LoginDialog` 关闭时（`isOpen` 变为 `false`），使用 `useEffect` 重置所有表单状态（邮箱、密码、验证码、登录方式、倒计时等）。
      - **登录成功后的处理流程**：
        1. 清除表单状态（邮箱、密码、验证码等）
        2. 清除加载状态（`setIsLoading(false)`）
        3. **使用 `setTimeout(..., 0)` 关闭对话框**（`onClose()`），触发 `useEffect` 重置所有状态
           - **原因**：React 的状态更新是异步的，如果立即调用 `onClose()`，可能会与其他状态更新冲突，导致对话框状态更新被覆盖，模态框无法关闭
           - **解决方案**：使用 `setTimeout(..., 0)` 将 `onClose()` 推迟到下一个事件循环，确保所有状态更新都已完成，避免状态更新冲突
        4. **延迟 100ms 显示 toast 消息**（`toast.success('登录成功')`），确保对话框已经关闭
           - **原因**：如果先显示 toast，toast 可能会显示在模态框之上（即使 z-index 配置正确，也可能有渲染时序问题）
           - **解决方案**：先关闭对话框，再延迟显示 toast，确保 toast 显示时模态框已经关闭
      - 这样下次打开对话框时，会显示干净的状态，而不是上次的输入内容。
      - **注意**：`RegisterDialog` 和 `AdminLoginDialog` 也使用相同的逻辑，确保所有对话框的关闭行为一致。
    - **【重要】结果页面登录对话框处理（第三次修复）**：
      - **问题**：登录成功后立即跳转到结果页面时，`showLoginDialog` 可能仍为 `true`，导致登录对话框的 z-index（`z-[10001]`/`z-[10002]`）高于结果页面内容（`z-50`），导致叠加显示。
      - **根本原因**：
        1. 登录成功后，`LoginDialog` 使用 `setTimeout(..., 0)` 延迟关闭对话框，但此时可能已经跳转到结果页面
        2. 结果页面（`ThemeCardsGrid`）没有检查登录对话框状态，也没有渲染 `LoginDialog` 组件
        3. 即使 `showLoginDialog` 为 `true`，结果页面也没有处理，导致对话框仍然显示
      - **解决方案**：
        1. **在结果页面渲染时强制关闭登录对话框**：在 `App.tsx` 中添加 `useEffect`，当 `showResults` 为 `true` 且 `showLoginDialog` 为 `true` 时，强制设置 `setShowLoginDialog(false)`
        2. **在结果页面也渲染 LoginDialog**：确保 `AnimatePresence` 的 exit 动画能正确执行，避免对话框残留
        3. **结果页面容器 z-index 设置**：在 `ThemeCardsGrid` 的根容器上设置 `z-0`，确保低于登录对话框的 z-index
        4. **添加日志记录**：在 `LoginDialog` 和 `App.tsx` 中添加日志，追踪对话框的打开和关闭状态
      - **实现位置**：
        - `src/App.tsx`：在结果页面渲染前添加 `useEffect` 检查并关闭登录对话框，在结果页面 JSX 中渲染 `LoginDialog` 组件
        - `src/components/ThemeCardsGrid.tsx`：在根容器上添加 `z-0` 类名，确保低于登录对话框
        - `src/components/LoginDialog.tsx`：在登录成功处理中添加日志记录
      - **注意事项**：
        - 结果页面的 `LoginDialog` 必须通过 `isOpen={showLoginDialog}` 控制显示/隐藏，确保对话框关闭时能正确执行 exit 动画
        - 结果页面的容器 z-index 必须低于登录对话框，避免内容透过 backdrop 显示
- **服务器端建议**：
  - 对于仍在 `processing` 的任务，可返回 `Retry-After` 或在 `data.retryAfterSeconds` 内指示前端轮询间隔。

### 17. 鉴权、幂等与错误码规范

- **鉴权策略**：
  - 主站用户：
    - 登录后返回 `accessToken` + 可选 `refreshToken`，前端保存于 `httpOnly cookie` 或 `localStorage`（视安全等级而定）。
    - 所有用户接口（上传、分析、历史、订阅、支付）需携带 `Authorization: Bearer <accessToken>`。
  - 管理后台：
    - `admin_session` 与普通用户 Token 区分（Payload 包含 `type: 'admin_session'`、`role: 'admin'`）。
    - 所有 `/api/admin/**` 接口强制要求 `admin_session` 且 `role=admin`。
  - 文件下载：
    - 为防止 Token 泄露，可采用签名 URL 或短期 Query Token，例如：
      - `GET /api/export/xmp?taskId=<id>&downloadToken=<one-time-token>`。
      - `downloadToken` 由前端通过受鉴权保护的接口 `POST /api/export/token` 获取。

- **幂等性与防重放**：
  - 任务创建类接口（如 `POST /api/analyze/part1`）建议支持 `Idempotency-Key` Header：
    - 后端基于 `(userId, Idempotency-Key)` 识别重复请求，返回同一任务结果。
  - 支付创建接口 `POST /api/payments/create` 必须支持幂等，防止用户多次点击“立即支付”生成多订单。

- **错误码建议**（示例，具体可在附录中落表）：
  - `ANALYSIS_TASK_NOT_FOUND`、`ANALYSIS_STAGE_INVALID`。
  - `UPLOAD_FILE_TOO_LARGE`、`UPLOAD_MIME_NOT_ALLOWED`。
  - `GEMINI_RESPONSE_INVALID_JSON`、`GEMINI_SCHEMA_VALIDATION_FAILED`。
  - `PAYMENT_CREATE_FAILED`、`PAYMENT_STATUS_UNKNOWN`。
  - `ADMIN_PERMISSION_DENIED`。

### 18. 上传/图片处理与前端直方图规范

- **上传与存储**：
  - 上传接口统一接受 multipart/form-data：
    - 字段：`sourceImage`（必填）、`targetImage`（可选）。
    - 校验：大小 ≤ 25MB，限制 MIME 为 `image/jpeg`, `image/png` 等。
  - 后端存储策略：
    - 数据库仅存储引用（如对象存储 URL）与必要的 Base64（短期）。
    - 缩略图与原图分离存储，避免前端载入超大文件。
    - **对象存储优化**：如果对象存储类型是 "local" 或未配置，直接使用 Base64 存储，不尝试上传到对象存储。这样可以避免不必要的连接尝试和超时等待（特别是 MinIO 连接失败时，会等待 10 秒超时），防止前端请求超时或被取消。
    - **MinIO 初始化优化**：在 `StorageService._init_minio()` 中设置 5 秒超时，避免 MinIO 服务未运行时阻塞应用启动。如果 MinIO 连接失败，会设置 `self._client = None`，后续上传时会自动回退到 Base64 存储。
    - **日志记录**：后端上传接口会记录详细的日志，包括函数入口、用户认证、图片读取、对象存储上传、Base64 编码、相似度计算、上传记录创建等各个步骤，便于追踪问题。
  - 返回给前端的 URL 需要：
    - 支持 HTTPS。
    - 控制缓存策略与有效期（可通过签名 URL 实现）。

- **前端直方图（像素级计算，不由模型直接给出 bins）**：
  - 所有直方图（参考图、用户图、仿色后示意图）必须由前端通过 `Canvas` 计算：
    - 加载图片 → 绘制到隐藏 `canvas` → `getImageData` → 遍历像素计算 RGB 分布 → 用 `Chart.js` 或自定义 SVG 绘制。
  - 后端/Prompt 不负责输出 256 维 bins 等高精度直方图数据，以避免 LLM “猜数值”带来的不稳定；如模型误输出相关字段，`analysisFormatter` 直接忽略。
  - **【重要】直方图类型说明**：
    - **Canvas 计算的直方图**（`Histogram` 组件）：
      - 用于：LR/PS 卡片中的直方图
      - 数据来源：前端通过 Canvas API 实时计算图片像素
      - 特点：精确、专业、基于实际像素数据
      - **交互功能**：支持鼠标悬停显示数值（亮度值、R/G/B/L 通道的像素分布数量和百分比）
    - **AI 反推直方图**（`HistogramChart` 组件）：
      - 用于：照片点评-色彩与景深维度
      - 数据来源：Gemini 根据图片视觉特征反推的直方图数据（`data_points` 数组，255个整数）
      - 特点：AI 根据视觉特征推测，用于趋势参考和解释说明
      - 用途：帮助用户理解"AI 认为这张照片的直方图应该是什么样的"
      - **交互功能**：使用 Recharts 的 `Tooltip` 组件，支持鼠标悬停显示数值（亮度值、分布值）
- **直方图摘要字段与图表生成服务（摘要由模型/算法，图由前后端绘制）**：
  - 为了在 UI 与报告中解释直方图形态，可以在协议中增加**摘要字段**，由模型或算法负责提供“形状说明”，而非原始像素 bins：
    - 示例结构：
      ```json
      "histogram_overview": {
        "luminance_distribution": { "shadows": 0.25, "midtones": 0.55, "highlights": 0.20 },
        "channel_balance": { "red": "slightly_dominant", "green": "balanced", "blue": "slightly_lower" },
        "shape": "midtones_peak_with_soft_shadows"
      }
      ```
    - 该字段可来自：
      - Gemini 的自然语言 + 结构化摘要（由 `analysisFormatter` 解析为上述 JSON）；
      - 或后端基于真实 bins 的规则计算（推荐长期采用）。
  - 后端建议新增 `chartService`（或等价服务）用于**导出报告中的静态图**生成：
    - 输入：真实直方图 bins、Part2 JSON 中的 tone_curve/rgb_curves、color_grading 等；
    - 输出：PNG/SVG 图像（直方图、曲线、色轮），由 `exportService` 嵌入 HTML/PDF 报告；
    - 前端交互页面仍由 React + Canvas/Chart.js 绘制，不依赖后端生成图片，以保证性能与交互性。

### 19. Admin 调试页与 Gemini 输出对比

- **目标**：为 Prompt 调优和协议演进提供可视化对比工具。
- **后端接口**：
  - `GET /api/admin/tasks/:taskId`：
    - 返回字段包含：
      - `gemini_result`: 原始模型返回（尽量保留结构，必要时裁剪掉 Base64 图片等敏感字段）。
      - `structured_result`: 经过 `analysisFormatter` + schema 校验后的规范结果。
      - `meta`: 包含 `warnings`、`protocolVersion`、`mappingNotes` 等。
  - 可选：`GET /api/admin/tasks/:taskId/logs` 返回关键日志片段（不含敏感数据）。
- **前端 Admin 页面**：
  - 左侧 JSON 视图：显示 `gemini_result`。
  - 右侧 JSON 视图：显示 `structured_result`。
  - 差异高亮：标出缺失字段、默认值补齐位置（可读取 `meta.warnings`）。
  - 操作按钮：
    - “复制 Prompt 请求体”——便于在外部工具复现。
    - “导出 JSON”——用于离线分析。

### 20. Prompt 版本化与缓存策略

- **Prompt 版本管理**：
  - 所有 Prompt 模板落地为代码文件：
    - `server/services/promptTemplate.ts`（或等价路径）。
    - 内部区分 `getPart1Prompt(...)`、`getPart2Prompt(...)`、`getPart3FlashPrompt(...)`。
  - Prompt 变更需：
    - 同步更新 `protocolVersion` 或以 `promptVersion` 字段记录。
    - 在 `顶层设计文档.md` 对应章节更新，保留变更说明。
- **Gemini 缓存与长上下文**：
  - 使用 Gemini 官方的 `cachedContent` 机制：
    - 将固定指令（角色、六步流程、JSON skeleton）写入缓存，设置 `TTL=43200` 秒。
    - 每次调用仅附加动态部分（图片、EXIF、Part1 摘要等）与 `cachedContent` 引用。
  - 超时与重试：
    - 设置合理超时（如 60 秒），超时后写入 `meta.warnings` 并返回友好错误。
    - 对短暂网络错误支持有限重试（如 2 次），避免用户体验受偶发错误影响。

### 21. 安全与合规补充细则

- **数据最小化与脱敏**：
  - 日志中禁止记录完整 Base64 图片数据，只记录摘要（如 hash）与尺寸。
  - 用户个人信息（邮箱、手机号）在日志中需做脱敏（如中间位替换为 `*`）。
- **访问控制与审计**：
  - 管理后台所有变更操作（套餐、价格、内容、权限）写入 `audit_logs` 表。
  - 关键安全参数（代理配置、API Key）严禁从前端可见接口透出。
- **配置管理**：
  - 所有敏感配置由环境变量提供：
    - `GEMINI_API_KEY`、`GEMINI_MODEL`、`GEMINI_FLASH_MODEL`、`GEMINI_TIMEOUT_MS`。
    - `AUTH_ADMIN_MAX_FAILED_ATTEMPTS` 等安全相关配置。
  - Dev/Staging/Prod 使用分离的 `.env` 文件，避免误用生产配置。
  - **Pydantic Settings 配置规范**：
    - `Settings` 类的 `Config` 中必须设置 `extra = "ignore"`，允许环境变量中有额外字段但不报错
    - 所有环境变量字段必须在 `Settings` 类中定义，或使用 `extra = "ignore"` 忽略未定义字段
    - 示例：
      ```python
      class Settings(BaseSettings):
          GEMINI_API_KEY: str = ""
          GEMINI_TIMEOUT_MS: int = 120000  # 必须定义所有环境变量字段
          
          class Config:
              env_file = ".env"
              extra = "ignore"  # 允许额外字段，但不报错
      ```

### 22. Gemini 调用实现与 ClashX 代理配置（Python & Node）

- **Python 侧（`server_py/app/services/gemini_service.py`）**：
  - 客户端封装：
    - 使用 `google.genai.Client(api_key=GEMINI_API_KEY)` 初始化，在 `GeminiService` 中注入：
      - `api_key`：从环境变量 `GEMINI_API_KEY` 读取；
      - `model`：默认 `gemini-3-pro-preview`（已迁移到 Gemini 3.0），允许通过 `GEMINI_MODEL` 覆盖；
      - `flash_model`：默认 `gemini-2.5-flash-image`（Part3 风格模拟使用，Gemini 3.0 不支持图片分割功能）；
      - `timeout_ms`：从配置 `GEMINI_TIMEOUT_MS` 读取，默认 180 秒（180000 毫秒）。
        【重要】根据实际测试，Part1 分析可能需要 60-70 秒，AI 诊断可能需要 70+ 秒
        考虑到网络延迟和 Gemini API 响应时间波动，设置为 180 秒以确保稳定性
    - 方法设计：
      - `generate_text(contents: List[Dict], response_mime: Optional[str]) -> str`：用于 Part1/Part2 文本+JSON 输出；
      - `generate_image(...)`：用于 flash-image 图像生成（Part3）。
    - **超时控制**：
      - 使用 `ThreadPoolExecutor` 在后台线程中执行 Gemini API 调用，并设置超时（`future.result(timeout=...)`）。
      - 超时时间从 `GEMINI_TIMEOUT_MS` 配置读取，默认 180 秒（与配置文件保持一致）。
      - 如果超时，抛出 `TimeoutError`，并在日志中记录详细的超时信息。
      - **注意**：google-genai SDK 的 `generate_content` 是同步方法，不能直接使用 `asyncio.wait_for`，因此使用 `ThreadPoolExecutor` 实现超时控制。
      - 【重要】根据实际测试，Part1 分析可能需要 60-70 秒，AI 诊断可能需要 70+ 秒，考虑到网络延迟和 Gemini API 响应时间波动，设置为 180 秒以确保稳定性。
  - 代理配置（对接 ClashX）：
    - 在启动后端之前，通过环境变量设置 HTTP 代理：
      - `HTTPS_PROXY=http://127.0.0.1:7890`
      - `HTTP_PROXY=http://127.0.0.1:7890`
    - Gemini SDK 默认遵守上述代理环境变量，无需在代码中硬编码代理。
  - 日志与错误处理：
    - 每次调用记录：`model`、阶段（`feasibility/part1/part2/style`）、耗时、是否命中 `cachedContent`、超时设置。
    - 如果超时，记录详细的超时信息（耗时、超时设置）。
    - 捕获 SDK 异常时，统一包装为业务错误 `GEMINI_CALL_FAILED`，并在 `meta.warnings` 写入简要原因；避免将原始异常栈直接暴露给前端。

- **Node 侧（若继续使用 `@google/genai`）**：
  - 初始化：
    - 使用 `const client = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY })`。
    - 通过 `process.env.HTTPS_PROXY = 'http://127.0.0.1:7890'` 或启动命令里的环境变量，让所有 `fetch` 走 ClashX。
  - 服务封装：
    - `geminiService.ts` 提供：
      - `callPart1(promptArgs): Promise<GeminiRawResponse>`；
      - `callPart2(promptArgs): Promise<GeminiRawResponse>`；
      - `callFlashImage(promptArgs): Promise<FlashImageResponse>`；
      - 内部统一处理：`cachedContent` 创建/复用、重试、超时。
  - 与 Python 的关系：
    - 当前仓库已存在 Python 版 `GeminiClient`；若后端最终统一在 Node，请保持 API 设计与 Python 版本一致（相同入参/出参结构），以便迁移。

### 23. 三阶段 Prompt 模板落地规范（终版约束）

- **Prompt 代码文件与命名**
  - 在后端维护 Prompt 模板文件：
    - Node 方案：`server/src/services/promptTemplate.ts`。
    - Python 方案：`server_py/app/services/prompt_template.py`（命名示例）。
  - 必须导出/实现以下三个函数（以及可选的 Feasibility Prompt），并在文档与代码中保持一致：
    - `getPart1Prompt(referenceImage, userImage, exif, options)`;
    - `getPart2Prompt(referenceImage, userImage, part1Context, options)`;
    - `getPart3FlashPrompt(userImage, styleSummary, options)`;
    - `getFeasibilityPrompt(referenceImage, userImage, exif)`（见第 26 节）。

- **23.1 Prompt 总体角色与输出要求**
  - 角色设定：Gemini 必须同时扮演 **资深摄影师** 与 **影像后期专家**，精通 Lightroom、Camera Raw 与 Photoshop 的参数与操作流程。
  - 总体任务：对输入图片（或两张图片做对比）进行全面、专业、具体、可执行的摄影风格分析，并输出两部分内容：
    1. 一段供用户阅读的自然语言分析（摄影师口吻、连贯叙述、说明“为什么 / 如何 / 体现在哪里”）；
    2. 一份严格结构化的 JSON（供前端与本地 color-mapping / 导出模块直接使用）。
  - 输入约定：
    - `reference_image`: 参考图 URL 或 base64（必填）；
    - `user_image`: 用户图 URL 或 base64（可选；若存在必须对比）；
    - `optional_style`: 可选风格关键词（如 "日出暖光", "胶片感"）；
    - `EXIF`: 若提供，必须优先使用其中的 ImageWidth/ImageHeight、相机型号、镜头信息等。
  - 总体硬约束：
    - 输出 **自然语言报告 + JSON** 两部分，两者内容必须一致（报告中的结论在 JSON 中有对应字段）；
    - 所有调整参数必须为具体数值，禁止“稍微提高/略微降低”这类模糊用语；
    - 所有 Lightroom/Photoshop 滑块参数必须为字符串，并带显式正负号（如 `"+0.25"`、`"-45"`、`"+0"`）；
    - 不允许输出 `"未提供" / "N/A" / "示例值"` 等占位符——无调整就用 `"+0"`，无数据则省略字段并在 `analysis_meta.notes` 说明原因；
    - 当存在 `user_image` 时，必须输出对比分析表（参考图 vs 用户图 vs 差异 vs 调整建议），并在 JSON 中结构化；
    - 所有输出必须遵守“提出观点 → 分析依据 → 得出结论”的叙述结构，保证段落衔接自然。

- **23.2 Part1 Prompt（基础洞察，结合复刻可行性摘要）**
  - 角色：**影像科学艺术总监 (审美与策略制定)**（已更新，从"影像科学首席技术官 & 资深艺术总监"改为更强调策略制定）。
  - 目标：输出自然语言 + Part1 JSON（点评、构图、光影趋势、可行性说明、工作流草案）。
  - **核心逻辑变更（CRITICAL）**：
    - **任务定位**：不是简单的"找不同"，而是制定**"风格迁移策略"**。
    - **通透感保护机制**：如果参考图是"高对比/高饱和"风格，而用户图是"柔美/高调（如樱花、人像）"题材，必须启动**【通透感保护机制】**。绝不能为了模仿风格而破坏用户图原本的纯净度。
    - **分析原则**：
      1. **先体检用户图**：在分析参考图之前，必须先深入分析用户图的"体质"（直方图分布、色彩倾向、题材特征）。
      2. **避免暴力强制克隆**：不要盲目套用参考图的参数，而是要根据用户图的特征，制定"适配性"的迁移策略。
      3. **保护原生美感**：如果用户图本身具有独特的审美价值（如高调片的轻盈感、柔美片的通透感），必须优先保护这些特征。
  - 自然语言部分要求（Step 1）：
    - 按以下维度，使用摄影师口吻连贯叙述，每一项都要说明“为什么 / 如何 / 体现在哪里”：
      1. 视觉引导与主体（第一视觉焦点、视线引导路径、颜色/亮度/位置对视线的影响）；
      2. 焦点与曝光（对焦与景深、曝光是否有意为之、对整体情绪的影响）；
      3. 色彩与景深（主体与背景色彩关系、空间感与景深表现）；
      4. 构图与表达（主体位置、构图法则、视觉平衡、情绪与主题表达）；
      5. 技术细节（剪裁/拍摄角度/后期方向的具体建议）；
      6. 设备与技术（若有 EXIF，优先使用；若无，则基于画面推断相机/镜头类型，并说明依据）；
      7. 色彩与情感（颜色组合与情绪）；
      8. 优点评价（“好在哪里”，并给出技术或艺术层面的证据）；
      9. 对比分析（若有 `user_image`，必须给出结构化对比：对比项 / 参考图 / 用户图 / 差异 / 调整建议）。
    - 结尾必须有一句「摄影师风格总结」短句，用于前端 Summary 卡片。
  - Step 2：整体影像分析（量化）：
    - 场景类型：如 `"landscape" / "portrait" / "architecture" / "documentary"`；
    - 画面结构：主体位置（如 `"right_third"` 或精确百分比）、留白说明、构图类型（对称/三分法/引导线等）；
    - 分辨率规则：
      - 若 EXIF 有 ImageWidth/ImageHeight，必须用 EXIF 值；
      - 否则用真实像素尺寸；
      - 禁止猜测或示例值；
    - 输出平均亮度（如 `"152/255"`）、景深描述（浅/长）、拍摄时间段（如 `"golden_hour"`）、光线方向（如 `"from_left_45deg"`）；
    - 若有 EXIF，相机/镜头/光圈/快门/ISO 信息必须列出并用于后续分析。
  - Step 4：可复刻可行性说明（与第 26 节对齐）：
    - 在 Part1 中，不再重新计算数值，而是：
      - 引用 `analysis_tasks.feasibility_result` 的摘要（`feasibilityScore`、`difficulty`、`confidence`、Top-3 拖累项）；
      - 以自然语言解释“为什么可行或困难”、“哪些维度拖累可行性”、“需要在后期中注意什么”；  
    - JSON 中在 `analysis_meta.conversion_feasibility` 填入：
      - `can_transform`、`difficulty`、`confidence`、`limiting_factors[]`、`recommendation`，数据来源于 Feasibility 结果。
  - Part1 JSON 要求（新 Prompt 模版）：
    - **模块一：照片点评 (module_1_critique)**
      - `comprehensive_review`：综合描述（内容 -> 影调 -> 色调 -> 器材/参数 -> 时间）
      - **基础体质诊断 (Base Image Diagnosis)** - 新增核心维度：
        - **用户图直方图体质**：分析用户图是"高调片（High Key）"还是"低调片（Low Key）"，必须明确指出直方图分布特征（左偏/右偏/中间调集中），并评估其"脆弱性"（即对后期调整的敏感度）。
        - **参考图攻击性评估**：评估参考图风格的"攻击性"（对用户图原生特征的破坏力），并给出风险警告。
        - **【新增】色彩饱和度策略 (Color Saturation Strategy)**：
          - 必须分析参考图的整体饱和度水平，判断属于以下哪种类型：
            - **鲜艳 (Vibrant)**：色彩饱和度高，画面鲜艳明亮
            - **自然 (Natural)**：色彩饱和度适中，接近真实场景
            - **低饱和/静音 (Muted/Desaturated)**：色彩饱和度低，画面呈现去色、静音、电影感
          - 必须明确指出参考图的饱和度类型，并在 style_summary 中明确告诉 Phase 2："这张图的重点是'去色'，而不是'上色'"。
        - **【新增】影调强度评估 (Tonal Intensity)**：
          - **对比度评估**：评估参考图的对比度是"柔和 (Soft)"、"标准 (Standard)"还是"强力/戏剧性 (Punchy/Dramatic)"。
          - **黑位评估**：评估参考图的黑位是"褪色灰 (Faded)"还是"扎实黑 (Crushed)"。
          - 必须明确指出参考图的对比度类型和黑位类型，并在 style_summary 中明确告诉 Phase 2 如何处理。
      - `visual_subject_analysis`：视觉引导与主体分析
      - `focus_exposure_analysis`：焦点与曝光分析
      - **色彩映射策略 (Color Mapping Strategy)** - 解决饱和度问题：
        - **饱和度策略（根据风格强度分级）**：
          - **低饱和/静音风格**：如果参考图被判定为"低饱和/静音"风格，HSL 的首要任务是**降低 Saturation (饱和度)**。对于关键色（如天空蓝），在降低饱和度的同时，再根据需要微调明度。示例："参考图是低饱和电影风格，天空蓝色的 Saturation 应该在 -20 到 -40 之间，而不是正值。全局饱和度 (Saturation) 和自然饱和度 (Vibrance) 通常需要是负数（例如 Saturation -10, Vibrance -20），作为全局去色的基调。"
          - **鲜艳/自然风格**：如果参考图被判定为"鲜艳"或"自然"风格，则遵循"提明度，降饱和"策略。示例："为了获得'通透感'，蓝色的处理不能只加饱和度。必须提高蓝色的**明亮度 (Luminance)**，同时控制饱和度在 +10 以内，否则天空会变成塑料蓝。"
        - **白平衡定调**：分析用户图当前的白平衡倾向，并给出具体的色温/色调调整方向，确保画面不偏色，保持通透感。
      - `color_depth_analysis`：
        - `text`：色彩科学分析文本
        - `simulated_histogram_data`：直方图数据
          - **新结构**（当前使用）：单一结构
            - `description`：文本描述直方图特征（如：中间低两头高）
            - `data_points`：255个整数表示0-255的亮度分布
          - **旧结构**（向后兼容）：包含 reference 和 user 两个字段
            - `reference`：参考图直方图数据（`description` + `data_points` 数组，255个整数）
            - `user`：用户图直方图数据（`description` + `data_points` 数组，255个整数）
          - **后端处理**：`analysis_formatter.py` 已兼容新旧两种结构，新结构会被映射为 `histogramData.reference`
      - `emotion`：情感与意境描述
      - `pros_evaluation`：高级感来源
      - `parameter_comparison_table`：参数对比表（dimension, ref_feature, user_feature）
      - `style_summary`：**风格克隆战略指导（最重要的字段）**
        - **这是 Phase 1 的核心产出**，不能只写一句话总结
        - **必须包含的内容**（一个也不能少）：
          1. **策略名称 (Strategy Name)**：给本次风格迁移策略起一个名称（如："高调空气感适配 (High-Key Airy Adaptation)" 或 "低饱和电影风格适配 (Muted Cinematic Adaptation)"）
          2. **关键警告 (Critical Warning)**：明确指出哪些操作是"禁止项"或"必须项"。
            - *对于低饱和/高对比风格*："关键战略：极度克制的色彩与强对比。全局必须大幅降低饱和度，抽离杂色，只保留微弱的青蓝阴影和淡黄高光。影调上，必须使用强S型曲线，压实暗部以制造沉浸感，不再优先考虑暗部细节的通透性。"
            - *对于高调/柔美风格*："用户图为樱花题材，严禁重度压暗阴影。需保持画面轻盈。"
          3. **影调重塑指令 (Tone Instruction)**：具体的明暗调整方向。
            - *对于低饱和/高对比风格*："影调层面：必须使用强S型曲线，压实暗部以制造沉浸感。允许 Blacks 为负值 (-10 ~ -30)，并使用强 S 型曲线压暗阴影区域，以匹配参考图的厚重感。不再优先考虑暗部细节的通透性。"
            - *对于高调/柔美风格*："光影层面：保持直方图向右堆积（ETTR）。利用曲线仅仅压暗极黑点，大幅提亮阴影区以获得空气感。"
          4. **色彩映射指令 (Color Instruction)**：具体的调色方向。
            - *对于低饱和/静音风格*："色彩层面：参考图是低饱和电影风格，全局必须大幅降低饱和度。基本面板的饱和度 (Saturation) 和自然饱和度 (Vibrance) 通常需要是负数（例如 Saturation -10, Vibrance -20），作为全局去色的基调。HSL 的首要任务是降低 Saturation，对于关键色（如天空蓝），Saturation 应该在 -20 到 -40 之间，而不是正值。颜色分级 (Color Grading) 的 Saturation 值通常很低（比如 5-15），只要一点点倾向就够了，不能给太多。"
            - *对于鲜艳/自然风格*："色彩层面：参考图的蓝色很深，但用户图需要通透。请通过 HSL 将蓝色明度(Luminance) +20，色相(Hue)微偏青，饱和度(Saturation) 限制在 +10。樱花粉色需减少洋红(Magenta)，偏向橙色以显嫩白。"
          5. **禁止项 (Prohibitions)**：明确列出哪些参数调整是"严禁"的。
            - *对于低饱和/高对比风格*："严禁增加全局饱和度，严禁保持 Blacks 为正值（必须允许为负值以匹配参考图的厚重感）。"
            - *对于高调/柔美风格*："严禁将阴影 (Shadows) 压低超过 -20"，"严禁蓝色饱和度超过 +15"。
          6. **风格强度配方 (Style Intensity Formula)**：明确写入具体的调整方法。
            - *对于低饱和/高对比风格*："使用强 S 型曲线压暗阴影区域，而不是提亮阴影。使用负值的全局饱和度作为去色基调，而不是增加饱和度。"
            - *对于高调/柔美风格*："使用 S 型曲线提亮中间调，而不是直接拉大对比度滑块。"
        - **目的**：这段文字将作为 Phase 2 生成 LR/PS 参数的直接依据，必须包含具体的参数限制和调整方法。**必须更具强制性**，针对低饱和/高对比风格给出明确的"去色"和"压暗部"指令，而不是温和的描述。
        - **目的**：这段文字将作为 Phase 2 生成 LR/PS 参数的直接依据，必须包含具体的参数限制和调整方法
        - **后端提取路径**：
          - 优先路径：`structured_result.sections.photoReview.structured.photographerStyleSummary`
          - 备选路径：`gemini_result.module_1_critique.style_summary`（新 Prompt 结构）
      - `feasibility_assessment`：复刻可行性评估（score, level, limitations, recommendation, confidence）
    - **模块二：构图分析 (module_2_composition)** - 【重构】双宇宙模式（物理隔离）
      - **核心设计**：将 Module 2 重构为两个严格隔离的平行宇宙，彻底杜绝 Gemini 混淆两张图
      - **宇宙 A：参考图分析 (reference_analysis)** - 仅分析参考图，作为教科书标准
        - `classification`：构图类型（如 "Environmental Portrait", "Minimalist Architecture"）
        - `geometric_structure`：几何结构（如 "Rule of Thirds", "S-Curve", "Triangle"）
        - `visual_quality_assessment`：顶级摄影师视角的深度评价，解释为什么这个构图是好的
        - `visual_weight`：视觉权重分析
          - `score`：整体视觉权重分数（0-100）
          - `method`：使用的构图法则（如 "Rule of Thirds", "Golden Ratio"）
          - `description`：主体突出度分析
          - `layers_visual_map`：【新增】可交互的权重图层数组，每个图层包含：
            - `label`：标签（如 "Main Subject", "Secondary Element"）
            - `score`：权重分数（0-100）
            - `box`：坐标框（x, y, w, h 为 0-100%，基于参考图）
        - `visual_flow`：视觉流分析
          - `description`：深度解释视线移动路径
          - `vanishing_point`：消失点坐标（x, y 为 0-100%，基于参考图）
          - `vectors`：向量线数组，显示视线如何移动（基于参考图）
            - `start`、`end`：起点和终点坐标（x, y 为 0-100%）
            - `type`：类型（"leading"、"perspective"、"horizon"、"distraction"）
            - `strength`：强度（0-100）
        - `spatial_depth`：空间深度分析
          - `foreground`、`midground`、`background`：每个包含：
            - `content`：内容描述
            - `depth_range`：深度范围 [0-100]
            - `polygon`：【新增】多边形数组，标记前中后景区域（基于参考图）
              - 每个点包含 `x, y`（0-100%）
        - `negative_space`：留白平衡
          - `percentage`：留白比例
          - `horizontal_balance`：水平平衡（如 "Left Heavy", "Balanced"）
          - `vertical_balance`：垂直平衡（如 "Top Heavy", "Bottom Heavy"）
      - **宇宙 B：用户图诊疗 (composition_clinic)** - 仅分析用户图，作为手术台
        - `diagnosis_summary`：一句话诊断用户图的核心问题
        - `suggested_crop`：智能构图建议
          - `x, y, w, h`：裁剪框坐标（0-100%，基于用户图）
          - `reason`：裁剪原因说明
        - `action_guides`：现场拍摄指导（AR 标记）
          - 每个标记包含：`x, y`（位置，0-100%，基于用户图）、`icon`（图标类型）、`instruction`（指令文字）、`vector_angle`（箭头方向）
        - `grading_masks`：后期蒙版
          - 每个蒙版包含：`area_polygon`（多边形区域，基于用户图）、`action`（操作类型）、`advice`（调色建议）
      - **前端显示方案**：
        - **主面板 (CompositionAnalysisPanel)**：左侧显示参考图交互区（支持切换图层：视觉流/空间深度/视觉权重），右侧显示数据分析面板（分类、视觉质量、权重分布、留白平衡），核心按钮进入构图诊疗室
        - **诊疗室 (DirectorViewfinder)**：全屏显示用户图，支持四种模式（原图/智能构图/拍摄指导/后期蒙版），提供沉浸式 AR 指导
      - **后端数据清洗**：
        - 清洗 `reference_analysis` 数据：`spatial_depth.polygon`、`visual_weight.layers_visual_map`、`visual_flow.vectors`
        - 清洗 `composition_clinic` 数据：`suggested_crop`、`action_guides`、`grading_masks`
        - 所有坐标归一化为 0-100% 格式
      - **向后兼容**：保留旧字段结构（`main_structure`、`subject_weight`、`visual_guidance` 等），确保不影响现有功能
    - **模块三：光影参数 (module_3_lighting_params)** - 仅分析参考图
      - `exposure_control`：曝光控制参数
        - **格式要求**：必须使用"范围+描述"格式，例如："+0.3～+0.6，轻微提升使高光有"柔光""
        - 支持格式：范围（"+0.3～+0.6"）、单个值（"+0.3"）、描述（"微调"），但必须同时包含范围和描述
        - 字段：exposure, contrast, highlights, shadows, whites, blacks
      - `tone_curves`：色调曲线
        - `explanation`：曲线调整逻辑说明
        - `points_rgb`：RGB 曲线坐标点数组
        - `points_red`：红色通道曲线坐标点数组
        - `points_green`：绿色通道曲线坐标点数组
        - `points_blue`：蓝色通道曲线坐标点数组
      - `texture_clarity`：纹理与清晰度
        - **格式要求**：必须使用"范围+描述"格式
        - 字段：texture, clarity, dehaze
    - 根级元信息：`protocolVersion: "2025-02"`、`stage: "part1"`、`meta.rawNaturalLanguage`（完整原文）。

- **23.3 Part2 Prompt（执行参数与工作流，对齐科学仿色约束）**
  - 角色：**资深调色师 (擅长日系/通透感/商业修图)**（已更新，从"影像科学高级数字影像技师 (Senior DIT) & 商业修图专家"改为更强调日系和通透感调色）
    - 精通 Adobe Lightroom Classic 和 Photoshop 的顶级修图师，特别擅长日系风格、通透感调色和商业修图
    - 在 Phase 1 中，艺术总监已经制定了宏观的《影像风格克隆战略》（即 `style_summary`）
    - 现在的任务是**执行**——将这些战略转化为精确的、可操作的参数和步骤
  - **核心任务**：将 Phase 1 的策略转化为 LR/PS 参数。
  - **当前痛点修正**：之前的算法导致结果过于饱和、反差过大。必须遵循**【风格优先级覆盖机制】**来生成数据，根据 Phase 1 的风格强度分级，灵活调整参数生成策略。
  - **风格优先级覆盖机制 (Style Priority Override Mechanism) - 必须严格遵守**：
    - **核心原则**：**"风格匹配度优先"**，而不是僵化地遵循"通透感优先"。如果 Phase 1 指示风格为"低饱和/静音"或"强力/戏剧性"，必须大胆地降饱和、大胆地压暗部，以匹配参考图的风格。
    - **定律 1：明度 > 饱和度（增加例外情况）**：
      - **默认规则（鲜艳/自然风格）**：通透感来自于颜色的**明亮度 (Luminance)**，而不是饱和度。在 HSL 调整中，优先提升关键色（如蓝、橙、绿）的明度。
      - **例外规则（低饱和/静音风格）**：对于低饱和风格，HSL 的首要任务是**降低 Saturation (饱和度)**。对于关键色（如天空蓝），在降低饱和度的同时，再根据需要微调明度。示例：天空蓝色的 Saturation 应该在 -20 到 -40 之间，而不是正值。
    - **定律 2：去雾 (Dehaze) 慎用**：去雾功能会大幅增加饱和度和对比度，导致死黑。除非画面灰度极大，否则去雾值**严禁超过 +10**，甚至在日系风中应为负值 (-5 ~ -10) 以增加空气感。
    - **定律 3：对比度与黑位陷阱（风格覆盖机制）**：
      - **默认规则（高调/柔美风格）**：不要通过"对比度"滑块加对比。要通过**"色调曲线 (Tone Curve)"**来实现——提亮亮部，保持暗部柔和。Blacks 参数应在 +5 ~ +20 之间，而不是负值。
      - **风格覆盖规则（强力/戏剧性风格）**：如果 Phase 1 指示风格为"强力/戏剧性 (Dramatic)"，则允许 Blacks 为负值 (-10 ~ -30)，并允许使用强 S 型曲线压暗阴影区域，以匹配参考图的厚重感。
    - **定律 4：参数生成逻辑的微调**：
      - **基本面板 > 饱和度/自然饱和度**：对于低饱和风格，这两个数值通常需要是负数（例如 Saturation -10, Vibrance -20），作为全局去色的基调。
      - **HSL > 饱和度**：要求 AI 更大胆地给出负值。对于低饱和风格，HSL 的首要任务是降低 Saturation，而不是提升 Luminance。
      - **颜色分级 (Color Grading)**：强调在低饱和风格中，色轮的 Saturation 值通常很低（比如 5-15），只要一点点倾向就够了，不能给太多。
  - **【重要】语言要求**：
    - **必须使用简体中文（Chinese Simplified）输出所有文本内容**，包括：
      - 所有 `reason` 字段（解释字段）
      - 所有 `description` 字段（描述字段）
      - 所有 `text` 字段（文本字段）
      - 所有自然语言说明
    - **禁止使用英文**。如果发现任何英文文本，将被视为格式错误。
    - 在 Prompt 的多个位置（开头、Output Format、Constraints）都明确强调中文输出要求。
  - 输入：
    - `reference_image`：参考图（必填）
    - `user_image`：用户图（必填）
    - `style_summary`：**Phase 1 的风格克隆战略指导（核心输入）**
      - 从 Part1 结果中提取：`structured_result.sections.photoReview.structured.photographerStyleSummary`
      - 备选路径：`gemini_result.module_1_critique.style_summary`（新 Prompt 结构）
      - 后端实现：`server_py/app/routes/analyze.py` 在 `analyze_part2` 接口中提取并传递给 Prompt
      - 如果未找到 `style_summary`，会在日志中记录警告，但不会中断流程
    - `part1_context`：Part1 上下文（含 `workflow_draft` 等，可选）
    - `feasibility_result`：可行性评估结果摘要（可选）
  - **处理逻辑（必须严格遵守）**：
    1. **继承战略**：生成的每一个参数（如色温、曲线点）都必须有据可依，必须源于 Phase 1 的分析结果。严禁产生与 Phase 1 矛盾的参数（例如 Phase 1 说要冷调，你却加暖色温）。
    2. **软件分工**：
       - **Lightroom (80%)**：负责定调。完成白平衡、曝光、基础色相/饱和度、颜色分级。
       - **Photoshop (20%)**：负责精修。完成局部光影（Dodge & Burn）、氛围光晕（Glow）、特定颜色的更精细偏移（可选颜色）、质感锐化。
    3. **数据精度**：
       - 数值应为**范围**（如 `+10 ~ +15`），给予用户一定的容错空间。
       - 解释（Reasoning）必须从视觉原理出发（如"为了互补色对比"），而不能是废话。
  - 目标：输出可直接驱动前端与导出模块的 Lightroom / Photoshop 全量参数 + 工作流对齐说明，并尊重可行性分析结论。
  - 自然语言报告：
    - `workflow_execution_summary`：
      - 说明如何沿用 / 调整 / 新增 Part1 草案中的步骤；
      - 如 Feasibility 判定"极高/不建议"，需要在此明确说明"本次只给出方向性建议，不保证高度还原"，并建议补拍/更换目标等。
      - **必须使用简体中文**。
    - `lightroom_strategy` / `photoshop_strategy`：
      - 对 LR/PS 调色思路做解释，必须与 JSON 中给出的具体参数一致，不能出现"想法一套、参数一套"的矛盾。
      - **必须使用简体中文**。
  - JSON 部分（严格数值输出）：
    - **新结构**（当前使用）：
      - `phase_1_extraction`：**必须输出此对象**，包含三个字段（用于前端色彩策略卡片展示）
        - `master_style_recap`：确认识别到的流派（必须使用简体中文），例如："日系冬日极简 / 高调空气感 (Japanese Winter High-Key)"
        - `style_summary_recap`：简要回顾 Phase 1 的核心指导思想（必须使用简体中文），例如："基于参考图的[Ethereal High-Key Strategy]与[Cool Desaturation Mapping]，核心在于..."
        - `key_adjustment_strategy`：总结本次调色的三大关键点（必须使用简体中文），例如："1. 激进的阴影提亮与黑位哑光化... 2. 负向清晰度与去朦胧... 3. 全局低饱和冷色映射..."
        - **重要**：这三个字段是必需的，不能省略！Prompt 中已明确强调此要求。
      - `color_science_scheme`：
        - `white_balance`：白平衡（temperature、tint，每个字段包含 `value`（范围字符串，如 `"+600 ~ +900"`）和 `reason`）
          - **要求**：追求"中性白"。如果画面发黄/发蓝，必须先归零色偏。
        - `color_grading_wheels`：颜色分级（highlights、midtones、shadows，每个字段包含 `hue`、`saturation`、`reason`）
          - `saturation`：**0 ~ 5 或 5 ~ 15**（根据 Phase 1 的色彩饱和度策略：低饱和风格为 0 ~ 5，鲜艳/自然风格可为 5 ~ 15。在低饱和风格中，色轮的 Saturation 值通常很低，只要一点点倾向就够了，不能给太多）
        - `hsl_detailed_12_colors`：HSL 12 色详细调整（red、orange、yellow、yellow_green、green、green_cyan、cyan、cyan_blue、blue、blue_purple、purple、magenta），每个颜色包含 `h`、`s`、`l`、`desc`）
          - **【重要】`desc` 字段要求**：必须使用简体中文描述调整原因，例如："完全去除，防止杂色。"、"去除沙滩中可能存在的暖土色。"、"提亮青色明度，使其更接近空气感的'白'。"
          - **前端显示要求**：`HSLVisualizer` 组件应在每个颜色通道下方显示 `desc` 字段内容，hover 时也应显示完整描述。
          - **HSL 高级逻辑**：根据 Phase 1 的色彩饱和度策略判断。如果是低饱和/静音风格，HSL 的首要任务是降低 Saturation，而不是提升 Luminance。如果是鲜艳/自然风格，必须遵循"明度 > 饱和度"原则，优先提升明度而非饱和度。
          - **蓝色 (Blue)**：
            - Hue: 向青色偏移 (-5 ~ -10) -> 看起来更清爽
            - Sat: **-40 ~ -20 或 +5 ~ +15**（根据 Phase 1 的色彩饱和度策略：低饱和风格为负值 -40 ~ -20，鲜艳/自然风格限制在 +15 以内）
            - Lum: **+10 ~ +30 或 -10 ~ +10**（根据 Phase 1 的色彩饱和度策略：鲜艳/自然风格必须为正值，低饱和风格可根据需要微调）
          - **绿色 (Green)**：
            - Hue: 向暖绿/黄绿偏移 (+10 ~ +20) -> 去除死板的深绿
            - Sat: **降低 (-10 ~ -20)** -> 避免荧光绿
            - Lum: 提升 (+10) -> 树叶透光感
      - `lightroom_workflow`：
        - `simulated_histogram`：预判调色后的直方图形态（`description`、`rgb_values`、`histogram_data`）
          - **后端提取**：`_format_lightroom` 方法从 `lightroom_workflow.simulated_histogram` 中提取 `description`、`rgb_values` 和 `histogram_data`，添加到 `structured.simulatedHistogram`
          - **前端显示**：`dataAdapter` 将 `structured.simulatedHistogram` 映射到 `result.lightroom.simulated_histogram`，并将 `histogram_data` 映射到 `result.lightroom.histogram`，用于前端显示
          - **字段格式**：
            - `description`：字符串，描述直方图形态（如："直方图整体大幅向右移动（高调）"）
            - `rgb_values`：对象，包含 `r`、`g`、`b` 三个整数值（0-255）
            - `histogram_data`：对象，包含 `r`、`g`、`b`、`l` 四个数组，每个数组包含 256 个值（对应亮度级别 0-255），值已归一化到 0-100
          - **要求**：通透照片的直方图最左端通常不触底（Fade Look）
          - **Prompt 要求**：Gemini 必须输出完整的 `histogram_data`，包含 256 个值，用于前端绘制直方图
        - `basic_panel`：基础面板（exposure、contrast、highlights、shadows、whites、blacks，每个字段包含 `val`（范围字符串）和 `reason`）
          - `contrast`：**范围 -10 ~ +5**（靠曲线做对比，不要靠滑块）
          - `highlights`：**-30 ~ -50**（保护云层和樱花细节）
          - `shadows`：**+20 ~ +40**（日系通透感的关键，提亮阴影）
          - `whites`：**+10 ~ +30**（拉开光比的关键，让白色更白）
          - `blacks`：**+5 ~ +15 或 -10 ~ -30**（根据 Phase 1 的影调强度评估：高调/柔美风格为正值，强力/戏剧性风格允许负值）
        - `presence`：存在感（texture、clarity、dehaze，每个字段包含 `val` 和 `reason`）
          - `texture`：+5 ~ +10（保留质感）
          - `clarity`：**-5 ~ +5**（严禁过高，否则画面变脏）
          - `dehaze`：**-5 ~ +5**（去雾功能会大幅增加饱和度和对比度，导致死黑。除非画面灰度极大，否则严禁超过 +10，甚至在日系风中应为负值 (-5 ~ -10) 以增加空气感）
        - `color_settings`：颜色设置（saturation、vibrance，每个字段包含 `val` 和 `reason`）
          - `saturation`：**-10 ~ -5 或 +0 ~ +5**（根据 Phase 1 的色彩饱和度策略：低饱和风格为负值，鲜艳/自然风格可为正值）
          - `vibrance`：**-20 ~ -10 或 +5 ~ +15**（根据 Phase 1 的色彩饱和度策略：低饱和风格为负值，鲜艳/自然风格可为正值）
        - `tone_curve`：色调曲线（`rgb_points`、`red_channel`、`green_channel`、`blue_channel` 为坐标点数组，`reason` 为解释）
          - **要求**：根据 Phase 1 的影调强度评估判断。如果是高调/柔美风格，RGB曲线必须描述为"J型"或"缓S型"，暗部端点(0,0)需上移至 (0, 10~20) 以制造哑光黑，提亮亮部，保持暗部柔和。如果是强力/戏剧性风格，必须使用强S型曲线，压实暗部以制造沉浸感，暗部端点可以保持在 (0, 0) 或略微上移，不再优先考虑暗部细节的通透性。
        - `split_toning_detail`：分离色调详情（highlights、shadows、balance，每个字段包含 `h`、`s`、`reason`）
      - `photoshop_workflow`：
        - `logic_check`：分析 LR 调整后的状态，指出 PS 需要补充的不足
        - `post_histogram_target`：PS 精修完成后的最终直方图理想状态（`description`、`zone_values`）
        - `camera_raw_filter`：Camera Raw 滤镜微调（`exposure_tweak`、`contrast_tweak`，每个字段包含 `val` 和 `reason`）
        - `ps_curves_adjustment`：PS 曲线调整（`rgb_tweak` 描述、`reason`）
        - `selective_color`：可选颜色（各颜色通道的调整值，如 `red_cyan`、`red_magenta` 等，每个字段包含 `val`（范围字符串）和 `reason`，以及 `settings` 说明混合模式和不透明度）
          - **针对"不通透"的修补**：
            - `black_cyan`：-5（黑色/中性色减少青色，修正环境色偏）
            - `black_magenta`：-2（黑色/中性色减少洋红，修正环境色偏）
            - `white_black`：-10（白色减少黑色，提亮高光纯净度）
        - `local_dodge_burn`：局部 Dodge & Burn（`target_area`、`method`、`brush_settings`、`reason`）
        - `atmosphere_glow`：氛围光晕（`method`、`steps`、`opacity`、`reason`）
        - `details_sharpening`：细节锐化（`method`、`radius`、`mode`、`reason`）
          - **Lab 模式明度通道锐化（高级技巧）**：仅在明度通道锐化，不破坏色彩信息，防止噪点增加。强化边缘线条的同时保持色彩纯净
        - `grain_texture`：颗粒纹理（`type`、`amount`、`size`、`roughness`、`reason`）
        - `vignette`：暗角（`amount`、`midpoint`、`roundness`、`feather`、`reason`）
        - `final_levels`：最终色阶（`input_black`、`input_white`、`midpoint`、`reason`）
    - **旧结构**（向后兼容）：
      - 原有的 `lightroom`、`lightroom_panels`、`photoshop`、`color_mapping` 结构
      - 基础滑块（exposure/contrast/highlights/shadows/whites/blacks/clarity/texture/dehaze/vibrance/saturation）
      - tone_curve、RGB 曲线、HSL、color_grading 等
    - **数据格式化**：
      - `_format_lightroom` 方法已更新，支持新结构（`lightroom_workflow`）和旧结构（`lightroom`、`lightroom_panels`）
      - `_format_photoshop` 方法已更新，支持新结构（`photoshop_workflow`）和旧结构（`photoshop.steps`）
      - `_format_color_part2` 方法已更新，支持新结构（`color_science_scheme`）和旧结构（`lightroom.temperature/tint`、`lightroom.color_grading`、`lightroom.HSL`）
      - 所有格式化方法都保持向后兼容，确保无论 Gemini 返回哪种格式，后端都能正确处理
    - **所有滑块值必须遵守**：
      - 字符串 + 显式正负号（新结构使用范围格式，如 `"+10 ~ +15"`）
      - tone_curve 5 点、RGB 曲线每通道 ≥ 4 点
      - 缺失数值由 schema 默认值填充，并在 `meta.warnings` 记录
    - **风格优先级覆盖机制遵守**（必须严格遵守）：
      - **根据 Phase 1 的"色彩饱和度策略"判断**：低饱和风格优先降饱和，鲜艳/自然风格优先提明度
      - **去雾值严禁超过 +10**（日系风应为负值 -5 ~ -10）
      - **对比度通过曲线实现**，不通过滑块（contrast 范围 -10 ~ +5）
      - **根据 Phase 1 的"影调强度评估"判断**：高调/柔美风格 Blacks 应为正值 (+5 ~ +20)，强力/戏剧性风格允许负值 (-10 ~ -30)
      - **RGB 曲线**：根据 Phase 1 的影调强度评估判断，高调/柔美风格暗部端点需上移至 (0, 10~20)，强力/戏剧性风格可以使用强S型曲线压实暗部
    - **Logic Check (逻辑自检)**：如果生成的 Saturation 总和超过 +50，必须触发自我修正，降低数值
    - **Reasoning (推理要求)**：每一个参数的 `reason` 字段，必须解释它如何贡献于"风格匹配度"（例如："提升蓝色明度是为了让天空更轻盈" 或 "降低蓝色饱和度是为了匹配参考图的低饱和电影风格，抽离杂色以获得静音感"），不能只是描述参数本身
    - 若 `feasibility_result` 判定不可行（Score < 0.3 或存在 deal-breakers），则：
      - 允许只输出"方向性参数"（偏中性曲线），但必须在 `workflow_alignment_notes` 中清晰声明"不建议按此参数强行复刻"，并引导用户重拍/更换目标。

- **23.3.1 直方图摘要字段（供曲线/色轮/报告解释使用）**
  - 虽然像素级直方图由前端/后端图像算法计算，但 Prompt 仍可要求模型输出“直方图形态摘要”，以便：
    - 在自然语言报告中解释“暗部/中间调/高光的占比与倾向”；
    - 在 JSON 中留下机器可读的结构供报告使用。
  - 建议的 JSON 结构（挂在 `sections.lighting.structured.histogram_overview` 或 `analysis_meta.image_histogram` 下）：
    ```json
    "histogram_overview": {
      "luminance_distribution": {
        "shadows": 0.25,
        "midtones": 0.55,
        "highlights": 0.20
      },
      "channel_balance": {
        "red": "slightly_dominant",
        "green": "balanced",
        "blue": "slightly_lower"
      },
      "shape": "midtones_peak_with_soft_shadows"
    }
    ```
  - 约束：
    - 模型不输出 256 维 bins，只输出归一化比例（0.0–1.0）和定性描述（`shape`）；
    - `analysisFormatter` 对该结构做 Schema 校验，失败则丢弃并记录 warning；
    - 真正的 bins 数据由前端 Canvas 或后端图像库计算，**Prompt 不承担像素级统计职责**。

- **23.4 Part3 Prompt（风格模拟 - 第三阶段开发）**
  - **角色设定**：拥有20年经验的高级数字影像技师 (DIT) 和商业修图师，精通 Adobe Lightroom Classic 和 Photoshop 的色彩科学。
  - **任务目标**：严格按照给定的色彩方案数据（Schema）对用户提供的原图（第二张图片）进行"冲印"和"显影"处理，使其风格与参考图（第一张图片）一致，生成照片级真实的图像。
  - **【重要】图片顺序说明（必须严格遵守）**：
    - **第一张图片 = 参考图 (Reference Image)**：目标风格图，用于理解目标色彩风格、影调特征和整体氛围，**不直接处理**，仅用于参考
    - **第二张图片 = 用户原图 (User Image / Source Image)**：需要处理的图片，**必须按照参考图的风格进行调色**
    - **Prompt 中必须明确标记**：在 Role、Input Data、Processing Instructions、Output Goal 等多个位置明确说明图片顺序，避免 Gemini 混淆
  - **输入数据**（根据用户需求更新）：
    1. **参考图 (Reference Image)**：作为**第一张图片**，用于理解目标风格的参考图片（base64）
    2. **用户原图 (User Image / Source Image)**：作为**第二张图片**，需要处理的图片（base64）
    3. **照片点评 (Photo Review)**：完整的 Part1 照片点评数据，包括：
       - `style_summary`：**风格克隆战略指导（最重要的字段）**，包含内容策略、影调重塑、色彩映射
       - `overviewSummary`：整体概览
       - `dimensions`：各维度分析（视觉引导、焦点曝光、色彩景深等）
       - `comparisonTable`：参数对比表
       - `feasibility`：可行性评估
    4. **色彩方案 (Color Grading Schema)**：完整的 Part2 输出，包括：
       - `whiteBalance`：白平衡（temperature、tint）
       - `grading`：色彩分级（highlights、midtones、shadows、balance）
       - `hsl`：HSL 调整（8 种颜色：红、橙、黄、绿、青、蓝、紫、洋红）
    5. **Lightroom 调整方案 (Lightroom Adjustment Schema)**：完整的 Lightroom 数据，包括：
       - `panels`：所有面板（6 个面板：基本面板、细节与质感、色彩调整、HSL/颜色、色调分离、色调曲线）
       - `toneCurve`：色调曲线（5 个控制点）
       - `rgbCurves`：RGB 曲线（红、绿、蓝三个通道）
       - `colorGrading`：色彩分级（高光、中间调、阴影的色相和饱和度）
    6. **Photoshop 调整方案 (Photoshop Adjustment Schema)**：完整的 Photoshop 数据，包括：
       - `steps`：所有步骤（ACR 滤镜、曲线调整、可选颜色、局部 Dodge & Burn 等）
  - **处理指令**：
    - **【重要】处理对象明确**：
      - **只处理第二张图片（用户原图）**
      - **参考第一张图片（参考图）的风格**进行调色
      - **严禁**修改画面内容、构图、人物面部特征或添加任何新物体
    - **Step 1: 基础影调重塑**：根据 Schema 中的 Exposure、Contrast、Highlights、Shadows、Temperature、Tint 调整**用户原图（第二张图片）**
    - **Step 2: 色彩分级**：根据 Schema 中的 HSL 数据和分离色调（Split Toning）调整**用户原图（第二张图片）**
    - **Step 3: 质感与氛围**：根据 Schema 中的曲线形态、颗粒（Grain）、暗角（Vignette）调整**用户原图（第二张图片）**
  - **负向约束（绝对禁止）**：
    - 禁止改变原有构图
    - 禁止改变人物的面部特征、表情或肢体动作
    - 禁止添加原图中不存在的物体（如云彩、飞鸟等）
    - 禁止过度 HDR 导致画面脏乱
  - **输出要求**：
    - **【重要】输出要求明确**：
      - 输出的是**用户原图（第二张图片）经过调色后的结果**
      - 这张图看起来应该就是用户原图，但经过了电影级的后期调色处理
      - **完美复刻参考图（第一张图片）的色彩风格**
      - 保持用户原图的构图、内容、人物特征不变，只改变光影和色彩
    - 输出分辨率：4K（3840x2160 或更高）
    - 保持原始图片的宽高比
    - 输出格式：JPEG，质量：高质量
    - 只输出图片，不返回 JSON 或其他文本
  - **模型选择评估**（根据 Google 官方文档确认）：
    - **Gemini 3 Pro 图片预览版（gemini-3-pro-image-preview）**：
      - **确认**：根据 [Google Gemini API 文档](https://ai.google.dev/gemini-api/docs/image-generation?hl=zh-cn&batch=file)，Gemini 3 Pro 图片预览版支持图片生成，可生成分辨率高达 4K 的图像
      - **优点**：更强的理解能力，能更好地理解复杂的色彩方案和风格分析；支持 4K 输出；使用 Google 搜索进行现实世界知识的接地；默认的"思考"过程（在生成之前优化构图）
      - **缺点**：延迟时间相对较高（高级功能需要更多计算资源）
      - **推荐**：**优先使用 Gemini 3 Pro 图片生成模型**，如果不支持或失败则回退到 Flash 模型
    - **Gemini 2.5 Flash Image（gemini-2.5-flash-image）**：
      - **优点**：明确支持图片生成，速度快，成本低；针对大批量、低延迟任务优化；生成 1024 像素分辨率的图片
      - **缺点**：理解能力相对较弱，可能无法完全理解复杂的色彩方案；分辨率较低（1024 像素）
      - **推荐**：作为回退方案，确保功能可用性
    - **最终策略**：优先使用 `gemini-3-pro-image-preview`，如果失败则自动回退到 `gemini-2.5-flash-image`
  - **实现要点**：
    - `StyleSimulationService.extract_color_grading_schema()` 从 `structured_result` 中提取完整的色彩方案数据：
      - **照片点评完整数据**（从 `sections.photoReview.structured` 提取）：
        - `style_summary`：风格克隆战略指导（最重要的字段），从 `photographerStyleSummary` 提取，如果没有则从 `overviewSummary` 提取
        - `overviewSummary`：整体概览
        - `dimensions`：各维度分析（视觉引导、焦点曝光、色彩景深等）
        - `comparisonTable`：参数对比表
        - `feasibility`：可行性评估
      - **Lightroom 完整调整方案**（从 `sections.lightroom.structured` 提取）：
        - `panels`：所有面板（6 个面板：基本面板、细节与质感、色彩调整、HSL/颜色、色调分离、色调曲线）
        - `toneCurve`：色调曲线（5 个控制点）
        - `rgbCurves`：RGB 曲线（红、绿、蓝三个通道）
        - `colorGrading`：色彩分级（高光、中间调、阴影的色相和饱和度）
      - **Photoshop 完整调整方案**（从 `sections.photoshop.structured` 提取）：
        - `steps`：所有步骤（ACR 滤镜、曲线调整、可选颜色、局部 Dodge & Burn 等）
      - **色彩方案完整数据**（从 `sections.color.structured` 提取）：
        - `whiteBalance`：白平衡（temperature、tint）
        - `grading`：色彩分级（highlights、midtones、shadows、balance）
        - `hsl`：HSL 调整（8 种颜色：红、橙、黄、绿、青、蓝、紫、洋红）
    - **【重要】变量命名规范**：
      - 照片点评数据变量名：`photo_review_data`（必须正确定义，不能使用未定义的变量）
      - 提取路径：`sections.get("photoReview", {}).get("structured", {})`
      - `style_summary` 字段映射：从 `structured.photographerStyleSummary` 提取，如果没有则从 `structured.overviewSummary` 提取
    - `StyleSimulationService.simulate_style()` 接收两张图片（参考图和用户图）和完整的色彩方案数据
      - **【重要】图片传递顺序**（必须严格遵守）：
        - **第一张图片**：参考图（`reference_image_data`）- 用于理解目标风格，不直接处理
        - **第二张图片**：用户原图（`user_image_data`）- 需要处理的图片，必须按照参考图的风格进行调色
        - **Prompt 文本**：包含完整的色彩方案数据和处理指令
      - **代码实现**：`style_simulation_service.py` 中 `contents` 数组的顺序为：参考图、用户图、Prompt 文本
    - `PromptTemplateService.get_part3_flash_prompt()` 使用新的 Prompt 模板，包含：
      - **【重要】图片顺序明确标记**：在 Role、Input Data、Processing Instructions、Output Goal 等多个位置明确说明图片顺序
        - 第一张图片 = 参考图（Reference Image）
        - 第二张图片 = 用户原图（User Image / Source Image）
      - 照片点评数据（尤其是 `style_summary` 字段的详细说明）
      - 色彩方案、Lightroom、Photoshop 的完整 JSON 数据
      - 详细的处理指令和约束
    - `GeminiService.generate_image()` 优先使用 `gemini-3-pro-image-preview`，失败则回退到 `gemini-2.5-flash-image`
    - 配置文件中新增 `GEMINI_IMAGE_MODEL` 环境变量，默认值为 `"gemini-3-pro-image-preview"`
    - 若 `feasibility_result` 表示不可行，应在调用前由后端阻断或降级处理（例如返回"无法提供风格模拟"的友好错误）

- **23.5 Feasibility Prompt（复刻可行性评估，与第 26 节联动）**
  - `getFeasibilityPrompt(referenceImage, userImage, exif)` 的具体输出约束见第 26 节：
    - Ginemi 必须按 L/C/S/P/D/T/Q/R 八个维度输出 score 与 reason；
    - 检测并列出所有 `dealBreakers[]`，并给出 `dominantFactors[]`、`recommendedActions[]`、`feasibilityScore/difficulty/confidence/explanation`；
    - 输出的 JSON 必须可被 `FeasibilitySchema` 解析，并写入 `analysis_tasks.feasibility_result`；
    - Part1/Part2 在生成自然语言和 JSON 时只能“引用/解释”可行性结果，不得与该结果矛盾。

### 24. 六大块前端字段协议表（Review / Composition / Lighting / Color / Lightroom / Photoshop）

> 目的：把前端六大分析块真实使用到的字段明确成协议表，约束 Prompt 输出与 `analysisFormatter` 映射，避免任何字段被遗漏或丢弃。

- **通用约定**
  - 所有字段最终都挂在 `analysis_tasks.structured_result.sections` 下，由前端 `App.tsx` 中的映射逻辑转换为前端的 `results` 对象：
    - `sections.photoReview` → `results.review`
    - `sections.composition` → `results.composition`
    - `sections.lighting` → `results.lighting`
    - `sections.color` → `results.color`
    - `sections.lightroom` → `results.lightroom` / `results.lightroom_extra`
    - `sections.photoshop` → `results.photoshop`
  - 自然语言原文：
    - 完整原文写入 `meta.rawNaturalLanguage`；
    - 分块自然语言写入 `sections.*.naturalLanguage.*`（不允许丢弃）；
    - `analysisFormatter` 负责把纯自然语言解析/整理为后文列出的结构化字段。
  - **前端映射实现**（`src/App.tsx`）：
    - `review`：从 `sections.photoReview.structured` 提取字段，包括 `comparisonTable`（参数对比表）
      - **重要**：`sections.photoReview` 包含 `naturalLanguage` 和 `structured` 两个字段
      - 前端必须从 `structured` 中提取 `overviewSummary`、`dimensions`、`comparisonTable` 等字段
      - `feasibility` 可能在 `structured.feasibility` 中，也可能在 `photoReview.feasibility` 顶层（向后兼容）
    - `composition`：从 `sections.composition.structured` 提取字段
      - **重要**：`sections.composition` 包含 `naturalLanguage` 和 `structured` 两个字段
      - 前端必须从 `structured` 中提取数据
      - 自动检测新结构（5字段：`main_structure`、`subject_weight`、`visual_guidance`、`ratios_negative_space`、`style_class`）或旧结构（7段：`advanced_sections`），向后兼容
    - `lighting`：从 `sections.lighting.structured` 提取字段
      - **重要**：`sections.lighting` 包含 `naturalLanguage` 和 `structured` 两个字段
      - 前端必须从 `structured` 中提取 `basic`、`texture`、`toneCurves` 等字段
    - `color`：直接展开 `sections.color.structured`

- **Review（照片点评） → `results.review`**
  - 前端字段：
    - `overviewSummary?: string`
    - `dimensions?: {`
      - `visualGuidance?: { title; referenceDescription; userDescription }`
      - `focusExposure?: { ... }`
      - `colorDepth?: {`
        - `title?: string`
        - `description?: string`
        - `histogramData?: {` ⭐ **新增字段**
          - `reference?: { description: string; data_points: number[] }` - 参考图直方图数据
          - `user?: { description: string; data_points: number[] }` - 用户图直方图数据
          - `}`
        - `}`
      - `composition?: { ... }`
      - `technicalDetails?: { ... }`
      - `equipment?: { ... }`
      - `colorEmotion?: { ... }`
      - `advantages?: { ... }`
      - `}`
    - `comparisonTable?: { dimension; reference; user }[]`
    - `photographerStyleSummary?: string`
    - `feasibility?: { conversion_feasibility; difficulty; confidence; limiting_factors; recommendation; notes? }`
    - `feasibilityDescription?: string`
  - 协议要求：
    - Prompt Part1 / Feasibility Prompt 中必须输出上述信息对应的自然语言段落；
    - `analysisFormatter` 从 `sections.photoReview.naturalLanguage.*` 和 `feasibility_result` 中提取并填充这些字段，缺失时写默认值并记录 `meta.warnings`。
    - **后端数据结构**（`sections.photoReview`）：
      - `naturalLanguage`: 包含 `summary`、`highlights`、`technique`、`comparison` 等自然语言字段
      - `structured`: 包含 `overviewSummary`、`dimensions`、`comparisonTable`、`photographerStyleSummary`、`feasibility` 等结构化字段
      - **重要**：`dimensions` 字段在 `structured` 中，前端必须从 `sections.photoReview.structured.dimensions` 提取
    - **Schema 验证**：
      - 使用 `PhotoReviewSchema` 验证，支持嵌套结构（`naturalLanguage` 和 `structured`）
      - 使用 `model_dump(exclude_none=True)` 排除 None 值，避免向后兼容字段干扰
    - **构图分析数据结构**（`sections.composition`）：
      - `naturalLanguage`: 包含 `framework`、`subjectWeight`、`leadingLines` 等自然语言字段
      - `structured`: 包含 `main_structure`、`subject_weight`、`visual_guidance`、`ratios_negative_space`、`style_class` 等结构化字段（新结构5字段）或 `advanced_sections`（旧结构7段）
      - **重要**：前端必须从 `sections.composition.structured` 提取数据
    - **光影参数数据结构**（`sections.lighting`）：
      - `naturalLanguage`: 包含 `exposureControl`、`toneCurve`、`textureClarity` 等自然语言字段
      - `structured`: 包含 `basic`（曝光控制）、`texture`（纹理与清晰度）、`toneCurves`（色调曲线）等结构化字段
      - **重要**：前端必须从 `sections.lighting.structured` 提取数据

- **Composition（构图分析） → `results.composition`**
  - 前端字段（新 Prompt 模版 - 方案A：5个独立卡片）：
    - `main_structure?: string` - 画面主结构分析
    - `subject_weight?: {`
      - `description?: string` - 主体位置、占比及权重
      - `layers?: string` - 前景/中景/远景分布
      - `}`
    - `visual_guidance?: {`
      - `analysis?: string` - 线条走向分析
      - `path?: string` - 视觉路径：入口点 -> 停留点 -> 终点
      - `}`
    - `ratios_negative_space?: {`
      - `entity_ratio?: string` - 实体比例（如："60%"）
      - `space_ratio?: string` - 留白比例（如："40%"）
      - `distribution?: string` - 留白分布位置
      - `}`
    - `style_class?: string` - 构图风格归类
  - 协议要求：
    - Prompt Part1 中必须输出上述五个字段的自然语言文本；
    - `sections.composition.structured` 直接使用新 Prompt 的 5 字段结构（`module_2_composition`），无需映射为 7 段；
    - 前端显示：采用方案A（5个独立卡片），每个字段对应一个卡片，`subject_weight` 和 `ratios_negative_space` 可显示子字段。
    - **前端映射实现**（`src/App.tsx`）：
      - 自动检测新结构（5字段）或旧结构（7段），向后兼容
      - 新结构：直接映射 `main_structure`、`subject_weight`、`visual_guidance`、`ratios_negative_space`、`style_class`
      - 旧结构：展开 `advanced_sections` 对象

- **Lighting（光影参数） → `results.lighting`**
  - 前端字段（新 Prompt 模版）：
    - `basic?: {`
      - `exposure?:   { range: string; note?: string }` - 从"范围+描述"格式解析
      - `contrast?:   { range: string; note?: string }`
      - `highlights?: { range: string; note?: string }`
      - `shadows?:    { range: string; note?: string }`
      - `whites?:     { range: string; note?: string }`
      - `blacks?:     { range: string; note?: string }`
      - `}`
    - `toneCurves?: {` ⭐ **新增字段**
      - `explanation?: string` - 曲线调整逻辑说明
      - `points_rgb?: Array<{x: number, y: number}>` - RGB 曲线坐标点数组（对象格式）
      - `points_red?: Array<{x: number, y: number}>` - 红色通道曲线坐标点数组（对象格式）
      - `points_green?: Array<{x: number, y: number}>` - 绿色通道曲线坐标点数组（对象格式）
      - `points_blue?: Array<{x: number, y: number}>` - 蓝色通道曲线坐标点数组（对象格式）
      - `}`
      - **【重要】曲线绘制规范（符合后期领域图像规范）**：
        - 曲线必须包含起点 `{x: 0, y: 0}` 和终点 `{x: 255, y: 255}`，确保与坐标轴相交
        - 曲线必须是一条平滑的曲线（使用贝塞尔曲线或 Catmull-Rom 样条曲线），不能是折线
        - 如果 Gemini 输出为空或缺少起点/终点，后端自动补充；前端也进行二次验证和补充
        - 前端使用平滑的贝塞尔曲线绘制，而不是直线连接（`L` 命令）
        - 如果某个通道不需要调整，也必须输出起点和终点，不能输出空数组
    - `texture?: {`
      - `texture?:    { range: string; note?: string }` - 从"范围+描述"格式解析
      - `clarity?:    { range: string; note?: string }`
      - `dehaze?:     { range: string; note?: string }`
      - `}`
  - 协议要求：
    - **Prompt Part1 中必须明确要求 Gemini 输出完整的曲线点**：
      - 所有曲线点必须使用对象格式：`{"x": 0, "y": 0}`，其中 x 和 y 都是 0-255 的整数
      - **必须包含起点和终点**：起点 `{"x": 0, "y": 0}`，终点 `{"x": 255, "y": 255}`
      - 中间控制点：根据曲线形状添加 3-5 个中间点
      - 如果某个通道不需要调整，也必须输出起点和终点，不能输出空数组
    - Prompt Part1 中必须使用"范围+描述"格式，例如："+0.3～+0.6，轻微提升使高光有"柔光""，`analysisFormatter` 负责：
      - 解析出标准数值字符串（`range`，如 `"+0.45"`，取范围中值或单个值）；
      - 把描述性句子写入 `note`（如："轻微提升使高光有"柔光""）；
      - 若只给出模糊描述（"微调"），则 `range` 使用默认值 `"+0"`，`note` 保留原文。
    - **后端 `analysisFormatter` 负责**：
      - **【重要修复】不自动增补点**：严格按照 Gemini 输出的点绘制，不强制添加 (0, 0) 和 (255, 255)
      - Gemini 输出的点（如 {x: 0, y: 30}）已经是曲线的起点，不需要再添加 (0, 0)
      - 统一曲线点格式为对象数组格式 `{x, y}`
      - 按 x 坐标排序，确保曲线点顺序正确
      - 如果 Gemini 输出为空，返回空数组（不绘制曲线）
    - **前端绘制要求**：
      - **【重要修复】2D 平面视图**：移除所有 3D 效果（rotateX, rotateY, translate-z, perspective 等），使用纯 2D 平面视图
      - **【重要修复】不自动增补点**：严格按照 Gemini 输出的点绘制，不强制添加 (0, 0) 和 (255, 255)
      - 使用平滑的贝塞尔曲线（Catmull-Rom 样条曲线）绘制，而不是直线连接
      - 2 个点：使用直线连接
      - 3 个或更多点：使用三次贝塞尔曲线（C）近似 Catmull-Rom 样条曲线
      - 确保曲线通过所有控制点，且曲线平滑连续
      - 如果数据为空，不绘制曲线（而不是显示默认线段）
      - **【新增】点值标签**：在每个控制点上显示通道标识（RGB/R/G/B）和坐标值 (x, y)
      - **【新增】智能标签位置**：根据点的位置智能调整标签位置，避免标签重叠和超出边界

- **Color（色彩方案） → `results.color_scheme` 或 `results.color`**
  - 前端字段：
    - `styleKey: string` 或 `style_key_points: string`  // 风格关键词（向后兼容）
    - **【新增】色彩策略三字段（用于前端色彩策略卡片展示）**：
      - `master_style_recap: string`  // 主风格回顾（流派识别），例如："日系冬日极简 / 高调空气感 (Japanese Winter High-Key)"
      - `style_summary_recap: string`  // 风格总结回顾（Phase 1 核心指导思想），例如："基于参考图的[Ethereal High-Key Strategy]与[Cool Desaturation Mapping]，核心在于..."
      - `key_adjustment_strategy: string`  // 关键调整策略（三大动作），例如："1. 激进的阴影提亮与黑位哑光化... 2. 负向清晰度与去朦胧... 3. 全局低饱和冷色映射..."
    - `whiteBalance: {`
      - `temp: { range: string; note?: string }`
      - `tint: { range: string; note?: string }`
      - `}`
    - `grading: {`
      - `highlights: { hue: number | string; saturation: number | string; reason: string }`  // 【重要】reason 字段用于前端显示调整原因描述
      - `midtones:   { hue: number | string; saturation: number | string; reason: string }`  // 【重要】reason 字段用于前端显示调整原因描述
      - `shadows:    { hue: number | string; saturation: number | string; reason: string }`  // 【重要】reason 字段用于前端显示调整原因描述
      - `balance:    number | string`
      - `}`
    - `hsl: Array<{`
      - `color: string;           // "红/橙/黄/绿/青/蓝/紫/洋红"`
      - `hue: string;             // "±xx"`
      - `saturation: string;      // "±xx"`
      - `luminance: string;       // "±xx"`
      - `note?: string;           // 【重要】HSL 调整原因描述（后端将 Gemini 的 desc 字段映射到 note）`
      - `desc?: string;           // 【新增】HSL 调整原因描述（Gemini 原始字段，前端优先使用）`
      - `}>`
      - **前端显示要求**：`HSLVisualizer` 组件应在每个颜色通道下方显示 `desc` 或 `note` 字段内容，帮助用户理解调整原因。hover 时也应显示完整描述。
  - 协议要求：
    - **Prompt Part2 必须输出 `phase_1_extraction` 对象**，包含三个字段：
      - `master_style_recap`: 确认识别到的流派（必须使用简体中文）
      - `style_summary_recap`: 简要回顾 Phase 1 的核心指导思想（必须使用简体中文）
      - `key_adjustment_strategy`: 总结三大关键调整动作（必须使用简体中文）
    - Prompt Part2 中必须输出可解析的 HSL / 色彩分级描述（可以是自然语言，但要包含具体数值或“略微/明显”等可推断信息）；
    - `analysisFormatter`：
      - **从 `raw.phase_1_extraction` 中提取三个字段**，放入 `structured.master_style_recap`、`structured.style_summary_recap`、`structured.key_adjustment_strategy`
      - **从 `raw.color_grading_wheels` 中提取 `reason` 字段**，放入 `structured.grading.highlights.reason`、`structured.grading.midtones.reason`、`structured.grading.shadows.reason`（用于前端显示调整原因描述）
      - **从 `raw.hsl_detailed_12_colors` 中提取 `desc` 字段**，放入 `structured.hsl[].note`（后端将 `desc` 映射到 `note` 字段，前端优先使用 `desc`，如果没有则使用 `note`）
      - 把自然语言解析为 `hue/saturation/luminance` 字符串（`"+10"` 等），解析失败时用默认 `"0"` 并把原文写入 `note`；
      - 把"三段色彩分级"解析为 `grading` 的 `highlights/midtones/shadows/balance`，解析不到时给默认中性值并写 warning。
      - **前端显示要求**：
        - `ColorGradeWheel` 组件应在 hover 时显示 `reason` 字段内容，帮助用户理解调整原因。
        - `HSLVisualizer` 组件应在每个颜色通道下方显示 `desc` 或 `note` 字段内容，hover 时也应显示完整描述。
    - **Pydantic Schema 要求**：
      - `ColorStructuredSchema` 中**必须定义**三个字段：`master_style_recap`、`style_summary_recap`、`key_adjustment_strategy`
      - 必须设置 `model_config = {"extra": "allow"}`，避免 Pydantic 验证时过滤掉未定义的字段

- **Lightroom（LR 参数 + 可行性） → `results.lightroom` / `results.lightroom_extra`**
  - 主参数 `results.lightroom: LightroomPanel[]`：
    - `title: string`                        // 面板标题：根据设计规范，必须包含 6 个面板：
      - "基本面板"（原"基础调整"）：基础曝光和对比度调整
      - "细节与质感"（原"存在感"）：纹理、清晰度和去雾调整
      - "色彩调整"（原"颜色设置"）：饱和度和自然饱和度调整
      - "HSL/颜色"：色相、饱和度和明度调整
      - "色调分离"：高光和阴影的色调分离调整
      - "色调曲线"：RGB 和单通道曲线调整
    - `params: { name: string; value: string; reason?: string }[]`
    - `note?: string`
    - `masks?: { title: string; description: string; params: { name; value }[] }[]`
  - 可行性与调色思路 `results.lightroom_extra`（对应可行性评估 + LR 卡片概要）：
    - `conversion_feasibility: {`
      - `can_transform: boolean`
      - `difficulty: string`
      - `confidence: number`
      - `limiting_factors?: string[]`
      - `recommendation?: string`
      - `}`
  - 协议要求：
    - Prompt Part2 中对 LR 面板可以先给自然语言（“基础面板曝光+0.3，高光-40…”），也可以给半结构化文本；
    - `analysisFormatter` 必须：
      - 将所有 LR 参数转成固定 `params[]` 列表，`value` 统一使用字符串 + 显式正负号；
      - 从 `workflow_alignment_notes` / 可行性 JSON 中填充 `conversion_feasibility`；
      - 对局部调整蒙版仅保留能映射到 UI 的必要字段，其余原文作为 `notes`。

- **Photoshop（PS 步骤） → `results.photoshop`**
  - 前端字段（数组，每一项为一个步骤）：
    - `title: string`
    - `description: string`
    - `params?: { name: string; value: string; reason?: string }[]`
    - `details?: string`
    - `blendMode?: string`
    - `opacity?: string`
  - 协议要求：
    - Prompt Part2 对 PS 步骤的输出可采用“逐步说明 + 参数列表”的自然语言形式；
    - `analysisFormatter` 将各步骤的自然语言拆解为 `steps[]`：
      - `title` 来自步骤标题或序号；
      - `description` 是步骤概括；
      - 文本中的参数对（“曝光+0.3、对比+10…”）被解析为 `params[]`；
      - 图层混合模式/不透明度从文本中抽取到 `blendMode` / `opacity`；
      - 无法结构化的说明统一放到 `details`。

### 25. 帐号与权限体系细化（结合顶层设计）

- **身份与角色模型**
  - `users` 表：
    - 基础字段：`id`、`email/phone`、`password_hash`、`display_name`、`avatar_url`、`status`（active/disabled）、`created_at/updated_at`；
    - 角色字段：`role ENUM('user','admin') DEFAULT 'user'`；如需多角色，则增加 `roles`、`role_permissions`、`user_roles` 三张表，支持一人多角色（参见顶层设计 3.5）。
  - `auth_tokens` 表：
    - 字段：`id`、`user_id`、`type`（`session` / `admin_session` / `email_otp` / `admin_mfa` 等）、`token`（或其哈希）、`expired_at`、`consumed`、`created_at`；
    - 用途：统一管理所有登录会话与一次性验证码，支持单点登出与安全审计。
  - 审计与安全表：
    - `login_attempts`：记录所有登录成功/失败（含 IP、User-Agent、result），支持风控与锁定策略；
    - `audit_logs`：记录管理后台关键操作（创建/修改/删除用户、订阅、任务、配置等）。

- **JWT 载荷与 Token 类型**
  - 主站用户 `session`（普通用户）：
    - `sub`: userId
    - `type`: `"session"`
    - `role`: `"user"`（或来自 `users.role`）
    - `exp`: 过期时间（例如 2 小时）
  - 管理后台 `admin_session`：
    - `sub`: adminUserId
    - `type`: `"admin_session"`
    - `role`: `"admin"`
    - `permissions?`: 字符串数组，可用于前端控制菜单与按钮；
    - `exp`: 更短的有效期（例如 1 小时），配合 `admin_mfa` 使用更安全。

- **后端中间件映射**
  - `authMiddleware`：
    - 从 `Authorization: Bearer <JWT>` 解析 Token；
    - 校验签名、过期时间，并从 `auth_tokens` 表检查是否已吊销；
    - 在通过后注入 `req.user = { id, role, type }`；
    - 仅允许 `type = 'session'` 访问主站接口。
  - `requireAdmin`：
    - 在 `authMiddleware` 后执行，要求：
      - `req.user.type === 'admin_session'`
      - `req.user.role === 'admin'`
    - 如开启细粒度权限，则再检查 `req.user.permissions` 是否包含所需权限；
    - 所有 `/api/admin/**` 路由必须挂载该中间件。
  - `authMiddlewareForQuery`（下载专用）：
    - 从 Query 中读取 `downloadToken`，在 `auth_tokens` 表中校验其有效性与所属用户；
    - 将 `req.user` 设置为对应用户，并在使用后标记该 token 为 `consumed`；
    - 应用于 `/api/export/xmp|jsx|json|pdf` 等导出接口。

- **前端对应实现**
  - 主站前端：
    - 登录成功后，后端返回：
      - `accessToken`（JWT，type=`session`）；
      - `user`（`id`、`display_name`、`role`、`avatar_url` 等）；
    - `AuthContext` / `userStore` 负责保存 `accessToken` 与 `user`，并在 `api.ts` 请求拦截器中自动附带 `Authorization` 头；
    - 当收到 `401/UNAUTHORIZED` 时：
      - 清理本地 Token；
      - 跳转登录页或弹出登录对话框。
  - 管理后台前端：
    - 管理员登录页调用 `POST /api/admin/auth/login`；
    - 成功后将 `adminAuthToken`（`admin_session` JWT）保存到 `localStorage`，并缓存 `adminUser`（含 `permissions`）；
    - `adminApi` 封装所有 `/api/admin/**` 请求，统一附带 `Authorization: Bearer <admin_session>`；
    - 收到 `403/ADMIN_PERMISSION_DENIED` 时，提示权限不足，并根据 `permissions` 动态隐藏功能入口。

- **安全与锁定策略**
  - 管理员登录安全：
    - 连续失败次数超过 `AUTH_ADMIN_MAX_FAILED_ATTEMPTS` 时，在 `login_attempts` 中记录并锁定账号 `AUTH_ADMIN_LOCK_MIN` 分钟；
    - 登录成功后下发一次性 `admin_mfa`（邮箱验证码或 TOTP），验证通过后才生成 `admin_session`。
  - 普通用户安全：
    - 可选启用登录失败次数限制；
    - 对重要操作（删除任务、取消订阅等）增加二次确认或邮箱验证码；
    - 所有 Token 操作（创建/失效）落到 `auth_tokens` 与 `audit_logs` 表，方便事后审计。

#### 25.1 注册流程详细设计

- **邮箱注册流程（主要方式）**
  - 用户填写邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 设置密码 → 注册成功 → 自动登录
  - **接口**：
    - `POST /api/auth/send-verification-code`：发送验证码（`type="register"`）
    - `POST /api/auth/register`：提交注册（邮箱+验证码+密码）
  - **后端逻辑**：
    - 检查邮箱是否已注册（已注册返回错误）
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="email_otp"`, `expired_at=当前时间+10分钟`）
    - 调用阿里云邮件服务发送验证码（模板ID: `417051`）
    - 验证码验证通过后创建用户（`role="user"`, `status="active"`）
    - 自动创建免费版订阅（`analysis_per_month: 10`, `generations_per_month: 5`）
    - 生成 JWT Token（`type="session"`）并返回
  - **前端实现**：
    - `RegisterDialog.tsx`：显示邮箱输入、验证码输入（带倒计时）、密码输入
    - 验证码倒计时 60 秒，防止频繁发送
    - 注册成功后保存 `accessToken` 到 `localStorage`，关闭对话框

- **手机号注册（可选，当前迭代暂不实现）**
  - 保留 UI，但后端暂不实现，前端显示"功能开发中"提示

- **微信登录（可选，当前迭代暂不实现）**
  - 保留 UI，但后端暂不实现，前端显示"功能开发中"提示

#### 25.2 登录流程详细设计

- **普通用户登录（邮箱+密码）**
  - 用户输入邮箱和密码 → 点击"登录" → 后端验证 → 生成 Token → 返回用户信息
  - **接口**：`POST /api/auth/login`
  - **后端逻辑**：
    - 查询用户（`users` 表）
    - 验证密码（bcrypt）
    - 检查账号状态（`status="active"`）
    - 生成 JWT Token（`type="session"`）
    - 保存 Token 到 `auth_tokens` 表
    - 返回 `{ accessToken, user }`
  - **前端实现**：
    - `LoginDialog.tsx`：显示邮箱输入、密码输入
    - 登录成功后保存 `accessToken` 到 `localStorage`，关闭对话框

- **普通用户登录（邮箱+验证码）**
  - 用户输入邮箱 → 点击"获取验证码" → 后端发送验证码邮件 → 用户输入验证码 → 登录成功
  - **接口**：
    - `POST /api/auth/send-verification-code`：发送验证码（`type="login"`）
    - `POST /api/auth/login-with-code`：提交登录（邮箱+验证码）
  - **后端逻辑**：
    - 检查邮箱是否已注册（未注册返回错误）
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="email_otp"`, `user_id=用户ID`）
    - 调用阿里云邮件服务发送验证码
    - 验证码验证通过后生成 JWT Token（`type="session"`）
    - 返回 `{ accessToken, user }`
  - **前端实现**：
    - `LoginDialog.tsx`：添加"密码登录"和"验证码登录"切换选项
    - 验证码登录表单：邮箱输入、验证码输入（带倒计时按钮）
    - 验证码倒计时 60 秒，防止频繁发送

- **管理员登录（邮箱+密码+验证码，两步验证）**
  - 第一步：用户输入邮箱和密码 → 后端验证 → 发送验证码邮件 → 返回 `mfaToken`
  - 第二步：用户输入验证码 → 后端验证 → 生成 `admin_session` Token
  - **接口**：
    - `POST /api/admin/auth/login`：第一步（邮箱+密码）
    - `POST /api/admin/auth/verify-mfa`：第二步（`mfaToken`+验证码）
  - **后端逻辑**：
    - 第一步：验证密码，检查账号状态和角色（`role="admin"`），检查是否锁定
    - 生成 6 位数字验证码，保存到 `auth_tokens` 表（`type="admin_mfa"`, `user_id=管理员ID`）
    - 调用阿里云邮件服务发送验证码
    - 返回临时 `mfaToken`（用于第二步验证）
    - 第二步：验证 `mfaToken` 和验证码，生成 JWT Token（`type="admin_session"`）
    - 返回 `{ adminAuthToken, adminUser }`
  - **前端实现**：
    - `AdminLoginDialog.tsx`：两步登录流程
    - 第一步：邮箱+密码输入
    - 第二步：验证码输入（带倒计时按钮）
    - 登录成功后保存 `adminAuthToken` 到 `localStorage`（与普通用户 Token 分开存储）

#### 25.3 邮箱验证码服务设计（阿里云）

- **配置信息**：
  - 发信域名：`t-react.com`
  - 发信地址：`noreply@t-react.com`
  - 验证码邮件模版ID：`417051`
  - RAM 用户登录名称：`quantanova2025@1849721908321781.onaliyun.com`
  - AccessKey ID：`<请从环境变量或配置文件中获取>`
  - AccessKey Secret：`<请从环境变量或配置文件中获取>`

- **后端实现**：
  - 服务文件：`server_py/app/services/email_service.py`
  - 功能：`send_verification_code(email: str, code: str, type: str = "register") -> bool`
  - 依赖：`alibabacloud-dm20151123`
  - 配置：在 `server_py/app/config.py` 中添加 `ALIYUN_ACCESS_KEY_ID`、`ALIYUN_ACCESS_KEY_SECRET`、`ALIYUN_EMAIL_FROM`、`ALIYUN_EMAIL_TEMPLATE_ID`
  - **响应检查**：阿里云 SDK 的响应对象没有 `status_code` 属性，需要通过检查 `response.body` 或异常来判断成功/失败。如果没有异常抛出，通常表示请求成功。

- **验证码生成与存储**：
  - 生成规则：6 位数字验证码（000000-999999），使用 `secrets.randbelow(1000000)` 生成
  - 存储表：`auth_tokens`
  - 字段：`type`（`"email_otp"` 或 `"admin_mfa"`）、`token`（验证码字符串）、`user_id`（注册时为 NULL，登录时为对应用户 ID）、`expired_at`（当前时间 + 10 分钟）、`consumed`（`False`）
  - 验证逻辑：查询 `auth_tokens` 表，检查验证码、过期时间、是否已消费，验证通过后标记为已消费

- **防刷机制**：
  - 同一邮箱 60 秒内只能发送一次验证码
  - 验证码有效期 10 分钟
  - 验证码使用后立即标记为已消费，不能重复使用

#### 25.4 强制登录检查实现

- **后端权限控制**：
  - 修改 `HTTPBearer` 为强制要求：在 `server_py/app/middleware/auth.py` 中，将 `security = HTTPBearer()` 改为 `security = HTTPBearer(auto_error=True)`
  - 接口分类：
    - **普通用户接口**（需要 `type="session"`）：
      - `/api/photos/upload` - 上传图片
      - `/api/analyze/*` - 所有分析接口（feasibility, part1, part2, getTask, history）
      - `/api/simulate/*` - 风格模拟
      - `/api/export/*` - 导出（XMP/JSX/JSON/PDF）
      - `/api/user/*` - 用户相关（me, usage, reports, profile, change-password）
    - **管理员接口**（需要 `type="admin_session"` 且 `role="admin"`）：
      - `/api/admin/*` - 所有管理后台接口
    - **公开接口**（不需要登录）：
      - `/api/auth/register` - 注册
      - `/api/auth/login` - 登录（邮箱+密码）
      - `/api/auth/login-with-code` - 登录（邮箱+验证码）
      - `/api/auth/send-verification-code` - 发送验证码
      - `/api/admin/auth/login` - 管理员登录（第一步）
      - `/api/admin/auth/verify-mfa` - 管理员验证码验证
      - `/health` - 健康检查

- **前端权限控制**：
  - API 调用拦截：在 `src/lib/api.ts` 的 `request` 和 `uploadRequest` 函数中，如果收到 401 错误，自动清除 Token 并弹出登录对话框
  - 功能入口拦截：`App.tsx` 的 `handleAnalyze` 在开始分析前检查登录状态，未登录则弹出登录对话框
  - 路由保护：为需要登录的页面添加路由守卫（当前项目使用页面状态管理，在 `App.tsx` 中检查即可）

#### 25.5 订阅体系集成

- **新用户默认订阅**：
  - 注册成功后自动创建免费版订阅（`plan_id=1`，`status="active"`）
  - 免费版限制：`analysis_per_month: 10`（Part1+Part2 计 1 次），`generations_per_month: 5`（Part3 计 1 次）
  - 订阅记录保存在 `subscriptions` 表，关联到 `users.id`

- **用量检查**：
  - 在调用分析接口前检查用户用量是否超出限制
  - 接口：`usage_service.check_usage(db, user_id, usage_type)`
  - 检查逻辑：
    - 获取用户当前订阅（`subscriptions` 表，`status="active"`）
    - 获取订阅计划限制（`subscription_plans.features`）
    - 统计本月已用次数（`analysis_tasks` 表，按 `created_at` 在当月）
    - 如果超出限制，返回错误码：`USAGE_ANALYSIS_LIMIT_EXCEEDED` 或 `USAGE_GENERATION_LIMIT_EXCEEDED`
  - 前端处理：显示"升级套餐"提示，阻止进一步点击

- **管理员变更订阅计划**：
  - 接口：`PUT /api/admin/subscriptions/users/{subscriptionId}`
  - 请求体：`{ plan_id, status?, end_at?, auto_renew?, reason? }`
  - 用途：测试、补偿、促销、调试
  - 权限：仅管理员可调用
  - 立即生效：变更后用户立即享受新计划的限制

### 26. 复刻可行性评估算法与 Feasibility Prompt 设计

- **评估目标与维度补充**
  - 目标：在用户进入 Part1 正式分析之前，用一次轻量级但专业的评估，判断“这两张图是否有足够条件做高质量仿色”，避免无效等待。
  - 评估维度（每一项都要产出量化指标 + 文本说明）：
    - 光线（L）：方向 / 强度 / 硬软 / 光源类型 / 高光-暗部对比 / 阴影扩散；
    - 色彩（C）：主导色 / 配色板 / 色彩直方图 / 色温 / 色域；
    - 场景元素与语义（S）：主体类别与语义分布是否相似（人物/天空/植被/建筑等）；
    - 构图与透视（P）：主体相对位置、比例、视角与透视关系；
    - 动态属性（D）：是否存在长曝/运动模糊/流水/星轨等难以复刻的动态效果；
    - 纹理与噪点（T）：胶片颗粒、人造噪点、锐度差异；
    - 图像质量与分辨率（Q）：分辨率、压缩伪影、SNR；
    - 后期特征（R）：明显 vignette、渐变映射、特殊 LUT/滤镜；
    - 可选：EXIF/元数据（拍摄时间/光圈/快门/ISO/焦距/白平衡）与语义可替代性（是否存在可裁切对齐的区域）。

- **指标体系与权重（score_i ∈ [0,1]）**
  - 每个维度输出 0.0–1.0 的相似/可行性得分，权重总和 = 1.0，可后续通过数据调整：
    - L 光线相似度：0.25
    - C 色彩相似度：0.20
    - S 语义/场景相似度：0.18
    - P 构图/透视相似度：0.12
    - D 动态/曝光属性：0.05
    - T 纹理/颗粒相似度：0.05
    - Q 分辨率与质量：0.03
    - R 后期特征：0.07
  - 具体实现：
    - 第一期可以由 Gemini 直接给出每一项 score 与 reason（model-based estimation）；
    - 后续可将部分维度替换为独立 CV 模型（语义分割、直方图相似度等）计算，再交由 Gemini 做解释与整合。

- **致命不兼容因子（Deal-breakers）**
  - 若出现以下任一情况，直接判定不可复刻（FeasibilityScore = 0，difficulty = "极高/不建议"），并在结果中写明原因：
    - 拍摄时间/环境强矛盾：一张夜景另一张白天，或明显室内 vs 室外；
    - 主体类型不匹配：目标图为人像，用户图为纯城市风景，且无可裁切替代区域；
    - 极端镜头差异：一张为微距/极广角，一张为远景航拍，主体 scale 完全不在同一量级；
    - 特殊光学/合成效果：长曝星轨、多重曝光、复杂合成，无法用常规 LR/PS 调色复刻；
    - 明显法律/版权/人像规则限制（如检测到第三方敏感素材）——可直接业务层禁止。
  - 当触发 deal-breaker 时，`dealBreakers[]` 必须列出具体原因，前端弹窗提示用户“无法复刻，并给出替代建议（更换目标图/重新拍摄等）”。

- **综合评分公式与难度/置信度**
  - 可行性得分（0.0–1.0）：
    - `FeasibilityScore = Σ weight_i * score_i`
  - 难度映射（示例，可配置）：
    - `FeasibilityScore ≥ 0.75` → 难度 = `"低"`（高可行性，容易复刻）；
    - `0.50 ≤ Score < 0.75` → 难度 = `"中"`；
    - `0.30 ≤ Score < 0.50` → 难度 = `"高"`；
    - `Score < 0.30` → 难度 = `"极高/不建议"`（可视作基本不可行）；
  - 置信度（0.0–1.0）示例公式：
    - `Confidence = min(1.0, 0.7 * (1 - uncertainty_from_metrics) + 0.3 * meta_confidence)`
    - 其中：
      - `uncertainty_from_metrics` 来自各子指标置信（由模型或算法提供），越不确定值越大；
      - `meta_confidence` 取决于 EXIF 完整度、图像质量等元数据可靠性。

- **Feasibility 结果 JSON 结构**
  - 存储在 `analysis_tasks.feasibility_result`，用于模态框和六大块的渲染与解释：
    ```json
    {
      "feasibilityScore": 0.614,
      "difficulty": "中",
      "confidence": 0.78,
      "dealBreakers": ["目标为夜景，用户图为强烈日光"],
      "dominantFactors": [
        { "name": "色彩相似度", "score": 0.45, "weight": 0.20, "reason": "色温差 180K，主色偏蓝" },
        { "name": "语义相似度", "score": 0.90, "weight": 0.18, "reason": "主体均为人像，背景简单" },
        { "name": "光线相似度", "score": 0.55, "weight": 0.25, "reason": "光源方向相差约 30°" }
      ],
      "recommendedActions": [
        { "action": "统一白平衡", "why": "色温差距导致肤色/天空偏差" },
        { "action": "尝试裁切目标图天空区域", "why": "提升语义重叠度" }
      ],
      "metrics": {
        "L": 0.55, "C": 0.45, "S": 0.90, "P": 0.70,
        "D": 0.80, "T": 0.60, "Q": 0.95, "R": 0.60
      },
      "explanation": "总体可行，但需先从白平衡和暗部调整入手，否则肤色与天空区域会存在明显差异。"
    }
    ```

- **Feasibility Prompt 设计与 Gemini 引导**
  - 细化 `getFeasibilityPrompt(referenceImage, userImage, exif)` 的输出要求（与第 23 节保持一致）：
    - 按上述 8 个维度输出：
      - 每个维度的 `score ∈ [0,1]`；
      - 简短的 `reason`（中文解释）；
    - 检测并列出所有 `dealBreakers[]`（如存在）；
    - 给出 `dominantFactors[]`（Top-3 拖累项，包含 name/score/weight/reason）；
    - 给出 `recommendedActions[]`（针对本次拍摄的具体建议）；
    - 给出整体 `FeasibilityScore`、`difficulty`、`confidence`，以及一段自然语言 `explanation`。
  - Prompt 末尾必须给出严格 JSON skeleton，约束字段名与范围，禁止新增字段，确保 `FeasibilitySchema` 可稳定解析。
  - 后端 `feasibilityService` 可以：
    - 直接使用模型给出的 `score_i` 和 `FeasibilityScore`；
    - 或在 Schema 校验后自行重算 `FeasibilityScore` 与 `difficulty`，以保证数值一致性。

- **API 与前端弹窗流程**
  - 接口：`POST /api/analyze/feasibility`
    - 入参：
      - `sourceImage`（必填）：参考图，base64 字符串或 data URL 格式（如 `data:image/jpeg;base64,...`）
      - `targetImage`（必填）：用户图，base64 字符串或 data URL 格式（如 `data:image/jpeg;base64,...`）
      - `taskId`（可选）：任务 ID，用于关联可行性结果
    - 请求格式：`multipart/form-data`（前端使用 `FormData.append()` 发送字符串）
    - 返回：上文 JSON 结构，同时写入 `analysis_tasks.feasibility_result`（若已有 `taskId`），或先在 `uploads` 侧缓存等待与任务关联。
    - 错误处理：
      - 400 Bad Request：参数验证失败（如缺少必需参数、图片数据为空、参数类型不匹配）
        - **后端验证**：后端会进行三步验证（None 检查、类型检查、空值检查），记录详细的验证错误日志（字段、类型、消息），便于排查问题
        - **前端验证**：前端在发送请求前也会进行参数验证，如果 `sourceImage.preview` 或 `targetImage.preview` 为空，会显示友好的错误提示，不发送请求
        - **错误消息**：前端会收到友好的错误消息，避免暴露技术细节
        - **可能原因**：
          1. Form 数据解析失败（RequestValidationError）：可能是数据格式不正确、字段名不匹配、数据太大（超过 100MB 限制）
          2. 参数类型不匹配：期望字符串但收到其他类型
          3. 缺少必需参数：sourceImage 或 targetImage 未提供
          4. 数据值错误：图片数据为空或格式不正确
        - **排查方法**：
          1. 检查后端日志中的【参数验证错误】前缀，查看详细的错误信息
          2. 检查前端浏览器控制台的网络请求，查看请求体大小和 Content-Type
          3. 确认前端发送的字段名与后端期望的一致（sourceImage、targetImage）
          4. 确认图片数据格式正确（data URL 格式：data:image/jpeg;base64,...）
      - 401 Unauthorized：用户未登录或 Token 无效
        - 前端会自动清除 Token 并弹出登录对话框
      - 500 Internal Server Error：评估过程出错
        - 前端会显示通用的错误提示，建议用户重试
    - 日志记录：
      - 后端会记录函数入口、参数类型、验证结果等详细信息
      - 使用【可行性评估】和【参数验证错误】前缀，便于日志搜索和排查
      - 不记录完整的图片数据，只记录数据长度和格式，避免日志过大
  - 前端流程（详细）：
    - 用户上传两张图 → 点击"开始 AI 分析"：
      1. **前端参数验证**（在 `handleAnalyze` 函数中）：
         - 检查 `sourceImage` 和 `targetImage` 对象是否存在
         - 检查 `sourceImage.preview` 和 `targetImage.preview` 是否存在且不为空
         - 如果验证失败，显示友好的错误提示，不发送请求
      2. **调用可行性评估接口**：
         - 调用 `/api/analyze/feasibility`，传递 `sourceImage.preview` 和 `targetImage.preview`（data URL 格式）
         - 前端使用 `FormData.append()` 将图片数据作为字符串字段发送
      3. **处理评估结果**：
         - 若返回 `dealBreakers.length > 0`：
           - 弹出"无法复刻（致命不兼容）"模态框，只提供"更换目标/重拍"等选项，可选"强制继续（不推荐）"；
         - 若无致命因子：
           - 弹出"复刻可行性评估"模态，显示 `feasibilityScore`、`difficulty`、`confidence`、Top-3 拖累项和推荐操作；
           - 用户选择：
             - "继续分析（接受风险）" → 调用 `POST /api/analyze/part1` 进入正式分析（同样需要验证 `preview` 属性）；
             - "按建议调整并重试" → 关闭模态，回到上传/裁切界面。
  - **前端实现注意事项**：
    - **参数验证**：在调用可行性评估接口之前，必须验证 `sourceImage.preview` 和 `targetImage.preview` 是否存在且不为空
    - **数据格式**：`preview` 属性是 `FileReader.readAsDataURL()` 生成的 data URL 字符串（如 `data:image/jpeg;base64,...`）
    - **错误处理**：如果图片数据未正确加载，应该显示友好的错误提示，而不是发送无效请求
    - **类型安全**：使用 TypeScript 类型检查，确保 `sourceImage` 和 `targetImage` 不为 `null` 后再访问 `preview` 属性
  - 结果复用：
    - `feasibility_result` 同时喂给 `ReviewSection` 与 `LightroomSection` 的“可行性徽章/建议卡片”，与第 24 节的 `results.review.feasibility`、`results.lightroom_extra.conversion_feasibility` 结构一一对应。

### 27. 用户菜单与个人中心设计（抽屉式面板）

- **整体信息架构**
  - 触发入口：主站右上角头像按钮（如 Figma 截图所示）；
  - 点击后在右侧弹出“用户抽屉”（Drawer），包含以下菜单项：
    - 个人中心：查看和编辑基础资料（头像、昵称、邮箱）、安全设置入口；
    - 我的订阅：查看当前套餐、到期时间、自动续费状态，支持升降级、取消自动续费、查看账单明细；
    - 资源用量：展示本月已用分析次数（Part1+Part2 计 1 次）与生成照片次数（Part3 调用数），与订阅套餐额度绑定；
    - 我的仿色：展示本账号的历史仿色任务列表，点击可查看详情并下载报告；
    - 退出登录。
  - 交互形式：
    - 所有菜单项都在同一个右侧 Drawer 中切换不同的内容面板，而非跳转完整新页面；
    - Drawer 支持 ESC/遮罩关闭，切换菜单时保留滚动位置与加载状态。

- **前端实现（组件与数据流）**
  - 顶层组件：
    - `TopNav` 中增加 `UserMenu` 触发按钮，点击后设置 `userDrawerOpen = true`；
    - 新增组件 `UserDrawer.tsx`（或同等命名），内部通过 tabs 或侧边菜单切换四个子面板：
      - `ProfilePanel`（个人中心）；
      - `SubscriptionPanel`（我的订阅）；
      - `UsagePanel`（资源用量）；
      - `ReportsPanel`（我的仿色）。
  - 状态管理：
    - 使用已有 `AuthContext` / `userStore` 提供当前用户基本信息（`user.id`, `display_name`, `email`, `subscription` 摘要）；
    - `UserDrawer` 内部通过 `useQuery` / `SWR` 或自封装 hook 按需请求：
      - `/api/user/me` → 个人资料、当前订阅简要信息；
      - `/api/user/usage` → 本月分析/生成次数与套餐额度；
      - `/api/user/reports` → 历史仿色任务列表；
      - `/api/payments/invoices` → 账单明细（可选，如果按顶层设计启用）。
  - UI 行为：
    - ProfilePanel：展示基础信息，提供“编辑资料”入口（V1 可仅展示）；
    - SubscriptionPanel：
      - 展示当前订阅名称、价格、剩余时长、额度使用情况（结合 `/api/user/usage`）；
      - 提供“升级套餐”、“降级套餐”、“取消自动续费”、“查看账单”的按钮，点击跳转到订阅页 / 账单页或弹出对应对话框；
    - UsagePanel：
      - 展示“本月已用分析次数 / 套餐总次数”、“本月已用生成照片次数 / 套餐总次数”；
      - 不区分 Part1/Part2：每个任务分析（完成 Part1+Part2 即计一次），Part3 计入“生成照片次数”；
    - ReportsPanel：
      - 列表展示当前用户的仿色任务（`analysis_tasks` 中 Part3 完成的任务），包含：缩略图、任务创建时间、可行性摘要、状态；
      - 每行提供“查看详情”按钮（跳转到结果页或弹出报告预览）和“下载报告”按钮（调用导出接口）。

- **后端接口设计（与现有表结构对齐）**
  - 基础用户信息：
    - `GET /api/user/me`（需要 `session`）：
      - 返回：
        - `user`: `{ id, email, display_name, avatar_url, role, created_at }`
        - `subscriptionSummary`: `{ plan_id, plan_name, status, end_at, auto_renew, limits: { analysis_per_month, generations_per_month } }`
      - 数据来源：`users`、`subscriptions`、`subscription_plans`。
  - 资源用量：
    - `GET /api/user/usage`：
      - 输入：隐式使用当前 `userId`，可选 `month`（默认当前月份）；
      - 返回：
        ```json
        {
          "analysisUsed": 12,
          "analysisLimit": 50,
          "generationUsed": 8,
          "generationLimit": 30,
          "period": "2025-11"
        }
        ```
      - 计算规则：
        - `analysisUsed`：统计本月完成 Part1+Part2 的任务数（从 `analysis_tasks` 按 `status=completed` 或 `part2_completed=1` 且 `created_at` 在当月）；  
        - `generationUsed`：统计本月调用风格模拟 Part3 成功次数（例如 `analysis_tasks` 中存在有效 `preview_image_url` 且时间在当月）；  
        - `analysisLimit` / `generationLimit`：从当前用户订阅的 `subscription_plans.features` 中读取；  
        - 不区分 Part1 与 Part2，统一算一次“分析任务”。
  - 我的订阅：
    - `GET /api/user/subscription`：
      - 返回当前订阅详细信息：计划名称、价格、周期、下次扣费时间、自动续费状态、历史变更记录（可选）；
    - `POST /api/user/subscription/change`：
      - 用于升级/降级计划，入参为 `target_plan_id`，内部创建支付订单或直接变更（视计费模型而定）；
    - `POST /api/user/subscription/cancel-auto-renew`：
      - 关闭自动续费，更新 `subscriptions.status` 或 `metadata`；
    - `GET /api/user/invoices`（可选）：
      - 列出账单明细（结合 `payments` 表）。
  - 我的仿色（报告中心视图）：
    - `GET /api/user/reports`：
      - 查询当前用户下所有已完成 Part3 的任务，支持分页：
        ```json
        {
          "items": [
            {
              "taskId": "uuid",
              "created_at": "2025-11-15T10:23:00Z",
              "feasibilityScore": 0.61,
              "difficulty": "中",
              "preview_image_url": "https://...",
              "source_image_thumbnail": "https://...",
              "status": "completed"
            }
          ],
          "page": 1,
          "pageSize": 20,
          "total": 42
        }
        ```
      - 数据来源：`analysis_tasks`（结合 `uploads` 缩略图字段），只筛选 `status='completed'` 且存在 `preview_image_url` 的记录。
    - 用户点击单个报告的“查看详情”：
      - 前端可重用现有 `GET /api/analyze/:taskId` 接口，加载完整分析结果；
    - “下载报告”：
      - 调用现有/规划中的导出接口（例如 `GET /api/report/pdf?taskId=&downloadToken=`）生成 PDF；
      - 可通过 `ColorCloningReport` 的 HTML 模板 + chartService（直方图/曲线/色轮）生成完整仿色报告。

- **订阅与用量绑定规则**
  - 订阅计划表 `subscription_plans.features` 中需至少包含：
    - `analysis_per_month`：每月允许的分析任务次数（Part1+Part2 合计）；  
    - `generations_per_month`：每月允许的风格模拟（Part3）次数；
  - `usageService`（后端）负责：
    - 每次任务完成 Part1+Part2 时增加分析计数；  
    - 每次 Part3 成功生成预览图时增加生成计数；  
    - 提供 `getUserUsage(userId, period)` 方法给 `/api/user/usage` 使用；
    - 在超出额度前返回友好错误码（如 `USAGE_ANALYSIS_LIMIT_EXCEEDED`、`USAGE_GENERATION_LIMIT_EXCEEDED`），前端据此在按钮处展示“升级套餐”提示。

- **权限与安全**
  - 所有 `/api/user/**` 接口都必须挂载 `authMiddleware`，仅允许 `type='session'` 的用户访问；
  - `GET /api/user/reports`、`/api/user/usage` 必须基于 `userId` 做严格过滤，防止越权查看他人用量或任务；
  - 下载报告时通过第 17 节定义的 `downloadToken` 机制保护链接安全。

#### 27.1 Admin 功能 → 接口对照 Check List

> 目的：为 Cursor/开发同学提供一张“功能 → 接口”一览表，避免在实现管理后台时发散开发或遗漏接口，仅需按照表中映射实现代码。

| Admin 页面/模块            | 前端组件                     | 关键按钮/交互                               | 后端接口（示例）                                                       | 说明 |
|---------------------------|------------------------------|---------------------------------------------|------------------------------------------------------------------------|------|
| Dashboard（运营概览）     | `Dashboard`                  | 仅展示指标与图表                             | `GET /api/admin/dashboard/metrics`                                     | 返回用户数、订阅数、任务数、收入等汇总指标 |
| 用户管理                  | `UsersManagement`            | 添加用户                                    | `POST /api/admin/users`                                               | 创建用户账号，写入 `users` 表 |
|                           |                              | 查看详情                                    | `GET /api/admin/users/:userId`                                        | 返回用户基本信息、订阅摘要、任务统计 |
|                           |                              | 停用账号                                    | `PATCH /api/admin/users/:userId { status: "disabled" }`               | 更新 `users.status` |
| 订阅管理 - 订阅计划       | `SubscriptionsManagement`    | 新建计划                                    | `POST /api/admin/plans`                                               | 创建 `subscription_plans` 记录 |
|                           |                              | 编辑计划                                    | `PUT /api/admin/plans/:planId`                                        | 修改名称/描述/价格/feature/limits |
|                           |                              | 启用/禁用计划                               | `PATCH /api/admin/plans/:planId/status`                               | 切换 `is_active` |
|                           |                              | （可选）恢复默认计划/清空计划               | `POST /api/admin/plans/reset-defaults` / `DELETE /api/admin/plans/*`  | 仅在 dev/运维场景使用 |
| 订阅管理 - 订阅用户       | `SubscriptionUsersList`      | 筛选（状态/计划）、搜索                     | `GET /api/admin/subscriptions/users?status=&planId=&q=`               | 基于 `subscriptions` + `users` 查询 |
|                           |                              | 导出数据                                    | `GET /api/admin/subscriptions/users/export`                           | 导出 CSV/JSON |
|                           |                              | 查看详情                                    | `GET /api/admin/subscriptions/users/:id`                              | 查看单个订阅用户详情 |
|                           |                              | 编辑信息（变更计划/状态）                   | `PUT /api/admin/subscriptions/users/:id`                              | 调整订阅计划、自动续费等 |
|                           |                              | 账单记录                                    | `GET /api/admin/users/:id/invoices`                                   | 基于 `payments` 表返回账单列表 |
|                           |                              | 删除订阅用户（或解除订阅）                  | `DELETE /api/admin/subscriptions/users/:id`                           | 谨慎使用，可仅做“取消订阅” |
| 支付管理 - 支付订单        | `PaymentsManagement`         | 筛选 / 搜索订单                             | `GET /api/admin/payments?status=&method=&q=`                          | 按状态/渠道/关键字查询 |
|                           |                              | 查看订单详情                                | `GET /api/admin/payments/:paymentId`                                  | 返回订单全量信息与回调日志摘要 |
|                           |                              | 发起退款（已完成订单）                      | `POST /api/admin/refunds` 或 `/api/admin/payments/:paymentId/refund` | 创建退款记录并触发渠道退款流程 |
|                           |                              | 导出订单数据                                | `GET /api/admin/payments/export`                                      | 导出 CSV |
| 支付管理 - 退款管理        | `PaymentsManagement`/Refunds Tab | 审核通过                                   | `POST /api/admin/refunds/:id/approve`                                 | 更新 `refunds.status="completed"` |
|                           |                              | 拒绝退款                                    | `POST /api/admin/refunds/:id/reject`                                  | 更新 `refunds.status="rejected"` |
| 支付管理 - 支付方式配置     | `PaymentsManagement`/Methods Tab | 启用/禁用支付方式                          | `PATCH /api/admin/payment-methods/:id { enabled: boolean }`           | 控制渠道可用性 |
| 任务管理                  | `TasksManagement`            | 筛选状态 / 搜索任务                         | `GET /api/admin/tasks?status=&q=`                                     | 从 `analysis_tasks` 查询 |
|                           |                              | 查看任务详情                                | `GET /api/admin/tasks/:taskId`                                        | 返回 `gemini_result` + `structured_result` + meta（第 19 节） |
|                           |                              | 重试失败任务                                | `POST /api/admin/tasks/:taskId/retry`                                 | 重新排队执行 Part2+Part3 Job |
| 内容管理                  | `ContentManagement` / `ContentEditor` | 加载内容块                           | `GET /api/admin/content?position=`                                    | 读取 `cms_blocks` |
|                           |                              | 创建/更新内容                               | `POST /api/admin/content` / `PUT /api/admin/content/:id`              | 新建或修改内容块 |
|                           |                              | 删除内容块                                  | `DELETE /api/admin/content/:id`                                       | 删除 CMS 记录 |
| 用量管理                  | `UsageManagement`            | 加载系统用量（任务数/分析量/生成量等）     | `GET /api/admin/usage/metrics`                                        | 基于 `analysis_tasks`、`uploads` 统计 |
| 数据分析                  | `Analytics`                  | 加载用户行为/来源数据                       | `GET /api/admin/analytics/metrics` 或更细分的 `/analytics/*`          | 顶层设计 12.1 中定义 |
| Admin 登录/退出           | `AdminLoginDialog` / `AdminPage` | 登录（第一步：邮箱+密码）                 | `POST /api/admin/auth/login`                                          | 返回 `mfaToken` |

## Lightroom 面板硬编码数据修复（2024-12-XX）

**问题**：前端 `LightroomPanel.tsx` 中使用了硬编码的模拟数据，而不是 Gemini 输出的实际数据。

**修复内容**：
1. **后端修复**（`analysis_formatter.py` - `_format_lightroom` 方法）：
   - 【新增】提取 `lightroom_workflow.simulated_histogram` 数据（直方图描述和 RGB 值），添加到 `structured.simulatedHistogram`
   - 确保所有 `lightroom_workflow` 中的数据都被正确提取和格式化

2. **前端数据适配器修复**（`dataAdapter.ts`）：
   - 【新增】从 `structured.simulatedHistogram` 中提取直方图数据，映射到 `result.lightroom.simulated_histogram`
   - 【新增】从 `color_scheme` 中提取白平衡数据（`white_balance`），映射到 `result.lightroom.white_balance`
   - 【新增】从 `color_scheme` 中提取色彩分级数据（`color_grading`），映射到 `result.lightroom.color_grading`
   - 【新增】从 `color_scheme` 中提取关键调整策略（`key_adjustment_strategy`），映射到 `result.lightroom.key_adjustment_strategy`

3. **前端组件修复**（`LightroomPanel.tsx`）：
   - 【修复】`TacticalBrief` 组件：使用 `data.simulated_histogram.description` 替换硬编码内容（直方图描述作为关键任务点）
   - 【修复】`TargetLockSlider` 组件：使用 `data.white_balance.temp` 和 `data.white_balance.tint` 替换硬编码值
     - 白平衡数据从 `color_science_scheme.white_balance` 中提取（通过 `color_scheme.white_balance` 映射）
     - 色温值：从 `range` 字符串解析（如 "+600"），加上基准值 5500K 得到实际色温值
     - 色调值：从 `range` 字符串解析（如 "+10"），直接使用
     - 如果 `range` 包含范围格式（如 "+600 ~ +900"），则解析 `target_min` 和 `target_max`
   - 【修复】`ColorModal` 组件：修复色彩分级面板为空的问题
     - **问题**：`ColorModal` 中 `safeData.color_grading` 可能不存在或为空，导致色彩分级面板显示为空
     - **修复方案**：
       - 在 `ColorModal` 中添加安全检查，确保 `color_grading` 数据存在
       - 从 `colorSchemeData.color_grading` 中提取数据，如果不存在则使用默认值
       - 创建 `finalSafeData` 对象，确保 `color_grading` 字段始终存在
       - 使用 `finalSafeData.color_grading` 传递给 `ColorGradeWheel` 组件
     - **数据流**：
       - 后端：`_format_color_part2` 从 `color_science_scheme.color_grading_wheels` 中提取数据，添加到 `structured.grading`
       - 前端 `dataAdapter`：从 `structured.grading` 映射到 `result.color_scheme.color_grading`
       - 前端 `ColorModal`：从 `data.color_scheme.color_grading` 或 `data.color_grading` 中获取数据
     - **后端日志**：添加日志记录 `color_grading_wheels` 的提取结果，包括 `hue`、`saturation`、`reason` 字段
   - 【修复】`ColorGradeWheel` 组件：使用 `data.color_grading.highlights/midtones/shadows` 替换硬编码值（210, 20, 45, 15, 180, 5 等）
   - 【修复】`SpectrumMatrix` 组件：使用 `data.hsl` 替换硬编码的 channels 数组

**数据流**：
1. Gemini 输出 → `lightroom_workflow.simulated_histogram`（包含 `description` 和 `rgb_values`）、`color_science_scheme.white_balance`、`color_science_scheme.color_grading_wheels`
2. 后端 `_format_lightroom` → 提取并格式化数据，添加到 `structured.simulatedHistogram`
3. 后端 `_format_color_part2` → 提取并格式化白平衡和色彩分级数据，添加到 `structured.whiteBalance` 和 `structured.grading`
4. 前端 `dataAdapter` → 将后端数据映射到前端格式，添加到 `result.lightroom`（`simulated_histogram`、`white_balance`、`color_grading`）
5. 前端 `LightroomPanel` → 从 `data` props 中读取数据，替换硬编码值：
   - `TacticalBrief` 使用 `data.simulated_histogram.description`（直方图描述作为关键任务点）
   - `TargetLockSlider` 使用 `data.white_balance.temp/tint`
   - `ColorGradeWheel` 使用 `data.color_grading.highlights/midtones/shadows`
   - `SpectrumMatrix` 使用 `data.hsl`

**注意事项**：
- 所有硬编码数据都已替换为从 Gemini 输出中提取的实际数据
- 如果数据不存在，使用默认值或空值，避免前端崩溃
- 确保所有文本支持中英文切换（使用 `t()` 函数）
|                           |                              | 登录（第二步：验证码）                   | `POST /api/admin/auth/verify-mfa`                                     | 返回 `adminAuthToken`（`admin_session` JWT） |
|                           |                              | （可选）退出登录                            | `POST /api/admin/auth/logout`                                         | 失效 `auth_tokens` 中对应记录 |


## 15. 故障排除指南 (Troubleshooting Guide)

### 15.1 常见错误与解决方案

#### 500 Internal Server Error: Connection refused (Gemini API)

**症状**：
- 前端显示 "AI 分析失败：无法连接到代理服务器..."
- 后端日志显示 `[Errno 61] Connection refused` 或 `ConnectionError`
- 后端日志显示 `HTTPS_PROXY=http://127.0.0.1:7890`

**原因**：
- 后端配置了使用代理（默认 `http://127.0.0.1:7890` 或 `7897`），但代理软件（如 ClashX/Clash Verge）未启动或未运行在指定端口。
- Gemini API 在国内无法直接访问，必须通过代理。

**解决方案**：
1. **启动代理软件**：确保 ClashX 或 Clash Verge 已启动。
2. **检查端口**：
   - **ClashX** 默认端口：`7890`
   - **Clash Verge** 默认端口：`7897`
   - 请检查 `.env` 文件中的 `HTTP_PROXY` 和 `HTTPS_PROXY` 变量是否与你的代理软件端口一致。
3. **验证连接**：在终端运行 `curl -x http://127.0.0.1:7897 https://www.google.com` (根据实际端口调整) 验证代理是否可用。

#### 404 Not Found (API Routes)

**症状**：
- 前端请求 API 返回 404。

**原因**：
- 后端服务未正确启动。
- 端口配置不一致（前端请求 8081，后端运行在 8000）。

**解决方案**：
- 确保后端使用 `python server_py/run.py` 启动（强制使用 8081 端口）。
- 检查 `http://localhost:8081/docs` 是否可访问。

### 15.2 日志排查

- **后端日志**：`/tmp/backend_8081.log`
  - 包含详细的请求信息、Gemini API 调用日志、错误堆栈。
  - 搜索 "【Part1 分析】" 或 "【Gemini 代理】" 关键字。

- **前端日志**：浏览器控制台 (Console)
  - 查看网络请求详情 (Network tab)。
  - 查看 API 响应的具体错误信息。

